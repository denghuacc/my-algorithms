/*
 * @lc app=leetcode.cn id=3318 lang=typescript
 *
 * [3318] 计算子数组的 x-sum I
 *
 * https://leetcode.cn/problems/find-x-sum-of-all-k-long-subarrays-i/description/
 *
 * algorithms
 * Easy (66.61%)
 * Likes:    7
 * Dislikes: 0
 * Total Accepted:    6.2K
 * Total Submissions: 8.8K
 * Testcase Example:  '[1,1,2,2,3,4,2,3]\n6\n2'
 *
 * 给你一个由 n 个整数组成的数组 nums，以及两个整数 k 和 x。
 *
 * 数组的 x-sum 计算按照以下步骤进行：
 *
 *
 * 统计数组中所有元素的出现次数。
 * 仅保留出现次数最多的前 x 个元素的每次出现。如果两个元素的出现次数相同，则数值 较大 的元素被认为出现次数更多。
 * 计算结果数组的和。
 *
 *
 * 注意，如果数组中的不同元素少于 x 个，则其 x-sum 是数组的元素总和。
 *
 * 返回一个长度为 n - k + 1 的整数数组 answer，其中 answer[i] 是 子数组 nums[i..i + k - 1] 的
 * x-sum。
 *
 * 子数组 是数组内的一个连续 非空 的元素序列。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [1,1,2,2,3,4,2,3], k = 6, x = 2
 *
 * 输出：[6,10,12]
 *
 * 解释：
 *
 *
 * 对于子数组 [1, 1, 2, 2, 3, 4]，只保留元素 1 和 2。因此，answer[0] = 1 + 1 + 2 + 2。
 * 对于子数组 [1, 2, 2, 3, 4, 2]，只保留元素 2 和 4。因此，answer[1] = 2 + 2 + 2 + 4。注意 4
 * 被保留是因为其数值大于出现其他出现次数相同的元素（3 和 1）。
 * 对于子数组 [2, 2, 3, 4, 2, 3]，只保留元素 2 和 3。因此，answer[2] = 2 + 2 + 2 + 3 + 3。
 *
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums = [3,8,7,8,7,5], k = 2, x = 2
 *
 * 输出：[11,15,15,15,12]
 *
 * 解释：
 *
 * 由于 k == x，answer[i] 等于子数组 nums[i..i + k - 1] 的总和。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= n == nums.length <= 50
 * 1 <= nums[i] <= 50
 * 1 <= x <= k <= nums.length
 *
 *
 */

// @lc code=start
function findXSum(nums: number[], k: number, x: number): number[] {
  // 初始化结果数组，用于存储每个子数组的 x-sum
  const res: number[] = [];
  // 获取数组长度
  const n = nums.length;
  // 计算子数组的数量：n - k + 1
  const m = n - k + 1;

  // 遍历每个可能的子数组起始位置
  for (let i = 0; i < m; i++) {
    // 提取当前子数组：从索引 i 开始，长度为 k
    const subArr = nums.slice(i, i + k);

    // 使用哈希表统计子数组中每个元素的出现频率
    const freqMap: Map<number, number> = new Map();
    for (const num of subArr) {
      freqMap.set(num, (freqMap.get(num) || 0) + 1);
    }

    // 将频率映射转换为数组形式，方便排序
    // 每个元素是 [数值, 频率] 的元组
    const freqArray: [number, number][] = Array.from(freqMap.entries());

    // 对频率数组进行排序：
    // 1. 首先按频率降序排序（出现次数多的排在前面）
    // 2. 如果频率相同，则按数值降序排序（数值大的排在前面）
    freqArray.sort((a, b) => (a[1] === b[1] ? b[0] - a[0] : b[1] - a[1]));

    // 计算 x-sum：取前 x 个最高频元素，计算它们的加权和
    // slice(0, x) 取前 x 个元素，reduce 计算总和
    const sum = freqArray
      .slice(0, x)
      .reduce((acc, [num, count]) => acc + num * count, 0);

    // 将当前子数组的 x-sum 添加到结果数组中
    res.push(sum);
  }

  // 返回所有子数组的 x-sum 结果
  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 给定一个数组和两个参数 k、x，需要计算每个长度为 k 的子数组的 "x-sum"
   - x-sum 的定义是：统计子数组中元素出现频率，取出现次数最多的前 x 个元素（相同频率时取数值较大的），计算这些元素的总和
   - 本质是一个滑动窗口 + 频率统计 + 排序选择的问题

2. 算法分析：
   - 时间复杂度：O((n-k+1) * (k + k*log k))，其中 n-k+1 是子数组数量，k 是统计频率的时间，k*log k 是排序的时间
   - 空间复杂度：O(k)，用于存储频率映射和排序数组
   - 算法类型：暴力枚举 + 哈希表 + 排序

3. 解题思路：
   - 核心思想：对每个长度为 k 的子数组，统计元素频率，排序后选择前 x 个最高频元素计算和
   - 关键观察：由于 n ≤ 50，k ≤ 50，时间复杂度在可接受范围内，可以对每个子数组都重新计算
   - 算法步骤：
     1. 遍历所有可能的子数组起始位置（0 到 n-k）
     2. 对每个子数组，使用哈希表统计元素频率
     3. 将频率数据转换为数组，按频率降序、数值降序排序
     4. 取前 x 个元素，计算它们的加权和（数值 × 频率）
     5. 将结果添加到答案数组中

4. 实现要点：
   - 数据结构选择：使用 Map 统计频率，因为元素范围是 1-50，但为了代码清晰和性能，使用 Map
   - 边界条件处理：当子数组中不同元素少于 x 时，取所有元素之和（slice(0, x) 会自动处理）
   - 排序逻辑：先按频率降序，再按数值降序，这是题目要求的"出现次数最多的前 x 个元素"的正确实现

5. 示例分析：
   示例 1：nums = [1,1,2,2,3,4,2,3], k = 6, x = 2

   子数组 [1,1,2,2,3,4]：
   - 频率：1->2, 2->2, 3->1, 4->1
   - 排序后：[1,2], [2,2], [3,1], [4,1]
   - 取前2个：1和2，x-sum = 1*2 + 2*2 = 6

   子数组 [1,2,2,3,4,2]：
   - 频率：1->1, 2->3, 3->1, 4->1
   - 排序后：[2,3], [1,1], [3,1], [4,1]
   - 取前2个：2和4（4比1和3大），x-sum = 2*3 + 4*1 = 10

   子数组 [2,2,3,4,2,3]：
   - 频率：2->3, 3->2, 4->1
   - 排序后：[2,3], [3,2], [4,1]
   - 取前2个：2和3，x-sum = 2*3 + 3*2 = 12

6. 常见陷阱：
   - 排序逻辑错误：必须先比较频率，再比较数值大小
   - 边界情况：当不同元素数量小于 x 时，应该取所有元素
   - 性能误解：虽然看起来是 O(n*k*log k)，但由于 n,k ≤ 50，实际运行很快

7. 扩展思考：
   - 如果 n 和 k 很大，如何优化？可以考虑使用滑动窗口维护频率，但排序仍然是瓶颈
   - 类似问题：各种"前 k 个"选择问题，如 top k frequent elements
   - 实际应用：数据分析中的频率统计、推荐系统中的热门项目选择等场景
   - 算法变种：如果要求 x-sum II，可能需要更高效的算法处理更大规模的数据
*/
