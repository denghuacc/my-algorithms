/*
 * @lc app=leetcode.cn id=3289 lang=typescript
 *
 * [3289] 数字小镇中的捣蛋鬼
 *
 * https://leetcode.cn/problems/the-two-sneaky-numbers-of-digitville/description/
 *
 * algorithms
 * Easy (86.63%)
 * Likes:    15
 * Dislikes: 0
 * Total Accepted:    14.4K
 * Total Submissions: 16.4K
 * Testcase Example:  '[0,1,1,0]'
 *
 * 数字小镇 Digitville 中，存在一个数字列表 nums，其中包含从 0 到 n - 1 的整数。每个数字本应 只出现一次，然而，有 两个
 * 顽皮的数字额外多出现了一次，使得列表变得比正常情况下更长。
 *
 * 为了恢复 Digitville 的和平，作为小镇中的名侦探，请你找出这两个顽皮的数字。
 *
 * 返回一个长度为 2 的数组，包含这两个数字（顺序任意）。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入： nums = [0,1,1,0]
 *
 * 输出： [0,1]
 *
 * 解释：
 *
 * 数字 0 和 1 分别在数组中出现了两次。
 *
 *
 * 示例 2：
 *
 *
 * 输入： nums = [0,3,2,1,3,2]
 *
 * 输出： [2,3]
 *
 * 解释:
 *
 * 数字 2 和 3 分别在数组中出现了两次。
 *
 *
 * 示例 3：
 *
 *
 * 输入： nums = [7,1,5,4,3,4,6,0,9,5,8,2]
 *
 * 输出： [4,5]
 *
 * 解释:
 *
 * 数字 4 和 5 分别在数组中出现了两次。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 2 <= n <= 100
 * nums.length == n + 2
 * 0 <= nums[i] < n
 * 输入保证 nums 中 恰好 包含两个重复的元素。
 *
 *
 */

// @lc code=start
// 方法一：哈希集合法
// 利用 Set 记录已出现的数字，当遇到重复时添加到结果
var getSneakyNumbers = function (nums: number[]): number[] {
  const freq = new Set<number>(); // 用于记录已经出现过的数字
  const res: number[] = []; // 存储重复出现的数字

  // 遍历数组中的每个数字
  for (const num of nums) {
    if (freq.has(num)) {
      // 如果数字已经在集合中，说明这是第二次出现，添加到结果
      res.push(num);
    } else {
      // 第一次出现，添加到集合中
      freq.add(num);
    }
  }

  return res;
};

// 方法二：位运算解法（异或分组法）
// 利用异或的性质：相同的数异或为0，0异或任何数为该数本身
var getSneakyNumbers = function (nums: number[]): number[] {
  const n = nums.length - 2; // 原本应该有 n 个不同的数字（0 到 n-1）

  // 步骤1：将 nums 的所有数字和 0 到 n-1 的所有数字进行异或
  // 结果为两个重复数字的异或值（因为其他数字都抵消了）
  let xor = 0;
  for (const num of nums) {
    xor ^= num;
  }
  for (let i = 0; i < n; i++) {
    xor ^= i;
  }

  // 步骤2：找到 xor 中最低位的1（lowBit）
  // 这一位表示两个重复数字在这一位上不同
  const lowBit = xor & -xor;

  // 步骤3：根据 lowBit 将所有数字分成两组，分别异或
  let num1 = 0;
  let num2 = 0;

  // 对 nums 中的数字分组异或
  for (const num of nums) {
    if (num & lowBit) {
      num1 ^= num;
    } else {
      num2 ^= num;
    }
  }

  // 对 0 到 n-1 的数字分组异或
  for (let i = 0; i < n; i++) {
    if (i & lowBit) {
      num1 ^= i;
    } else {
      num2 ^= i;
    }
  }

  // num1 和 num2 就是两个重复出现的数字
  return [num1, num2];
};
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 在一个包含 n+2 个元素的数组中，应该有 0 到 n-1 的 n 个不同数字
   - 但有两个数字额外多出现了一次（即出现了2次）
   - 找出这两个重复出现的数字

2. 算法分析：
   
   方法一：哈希集合法
   - 时间复杂度：O(n) - 遍历数组一次
   - 空间复杂度：O(n) - 使用 Set 存储已出现的数字
   - 算法类型：哈希表
   
   方法二：异或分组法
   - 时间复杂度：O(n) - 需要遍历数组多次，但总体仍是线性
   - 空间复杂度：O(1) - 只使用常量额外空间
   - 算法类型：位运算

3. 解题思路：

   方法一：哈希集合法（直观易懂）
   
   核心思想：
   - 使用 Set 记录已经出现过的数字
   - 当遇到已经在 Set 中的数字时，说明这是重复数字
   - 将重复数字添加到结果数组
   
   算法步骤：
   1. 初始化空的 Set 和结果数组
   2. 遍历 nums 中的每个数字
   3. 如果数字在 Set 中存在，添加到结果
   4. 如果数字不在 Set 中，添加到 Set
   5. 返回结果数组
   
   优点：
   - 代码简洁直观
   - 易于理解和实现
   - 一次遍历即可完成
   
   缺点：
   - 需要额外的 O(n) 空间

   方法二：异或分组法（空间优化）
   
   核心思想：
   - 利用异或运算的性质：a ^ a = 0, a ^ 0 = a
   - 将 nums 的所有数字和 0 到 n-1 的所有数字进行异或
   - 结果是两个重复数字的异或值（其他数字都抵消了）
   - 利用这个异或值的某一位将所有数字分成两组
   - 每组分别异或，得到两个重复数字
   
   算法步骤：
   1. 计算 nums 中所有数字和 0 到 n-1 所有数字的异或值 xor
      - xor = (重复数字1) ^ (重复数字2)
   
   2. 找到 xor 的最低位1（lowBit = xor & -xor）
      - 这一位表示两个重复数字在这一位上不同
      - 一个为0，一个为1
   
   3. 根据 lowBit 将所有数字分成两组：
      - 组1：该位为1的数字
      - 组2：该位为0的数字
      - 两个重复数字必然分在不同组
   
   4. 分别对两组进行异或运算
      - 每组内，正常数字会抵消（出现1次 + 出现1次）
      - 只剩下重复数字（出现2次 + 出现1次 = 出现1次）
   
   5. 返回两个异或结果
   
   优点：
   - 空间复杂度 O(1)
   - 不需要额外的数据结构
   
   缺点：
   - 代码相对复杂
   - 不够直观，需要理解位运算

4. 实现要点：

   哈希集合法要点：
   - 使用 Set 而不是 Map，因为只需要判断存在性
   - 遇到重复立即添加到结果，无需等到遍历结束
   - 题目保证恰好有两个重复数字，无需额外判断

   异或分组法要点：
   - 理解异或的性质：相同为0，不同为1
   - lowBit = xor & -xor 是获取最低位1的经典技巧
     * -xor 是 xor 的补码（取反加1）
     * xor & -xor 只保留最低位的1
   - 分组时确保将 nums 和 0~n-1 都按相同规则分组
   - 每组的异或结果就是该组的重复数字

5. 示例分析：

   示例1：nums = [0,1,1,0]
   
   方法一（哈希集合）：
   - i=0, num=0: Set为空，添加0 → Set={0}, res=[]
   - i=1, num=1: Set中无1，添加1 → Set={0,1}, res=[]
   - i=2, num=1: Set中有1，添加到结果 → res=[1]
   - i=3, num=0: Set中有0，添加到结果 → res=[1,0]
   - 返回 [1,0]
   
   方法二（异或分组）：
   - n = 2（原本应该有0和1）
   - 步骤1：xor = (0^1^1^0) ^ (0^1) = 0 ^ 1 = 1
   - 步骤2：lowBit = 1 & -1 = 1（二进制：0001）
   - 步骤3：按最低位分组
     * nums中：0(偶)和0(偶)归入num2组，1(奇)和1(奇)归入num1组
     * 0~1中：0(偶)归入num2组，1(奇)归入num1组
     * num1 = 1^1^1 = 1
     * num2 = 0^0^0 = 0
   - 返回 [1,0]

   示例2：nums = [0,3,2,1,3,2]
   
   方法一（哈希集合）：
   - 遍历过程：
     * 0: Set={0}
     * 3: Set={0,3}
     * 2: Set={0,3,2}
     * 1: Set={0,3,2,1}
     * 3: 重复，res=[3]
     * 2: 重复，res=[3,2]
   - 返回 [3,2]
   
   方法二（异或分组）：
   - n = 4（原本应该有0,1,2,3）
   - xor = (0^3^2^1^3^2) ^ (0^1^2^3) = (2^3) ^ (2^3) = 0 ... 
   - 实际上：(0^3^2^1^3^2) = 1, (0^1^2^3) = 0
   - xor = 1 ^ 0 = 1
   - lowBit = 1
   - 按最低位分组后得到 [2,3] 或 [3,2]

6. 算法要点总结：

   核心技巧：
   - 哈希集合：利用集合的查找特性快速判断重复
   - 异或分组：利用异或的抵消性质和位运算分组

   选择建议：
   - 如果空间不是限制：使用方法一（哈希集合），简单直观
   - 如果要求 O(1) 空间：使用方法二（异或分组），技巧性强

   位运算技巧：
   - xor & -xor：获取最低位的1
   - 异或性质：a ^ a = 0, a ^ 0 = a, a ^ b ^ a = b
   - 分组思想：利用某一位的不同将数字分成两组

   类似问题：
   - LeetCode 136: 只出现一次的数字（单个重复数字）
   - LeetCode 137: 只出现一次的数字 II（其他数字出现3次）
   - LeetCode 260: 只出现一次的数字 III（找两个只出现一次的数字）

7. 常见错误：

   错误1：使用数组而不是 Set
   ```typescript
   // ❌ 效率低下
   const freq: number[] = [];
   if (freq.includes(num)) { // O(n) 查找
     res.push(num);
   }
   ```
   - Set 的查找是 O(1)，数组的 includes 是 O(n)

   错误2：异或分组时忘记对 0~n-1 也分组
   ```typescript
   // ❌ 错误：只对 nums 分组
   for (const num of nums) {
     if (num & lowBit) num1 ^= num;
     else num2 ^= num;
   }
   // 忘记对 0~n-1 也分组
   ```
   - 必须保持对称，nums 和 0~n-1 都要分组

   错误3：lowBit 计算错误
   ```typescript
   // ❌ 错误
   const lowBit = xor & (~xor);  // 这会得到0
   // ✅ 正确
   const lowBit = xor & -xor;    // 获取最低位的1
   ```

8. 扩展思考：

   位运算的数学原理：
   - 为什么 xor & -xor 能得到最低位的1？
     * 假设 xor = ...1000（最低位的1在第3位）
     * -xor 是补码：先取反 ...0111，再加1得 ...1000
     * xor & -xor 只保留了最低位的1
   
   异或的本质：
   - 异或可以看作"无进位加法"
   - 在 GF(2) 有限域上，异或就是加法
   - 这就是为什么 a ^ a = 0（自己加自己等于0）

   变种问题：
   - 如果有3个重复数字怎么办？
     * 无法用简单的异或分组解决
     * 需要使用哈希表或其他方法
   
   - 如果重复次数不确定怎么办？
     * 哈希表统计频率是最通用的方法
     * 异或方法只适用于重复偶数次的情况

   性能对比：
   - 实际应用中，方法一（哈希集合）通常更快
     * 虽然方法二空间更优，但需要多次遍历
     * 现代计算机内存充足，O(n) 空间通常可接受
   - 方法二更多是面试中展示位运算技巧
*/
