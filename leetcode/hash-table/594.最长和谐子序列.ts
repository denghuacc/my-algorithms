/*
 * @lc app=leetcode.cn id=594 lang=typescript
 *
 * [594] 最长和谐子序列
 *
 * https://leetcode-cn.com/problems/longest-harmonious-subsequence/description/
 *
 * algorithms
 * Easy (51.94%)
 * Likes:    204
 * Dislikes: 0
 * Total Accepted:    33.9K
 * Total Submissions: 63.9K
 * Testcase Example:  '[1,3,2,2,5,2,3,7]'
 *
 * 和谐数组是指一个数组里元素的最大值和最小值之间的差别 正好是 1 。
 *
 * 现在，给你一个整数数组 nums ，请你在所有可能的子序列中找到最长的和谐子序列的长度。
 *
 * 数组的子序列是一个由数组派生出来的序列，它可以通过删除一些元素或不删除元素、且不改变其余元素的顺序而得到。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [1,3,2,2,5,2,3,7]
 * 输出：5
 * 解释：最长的和谐子序列是 [3,2,2,2,3]
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums = [1,2,3,4]
 * 输出：2
 *
 *
 * 示例 3：
 *
 *
 * 输入：nums = [1,1,1,1]
 * 输出：0
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1
 * -10^9
 *
 *
 */

// @lc code=start
// hash table
function findLHS(nums: number[]): number {
  // 使用哈希表统计每个数字的出现次数
  const map: Map<number, number> = new Map();
  let max = 0;

  // 第一遍遍历：统计每个数字的频次
  for (const num of nums) {
    map.set(num, (map.get(num) ?? 0) + 1);
  }

  // 第二遍遍历：检查每个数字是否能形成和谐子序列
  for (const [key, value] of map) {
    // 检查是否存在比当前数字大1的数字
    // 只需要检查 key+1，不需要检查 key-1，避免重复计算
    if (map.has(key + 1)) {
      // 和谐子序列的长度 = 当前数字的出现次数 + (当前数字+1)的出现次数
      max = Math.max(max, value + map.get(key + 1)!);
    }
  }

  return max;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 找到数组中最长的和谐子序列，和谐子序列定义为最大值和最小值差值正好为1的子序列
   - 由于差值必须为1，所以和谐子序列只能包含两种数字：x 和 x+1

2. 算法分析：
   - 时间复杂度：O(n) - 需要两次遍历数组
   - 空间复杂度：O(n) - 哈希表存储数字频次
   - 算法类型：哈希表统计

3. 实现要点：
   - 使用哈希表统计每个数字的出现频次
   - 对于每个数字x，检查是否存在x+1
   - 如果存在，计算x和x+1的总出现次数
   - 只检查x+1而不检查x-1，避免重复计算

4. 优化思路：
   - 两次遍历的方式保证了算法的清晰性
   - 使用Map而不是普通对象，处理负数更安全
   - 空值合并运算符(??)简化代码

5. 关键观察：
   - 和谐子序列最多只能包含两种连续的数字
   - 子序列不要求元素连续，只需保持相对顺序
   - 统计频次后，问题转化为找相邻数字对的最大频次和

6. 边界情况：
   - 数组长度为1：无法形成和谐子序列，返回0
   - 所有数字相同：无法形成和谐子序列，返回0
   - 只有两种连续数字：返回数组长度

7. 类似问题：
   - 可以应用到其他需要统计频次的问题
   - 扩展到差值为k的情况
*/
