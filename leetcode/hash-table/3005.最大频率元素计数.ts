/*
 * @lc app=leetcode.cn id=3005 lang=typescript
 *
 * [3005] 最大频率元素计数
 *
 * https://leetcode.cn/problems/count-elements-with-maximum-frequency/description/
 *
 * algorithms
 * Easy (70.79%)
 * Likes:    12
 * Dislikes: 0
 * Total Accepted:    13.4K
 * Total Submissions: 18.3K
 * Testcase Example:  '[1,2,2,3,1,4]'
 *
 * 给你一个由 正整数 组成的数组 nums 。
 *
 * 返回数组 nums 中所有具有 最大 频率的元素的 总频率 。
 *
 * 元素的 频率 是指该元素在数组中出现的次数。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [1,2,2,3,1,4]
 * 输出：4
 * 解释：元素 1 和 2 的频率为 2 ，是数组中的最大频率。
 * 因此具有最大频率的元素在数组中的数量是 4 。
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums = [1,2,3,4,5]
 * 输出：5
 * 解释：数组中的所有元素的频率都为 1 ，是最大频率。
 * 因此具有最大频率的元素在数组中的数量是 5 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 100
 * 1 <= nums[i] <= 100
 *
 *
 */

// @lc code=start
function maxFrequencyElements(nums: number[]): number {
  // 第一步：统计每个元素的频率
  // 使用哈希表存储每个数字及其出现次数
  const freq = new Map<number, number>();

  // 遍历数组，统计每个元素的频率
  for (const num of nums) {
    // 如果元素已存在，频率+1；否则初始化为1
    freq.set(num, (freq.get(num) ?? 0) + 1);
  }

  // 第二步：找到最大频率并计算总频率
  let res = 0; // 存储所有最大频率元素的总频率
  let maxVal = 0; // 存储当前找到的最大频率值

  // 遍历所有频率值，找到最大频率并累加
  for (const f of freq.values()) {
    if (f > maxVal) {
      // 发现更大的频率，更新最大值并重置结果
      maxVal = f;
      res = f;
    } else if (f === maxVal) {
      // 发现相同最大频率的元素，累加到结果中
      res += f;
    }
    // 如果 f < maxVal，说明不是最大频率，直接跳过
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 统计数组中每个元素的出现频率
   - 找到最大频率值
   - 计算所有具有最大频率的元素的总出现次数

2. 算法分析：
   - 时间复杂度：O(n) - 需要遍历数组一次统计频率，再遍历频率表一次找最大值
   - 空间复杂度：O(k) - 其中k是不同元素的数量，最多为n
   - 算法类型：哈希表 + 统计

3. 解题思路：
   - 核心思想：使用哈希表统计频率，然后找到最大频率并累加
   - 关键观察：只需要知道最大频率值，然后累加所有等于最大频率的元素频率
   - 算法步骤：
     1. 遍历数组，用哈希表统计每个元素的频率
     2. 遍历频率表，找到最大频率值
     3. 累加所有等于最大频率的元素频率

4. 实现要点：
   - 数据结构选择：Map<number, number> 存储元素到频率的映射
   - 边界条件处理：空数组情况（题目保证1 <= nums.length）
   - 优化技巧：一次遍历统计，一次遍历找最大值，避免多次遍历

5. 示例分析：
   示例1：nums = [1,2,2,3,1,4]
   - 频率统计：{1: 2, 2: 2, 3: 1, 4: 1}
   - 最大频率：2
   - 具有最大频率的元素：1和2，总频率 = 2 + 2 = 4
   
   示例2：nums = [1,2,3,4,5]
   - 频率统计：{1: 1, 2: 1, 3: 1, 4: 1, 5: 1}
   - 最大频率：1
   - 具有最大频率的元素：1,2,3,4,5，总频率 = 1+1+1+1+1 = 5

6. 常见陷阱：
   - 忘记重置结果：当发现更大频率时，需要重置res为新的最大频率值
   - 理解题意：要求的是"总频率"而不是"元素个数"
   - 边界情况：所有元素频率相同的情况

7. 扩展思考：
   - 如果要求返回最大频率的元素个数而不是总频率，只需统计等于最大频率的元素数量
   - 可以优化为一次遍历：在统计频率的同时维护最大频率和结果
   - 类似问题：找出现次数最多的元素、统计频率分布等
*/
