/*
 * @lc app=leetcode.cn id=2044 lang=typescript
 *
 * [2044] 统计按位或能得到最大值的子集数目
 *
 * https://leetcode-cn.com/problems/count-number-of-maximum-bitwise-or-subsets/description/
 *
 * algorithms
 * Medium (79.78%)
 * Likes:    46
 * Dislikes: 0
 * Total Accepted:    10.4K
 * Total Submissions: 13.1K
 * Testcase Example:  '[3,1]'
 *
 * 给你一个整数数组 nums ，请你找出 nums 子集 按位或 可能得到的 最大值 ，并返回按位或能得到最大值的 不同非空子集的数目 。
 *
 * 如果数组 a 可以由数组 b 删除一些元素（或不删除）得到，则认为数组 a 是数组 b 的一个 子集 。如果选中的元素下标位置不一样，则认为两个子集
 * 不同 。
 *
 * 对数组 a 执行 按位或 ，结果等于 a[0] OR a[1] OR ... OR a[a.length - 1]（下标从 0 开始）。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [3,1]
 * 输出：2
 * 解释：子集按位或能得到的最大值是 3 。有 2 个子集按位或可以得到 3 ：
 * - [3]
 * - [3,1]
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums = [2,2,2]
 * 输出：7
 * 解释：[2,2,2] 的所有非空子集的按位或都可以得到 2 。总共有 2^3 - 1 = 7 个子集。
 *
 *
 * 示例 3：
 *
 *
 * 输入：nums = [3,2,1,5]
 * 输出：6
 * 解释：子集按位或可能的最大值是 7 。有 6 个子集按位或可以得到 7 ：
 * - [3,5]
 * - [3,1,5]
 * - [3,2,5]
 * - [3,2,1,5]
 * - [2,5]
 * - [2,1,5]
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 16
 * 1 <= nums[i] <= 10^5
 *
 *
 */

// @lc code=start
/**
 * 深度优先搜索解法
 * 通过递归遍历所有可能的子集，找出按位或的最大值及其对应的子集数量
 */
function countMaxOrSubsets(nums: number[]): number {
  let maxOr = 0; // 记录按位或的最大值
  let cnt = 0; // 记录能达到最大值的子集数量

  // 从第0个位置开始深度优先搜索，初始按位或值为0
  dfs(0, 0);
  return cnt;

  /**
   * 深度优先搜索函数
   * @param pos 当前处理的数组位置
   * @param orVal 当前子集的按位或值
   */
  function dfs(pos: number, orVal: number) {
    // 递归终止条件：已经处理完所有元素
    if (pos === nums.length) {
      // 如果当前按位或值大于已知最大值，更新最大值并重置计数
      if (orVal > maxOr) {
        maxOr = orVal;
        cnt = 1;
      }
      // 如果当前按位或值等于最大值，增加计数
      else if (orVal === maxOr) {
        cnt += 1;
      }
      return;
    }

    // 选择当前元素：将当前元素加入子集，按位或值更新
    dfs(pos + 1, orVal | nums[pos]);

    // 不选择当前元素：跳过当前元素，按位或值保持不变
    dfs(pos + 1, orVal);
  }
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 需要找出数组所有子集中按位或值的最大值
   - 统计能达到这个最大值的不同子集数量
   - 子集包含选择或不选择每个元素的所有可能组合

2. 算法分析：
   - 时间复杂度：O(2^n)，其中n是数组长度，需要遍历所有2^n个子集
   - 空间复杂度：O(n)，递归调用栈的深度为数组长度
   - 算法类型：深度优先搜索（DFS）+ 回溯

3. 实现要点：
   - 使用DFS递归遍历所有可能的子集组合
   - 对于每个元素有两种选择：选择或不选择
   - 在递归过程中维护当前子集的按位或值
   - 到达递归边界时更新最大值和计数器
   - 按位或运算的性质：a | b >= max(a, b)，值只增不减

4. 核心思想：
   - 子集生成：通过递归的方式生成所有可能的子集
   - 状态维护：在递归过程中维护当前子集的按位或值
   - 最优解更新：当找到更大的按位或值时，重置计数器
   - 计数统计：当找到相同的最大按位或值时，增加计数器

5. 算法步骤：
   - 初始化最大按位或值maxOr = 0，计数器cnt = 0
   - 从位置0开始DFS，初始按位或值为0
   - 对于每个位置pos，有两种选择：
     a) 选择nums[pos]：递归调用dfs(pos+1, orVal | nums[pos])
     b) 不选择nums[pos]：递归调用dfs(pos+1, orVal)
   - 当pos == nums.length时到达边界：
     - 如果orVal > maxOr：更新maxOr = orVal，重置cnt = 1
     - 如果orVal == maxOr：增加cnt += 1

6. 边界情况处理：
   - 数组长度为1：只有一个子集[nums[0]]，其按位或值就是nums[0]
   - 所有元素相同：所有非空子集的按位或值都相同，总数为2^n - 1
   - 按位或值单调性：子集越大，按位或值不会减小

7. 优化思路：
   - 当前实现已经是最优的暴力解法
   - 可以预先计算所有元素的按位或作为理论最大值
   - 对于更大的数据规模，可考虑状态压缩DP或位运算优化
*/
