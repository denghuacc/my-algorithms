/*
 * @lc app=leetcode.cn id=417 lang=typescript
 *
 * [417] 太平洋大西洋水流问题
 *
 * https://leetcode-cn.com/problems/pacific-atlantic-water-flow/description/
 *
 * algorithms
 * Medium (50.36%)
 * Likes:    387
 * Dislikes: 0
 * Total Accepted:    41.5K
 * Total Submissions: 80.5K
 * Testcase Example:  '[[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]'
 *
 * 有一个 m × n 的矩形岛屿，与 太平洋 和 大西洋 相邻。 “太平洋” 处于大陆的左边界和上边界，而 “大西洋” 处于大陆的右边界和下边界。
 *
 * 这个岛被分割成一个由若干方形单元格组成的网格。给定一个 m x n 的整数矩阵 heights ， heights[r][c] 表示坐标 (r, c)
 * 上单元格 高于海平面的高度 。
 *
 * 岛上雨水较多，如果相邻单元格的高度 小于或等于 当前单元格的高度，雨水可以直接向北、南、东、西流向相邻单元格。水可以从海洋附近的任何单元格流入海洋。
 *
 * 返回 网格坐标 result 的 2D列表 ，其中 result[i] = [ri, ci] 表示雨水可以从单元格 (ri, ci) 流向
 * 太平洋和大西洋 。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 *
 * 输入: heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]
 * 输出: [[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]
 *
 *
 * 示例 2：
 *
 *
 * 输入: heights = [[2,1],[1,2]]
 * 输出: [[0,0],[0,1],[1,0],[1,1]]
 *
 *
 *
 *
 * 提示：
 *
 *
 * m == heights.length
 * n == heights[r].length
 * 1 <= m, n <= 200
 * 0 <= heights[r][c] <= 10^5
 *
 *
 */

// @lc code=start
/**
 * 解法：逆向 DFS（从海洋向内陆搜索）
 * 时间复杂度：O(m × n) - 每个单元格最多被访问一次
 * 空间复杂度：O(m × n) - 需要两个二维数组记录可达性状态
 *
 * 核心思想：逆向思维 + DFS
 * 关键洞察：从边界（海洋）开始向内陆搜索，找到所有能流到该海洋的位置
 */
function pacificAtlantic(heights: number[][]): number[][] {
  // 四个方向的移动向量：上、下、左、右
  const dirs = [
    [-1, 0], // 向上
    [1, 0], // 向下
    [0, -1], // 向左
    [0, 1], // 向右
  ];

  const m = heights.length; // 矩阵行数
  const n = heights[0].length; // 矩阵列数

  // pacific[i][j] 表示位置(i,j)的水能否流到太平洋
  const pacific: boolean[][] = Array.from(new Array(m), () =>
    new Array(n).fill(false)
  );

  // atlantic[i][j] 表示位置(i,j)的水能否流到大西洋
  const atlantic: boolean[][] = Array.from(new Array(m), () =>
    new Array(n).fill(false)
  );

  // 从太平洋边界开始 DFS：左边界（太平洋接壤）
  for (let i = 0; i < m; i++) {
    dfs(i, 0, pacific);
  }

  // 从太平洋边界开始 DFS：上边界（太平洋接壤）
  for (let j = 1; j < n; j++) {
    dfs(0, j, pacific);
  }

  // 从大西洋边界开始 DFS：右边界（大西洋接壤）
  for (let i = 0; i < m; i++) {
    dfs(i, n - 1, atlantic);
  }

  // 从大西洋边界开始 DFS：下边界（大西洋接壤）
  for (let j = 0; j < n; j++) {
    dfs(m - 1, j, atlantic);
  }

  // 收集结果：找到既能流到太平洋又能流到大西洋的位置
  const result = [];
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (pacific[i][j] && atlantic[i][j]) {
        result.push([i, j]);
      }
    }
  }
  return result;

  /**
   * DFS 搜索函数：从指定位置开始，标记所有能流到当前海洋的位置
   * @param row 当前行坐标
   * @param col 当前列坐标
   * @param ocean 海洋可达性数组（pacific 或 atlantic）
   */
  function dfs(row: number, col: number, ocean: boolean[][]) {
    // 如果当前位置已经被标记为可达，直接返回（避免重复搜索）
    if (ocean[row][col]) {
      return;
    }

    // 标记当前位置为可达
    ocean[row][col] = true;

    // 向四个方向搜索
    for (const dir of dirs) {
      const newRow = row + dir[0];
      const newCol = col + dir[1];

      // 检查新位置是否有效且满足水流条件
      if (
        newRow >= 0 && // 不超出上边界
        newRow < m && // 不超出下边界
        newCol >= 0 && // 不超出左边界
        newCol < n && // 不超出右边界
        heights[newRow][newCol] >= heights[row][col] // 水只能从高处流向低处或平地
      ) {
        dfs(newRow, newCol, ocean);
      }
    }
  }
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 需要找到所有既能流到太平洋又能流到大西洋的位置
   - 水只能从高度相等或更高的地方流向当前位置
   - 太平洋在矩阵的左边界和上边界，大西洋在右边界和下边界

2. 算法分析：
   - 时间复杂度：O(m × n) - 每个单元格最多被访问一次
   - 空间复杂度：O(m × n) - 需要两个二维数组 + 递归栈空间
   - 算法类型：深度优先搜索 (DFS) + 逆向思维

3. 解题思路：

   核心观察：逆向思维的威力
   - 正向思考：从每个位置出发，检查能否到达两个海洋（复杂度高）
   - 逆向思考：从海洋边界出发，找到所有能流到该海洋的位置（更高效）

   算法步骤：
   1. 初始化两个布尔矩阵 pacific 和 atlantic
   2. 从太平洋边界（左边界和上边界）开始 DFS，标记所有能流到太平洋的位置
   3. 从大西洋边界（右边界和下边界）开始 DFS，标记所有能流到大西洋的位置
   4. 遍历矩阵，收集同时被两个海洋标记的位置

4. 实现要点：

   DFS 搜索策略：
   - 从边界开始搜索，边界位置天然可达对应海洋
   - 搜索条件：heights[newRow][newCol] >= heights[row][col]
   - 使用 visited 数组避免重复搜索，提高效率

   边界处理：
   - 太平洋边界：左边界 (i, 0) 和上边界 (0, j)
   - 大西洋边界：右边界 (i, n-1) 和下边界 (m-1, j)
   - 注意避免重复处理角落位置

5. 示例分析：

   输入：heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]

   太平洋可达性分析：
   - 从 (0,0) 开始：标记 (0,0)→(1,0)→(2,0)→(3,0)→(4,0)
   - 从 (0,1) 开始：标记 (0,1)→(0,2)→(1,2)→(2,2)
   - 继续这个过程...

   大西洋可达性分析：
   - 从右边界和下边界开始类似的搜索过程

   最终结果：
   - 交集位置：[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]

6. 算法优势：

   效率优势：
   - 相比暴力解法（每个位置都做两次搜索），时间复杂度大大降低
   - 每个位置最多被访问一次，避免重复计算

   思路清晰：
   - 逆向思维使问题变得直观
   - 从边界开始搜索符合物理直觉

7. 关键技巧：

   逆向思维：
   - 与其问"这个位置能流到哪里"，不如问"哪些位置能流到这里"
   - 从结果（海洋）反推原因（内陆位置）

   状态记录：
   - 使用两个独立的 visited 数组分别记录到两个海洋的可达性
   - 最后求交集得到最终结果

8. 常见陷阱：

   搜索方向错误：
   - 必须是 heights[newRow][newCol] >= heights[row][col]
   - 水是从高处流向低处，所以搜索是逆流而上

   边界处理遗漏：
   - 确保覆盖所有边界位置
   - 避免重复处理角落位置

   状态管理错误：
   - 两个海洋的可达性状态要分开记录
   - 不能在搜索过程中提前求交集

9. 扩展思考：

   类似问题：
   - 岛屿问题系列（DFS/BFS 的经典应用）
   - 连通性问题（图论的基础）
   - 路径搜索问题

   优化方向：
   - 可以使用 BFS 实现相同逻辑
   - 对于超大矩阵，可以考虑并行化处理

   实际应用：
   - 地理信息系统中的流域分析
   - 网络连通性分析
   - 地形分析和水文模拟

10. 算法思想总结：

    逆向思维的价值：
    - 将复杂问题转化为简单问题
    - 从多个起点变为少数起点
    - 降低算法复杂度

    DFS 的应用技巧：
    - 合理使用 visited 数组避免重复
    - 边界条件的准确判断
    - 状态的正确维护和更新

    这个问题完美展示了如何通过改变思考角度来优化算法设计，
    是学习图搜索算法和逆向思维的经典案例。

11. 具体执行追踪：

    以示例1为例，详细追踪算法执行过程：

    初始状态：
    heights = [[1,2,2,3,5],
               [3,2,3,4,4],
               [2,4,5,3,1],
               [6,7,1,4,5],
               [5,1,1,2,4]]

    太平洋DFS过程：
    - 从左边界开始：(0,0)→(1,0)→(2,0)→(3,0)→(4,0)
    - 从上边界开始：(0,1)→(0,2)→(0,3)→(0,4), (0,2)→(1,2)→(2,2)
    
    大西洋DFS过程：
    - 从右边界开始：(0,4)→(1,4)→(2,4)
    - 从下边界开始：(4,0)→(3,0), (4,1)→(3,1), (4,4)→(3,4)

    最终交集：
    pacific ∩ atlantic = [(0,4), (1,3), (1,4), (2,2), (3,0), (3,1), (4,0)]

12. 代码优化要点：

    内存优化：
    - 可以使用位运算优化布尔数组的存储
    - 对于极大矩阵，可以考虑流式处理

    性能优化：
    - 可以提前终止某些分支的搜索
    - 使用启发式方法指导搜索方向

    这个解法体现了算法设计中"换个角度思考"的重要性，
    是深度优先搜索和逆向思维结合的经典范例。
*/
