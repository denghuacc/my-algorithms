/*
 * @lc app=leetcode.cn id=1957 lang=typescript
 *
 * [1957] 删除字符使字符串变好
 *
 * https://leetcode.cn/problems/delete-characters-to-make-fancy-string/description/
 *
 * algorithms
 * Easy (63.98%)
 * Likes:    38
 * Dislikes: 0
 * Total Accepted:    20.7K
 * Total Submissions: 31K
 * Testcase Example:  '"leeetcode"'
 *
 * 一个字符串如果没有 三个连续 相同字符，那么它就是一个 好字符串 。
 *
 * 给你一个字符串 s ，请你从 s 删除 最少 的字符，使它变成一个 好字符串 。
 *
 * 请你返回删除后的字符串。题目数据保证答案总是 唯一的 。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：s = "leeetcode"
 * 输出："leetcode"
 * 解释：
 * 从第一组 'e' 里面删除一个 'e' ，得到 "leetcode" 。
 * 没有连续三个相同字符，所以返回 "leetcode" 。
 *
 *
 * 示例 2：
 *
 *
 * 输入：s = "aaabaaaa"
 * 输出："aabaa"
 * 解释：
 * 从第一组 'a' 里面删除一个 'a' ，得到 "aabaaaa" 。
 * 从第二组 'a' 里面删除两个 'a' ，得到 "aabaa" 。
 * 没有连续三个相同字符，所以返回 "aabaa" 。
 *
 *
 * 示例 3：
 *
 *
 * 输入：s = "aab"
 * 输出："aab"
 * 解释：没有连续三个相同字符，所以返回 "aab" 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= s.length <= 10^5
 * s 只包含小写英文字母。
 *
 *
 */

export {};

// @lc code=start
/**
 * 方法1：计数器法
 * 使用当前字符和计数器来跟踪连续相同字符的数量
 */
var makeFancyString = function (s: string): string {
  let res = ""; // 结果字符串
  let cur = ""; // 当前处理的字符
  let cnt = 0; // 当前字符的连续出现次数

  for (const ch of s) {
    if (ch !== cur) {
      // 遇到新字符，更新当前字符并重置计数
      cur = ch;
      cnt = 1;
    } else {
      // 相同字符，计数递增
      cnt++;
    }

    // 只有连续出现次数小于3时才添加到结果中
    if (cnt < 3) {
      res += ch;
    }
    // 如果cnt >= 3，则跳过该字符（相当于删除）
  }

  return res;
};

/**
 * 方法2：结果数组检查法
 * 通过检查结果数组的最后两个字符来判断是否会形成三连续
 */
var makeFancyString = function (s: string): string {
  const res: string[] = []; // 使用数组存储结果，便于检查和操作

  for (const ch of s) {
    // 检查是否会形成三个连续相同字符
    // 条件：结果中至少有2个字符 && 最后两个字符都与当前字符相同
    if (
      res.length >= 2 &&
      res[res.length - 1] === ch &&
      res[res.length - 2] === ch
    ) {
      // 如果添加当前字符会形成三连续，则跳过（删除）
      continue;
    }

    // 否则可以安全添加当前字符
    res.push(ch);
  }

  return res.join("");
};
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 删除最少字符使字符串中没有三个连续相同字符
   - 贪心策略：遇到会形成三连续的字符就删除，保留最多两个连续字符

2. 算法分析：
   - 时间复杂度：O(n) - 需要遍历字符串一次
   - 空间复杂度：O(n) - 需要存储结果字符串
   - 算法类型：贪心算法 + 字符串处理

3. 两种实现方法：

   方法1 - 计数器法：
   - 维护当前字符cur和连续出现次数cnt
   - 遇到新字符时重置计数器
   - 只有连续次数<3时才添加字符到结果
   - 优点：逻辑清晰，容易理解
   - 适用场景：需要明确知道每个字符连续出现次数的情况

   方法2 - 结果检查法：
   - 直接检查结果数组的最后两个字符
   - 如果当前字符与最后两个字符相同则跳过
   - 否则添加当前字符到结果
   - 优点：代码更简洁，不需要额外变量
   - 适用场景：只关心是否形成三连续的情况

4. 关键观察：
   - 删除策略：当遇到第三个连续相同字符时删除
   - 保留策略：每种字符最多保留连续两个
   - 贪心正确性：局部最优（保留尽可能多的字符）即全局最优

5. 边界情况处理：
   - 字符串长度为1或2：直接返回原字符串
   - 所有字符相同且长度>=3：返回前两个字符
   - 没有三连续字符：返回原字符串

6. 优化要点：
   - 方法2使用数组而非字符串拼接，避免频繁字符串创建
   - 一次遍历完成，无需回溯或多次扫描
   - 空间复杂度已是最优（必须存储结果）

7. 扩展应用：
   - 可推广到"删除字符使得没有k个连续相同字符"
   - 类似问题：删除重复字符、字符串去重等
   - 核心思想：贪心 + 滑动窗口思维
*/
