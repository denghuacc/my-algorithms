/*
 * @lc app=leetcode.cn id=3461 lang=typescript
 *
 * [3461] 判断操作后字符串中的数字是否相等 I
 *
 * https://leetcode.cn/problems/check-if-digits-are-equal-in-string-after-operations-i/description/
 *
 * algorithms
 * Easy (75.51%)
 * Likes:    11
 * Dislikes: 0
 * Total Accepted:    12.3K
 * Total Submissions: 15.7K
 * Testcase Example:  '"3902"'
 *
 * 给你一个由数字组成的字符串 s 。重复执行以下操作，直到字符串恰好包含 两个 数字：
 *
 *
 * 从第一个数字开始，对于 s 中的每一对连续数字，计算这两个数字的和 模 10。
 * 用计算得到的新数字依次替换 s 的每一个字符，并保持原本的顺序。
 *
 *
 * 如果 s 最后剩下的两个数字 相同 ，返回 true 。否则，返回 false。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入： s = "3902"
 *
 * 输出： true
 *
 * 解释：
 *
 *
 * 一开始，s = "3902"
 * 第一次操作：
 *
 * (s[0] + s[1]) % 10 = (3 + 9) % 10 = 2
 * (s[1] + s[2]) % 10 = (9 + 0) % 10 = 9
 * (s[2] + s[3]) % 10 = (0 + 2) % 10 = 2
 * s 变为 "292"
 *
 *
 * 第二次操作：
 *
 * (s[0] + s[1]) % 10 = (2 + 9) % 10 = 1
 * (s[1] + s[2]) % 10 = (9 + 2) % 10 = 1
 * s 变为 "11"
 *
 *
 * 由于 "11" 中的数字相同，输出为 true。
 *
 *
 *
 * 示例 2：
 *
 *
 * 输入： s = "34789"
 *
 * 输出： false
 *
 * 解释：
 *
 *
 * 一开始，s = "34789"。
 * 第一次操作后，s = "7157"。
 * 第二次操作后，s = "862"。
 * 第三次操作后，s = "48"。
 * 由于 '4' != '8'，输出为 false。
 *
 *
 *
 *
 *
 * 提示：
 *
 *
 * 3 <= s.length <= 100
 * s 仅由数字组成。
 *
 *
 */

// @lc code=start
function hasSameDigits(s: string): boolean {
  // 第一步：将字符串转换为数字数组，方便后续计算
  let nums = s.split("").map(Number);

  // 第二步：循环执行操作，直到数组只剩下 2 个元素
  while (nums.length > 2) {
    // 创建新数组存储本轮操作的结果
    const newNums: number[] = [];

    // 第三步：对每一对相邻数字进行求和取模操作
    // 从索引 1 开始，计算 nums[i-1] + nums[i]
    for (let i = 1; i < nums.length; i++) {
      // 计算相邻两个数字的和并对 10 取模
      const num = (nums[i - 1] + nums[i]) % 10;
      newNums.push(num);
    }

    // 第四步：用新数组替换原数组，准备下一轮操作
    nums = newNums;
  }

  // 第五步：检查最后剩下的两个数字是否相等
  return nums[0] === nums[1];
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 给定一个数字字符串，重复执行"相邻数字求和取模10"的操作
   - 每次操作将 n 个数字压缩成 n-1 个数字
   - 最终判断剩余的两个数字是否相等
   - 这是一个典型的模拟过程问题

2. 算法分析：
   - 时间复杂度：O(n²)
     * 第一轮操作：n-1 次计算
     * 第二轮操作：n-2 次计算
     * ...
     * 总计：(n-1) + (n-2) + ... + 1 = n(n-1)/2 = O(n²)
   - 空间复杂度：O(n)
     * 需要存储每一轮操作后的数组
     * 最坏情况下需要 O(n) 的额外空间
   - 算法类型：模拟

3. 解题思路：

   核心思想：
   - 直接模拟题目描述的操作过程
   - 每次将相邻数字的和（模10）组成新数组
   - 重复操作直到数组长度为 2
   - 比较最后两个数字是否相等

   算法步骤：
   
   步骤1：初始化
   - 将字符串转换为数字数组，方便后续数值计算
   
   步骤2：循环操作
   - 当数组长度大于 2 时，继续执行操作
   
   步骤3：相邻求和
   - 对于每对相邻数字 (nums[i-1], nums[i])
   - 计算 (nums[i-1] + nums[i]) % 10
   - 将结果存入新数组
   
   步骤4：更新数组
   - 用新数组替换原数组
   - 数组长度减 1
   
   步骤5：判断结果
   - 当数组长度为 2 时，比较两个数字是否相等

4. 实现要点：

   数据结构选择：
   - 使用数组存储数字：便于索引访问和遍历
   - 每轮操作创建新数组：保持代码清晰，避免原地修改的复杂性
   
   边界条件处理：
   - 题目保证 3 <= s.length <= 100，无需处理长度小于 3 的情况
   - 每次操作都确保数组长度减 1，最终一定会到达长度为 2
   
   优化技巧：
   - 使用 % 10 运算确保结果在 [0, 9] 范围内
   - 可以原地修改数组减少空间开销，但会降低代码可读性

5. 示例分析：

   示例1：s = "3902"
   
   初始状态：nums = [3, 9, 0, 2]
   
   第一轮操作：
   - (3 + 9) % 10 = 12 % 10 = 2
   - (9 + 0) % 10 = 9 % 10 = 9
   - (0 + 2) % 10 = 2 % 10 = 2
   - nums = [2, 9, 2]
   
   第二轮操作：
   - (2 + 9) % 10 = 11 % 10 = 1
   - (9 + 2) % 10 = 11 % 10 = 1
   - nums = [1, 1]
   
   判断：1 === 1，返回 true ✓

   示例2：s = "34789"
   
   初始状态：nums = [3, 4, 7, 8, 9]
   
   第一轮操作：
   - (3 + 4) % 10 = 7
   - (4 + 7) % 10 = 11 % 10 = 1
   - (7 + 8) % 10 = 15 % 10 = 5
   - (8 + 9) % 10 = 17 % 10 = 7
   - nums = [7, 1, 5, 7]
   
   第二轮操作：
   - (7 + 1) % 10 = 8
   - (1 + 5) % 10 = 6
   - (5 + 7) % 10 = 12 % 10 = 2
   - nums = [8, 6, 2]
   
   第三轮操作：
   - (8 + 6) % 10 = 14 % 10 = 4
   - (6 + 2) % 10 = 8
   - nums = [4, 8]
   
   判断：4 !== 8，返回 false ✓

6. 算法要点总结：

   核心技巧：
   - 直接模拟：按题目要求逐步执行操作
   - 数组压缩：每次操作将 n 个元素压缩为 n-1 个元素
   - 取模运算：保证数字在有效范围内
   
   优化要点：
   - 时间复杂度已经是最优的 O(n²)，因为必须完成所有计算
   - 空间上可以原地修改减少开销（但不推荐，影响可读性）
   
   类似问题：
   - LeetCode 119: 杨辉三角 II（类似的逐层压缩计算）
   - LeetCode 598: 范围求和 II（类似的区间操作）
   - 帕斯卡三角形的各种变体

7. 常见错误：

   错误1：循环条件错误
   - 应该是 while (nums.length > 2) 而不是 >= 2
   - 需要在长度为 2 时停止，而不是继续
   
   错误2：忘记取模
   - 必须对 10 取模，否则数字可能超出 [0, 9] 范围
   - 示例：(9 + 9) = 18，应该是 18 % 10 = 8
   
   错误3：索引越界
   - 循环从 i=1 开始，访问 nums[i-1]，确保不会越界
   - 如果从 i=0 开始，nums[i-1] 会导致错误
   
   错误4：没有创建新数组
   - 每轮操作需要基于当前数组生成新数组
   - 不能在遍历过程中修改正在遍历的数组

8. 扩展思考：

   变种问题：
   - 如果要求返回最终的两个数字？修改返回值为数组 [nums[0], nums[1]]
   - 如果要求计算操作次数？在循环中增加计数器
   - 如果最终要求只剩一个数字？修改循环条件为 nums.length > 1
   
   优化空间：
   - 原地修改版本（空间 O(1)）：
     ```typescript
     while (nums.length > 2) {
       for (let i = 0; i < nums.length - 1; i++) {
         nums[i] = (nums[i] + nums[i + 1]) % 10;
       }
       nums.pop(); // 移除最后一个元素
     }
     ```
   
   数学性质：
   - 这个操作类似于数字的"折叠"过程
   - 最终结果与初始排列有关，具有确定性
   - 可以研究特定模式下的规律（如等差数列、等比数列等）

9. 数学洞察：

   有趣的观察：
   - 每次操作相当于在数字之间建立一种线性组合关系
   - 最终的两个数字可以表示为原始数字的加权和（权重由二项式系数决定）
   - 这与杨辉三角形（帕斯卡三角形）的性质有关
   
   例如，对于 4 个数字 [a, b, c, d]：
   - 第一轮：[a+b, b+c, c+d]
   - 第二轮：[(a+b)+(b+c), (b+c)+(c+d)] = [a+2b+c, b+2c+d]
   - 系数 [1,2,1] 和 [1,2,1] 正是杨辉三角的第 2 行
*/
