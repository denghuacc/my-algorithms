/*
 * @lc app=leetcode.cn id=1625 lang=typescript
 *
 * [1625] 执行操作后字典序最小的字符串
 *
 * https://leetcode.cn/problems/lexicographically-smallest-string-after-applying-operations/description/
 *
 * algorithms
 * Medium (55.29%)
 * Likes:    54
 * Dislikes: 0
 * Total Accepted:    5.8K
 * Total Submissions: 9.7K
 * Testcase Example:  '"5525"\n9\n2'
 *
 * 给你一个字符串 s 以及两个整数 a 和 b 。其中，字符串 s 的长度为偶数，且仅由数字 0 到 9 组成。
 *
 * 你可以在 s 上按任意顺序多次执行下面两个操作之一：
 *
 *
 * 累加：将  a 加到 s 中所有下标为奇数的元素上（下标从 0 开始）。数字一旦超过 9 就会变成 0，如此循环往复。例如，s = "3456" 且 a
 * = 5，则执行此操作后 s 变成 "3951"。
 * 轮转：将 s 向右轮转 b 位。例如，s = "3456" 且 b = 1，则执行此操作后 s 变成 "6345"。
 *
 *
 * 请你返回在 s 上执行上述操作任意次后可以得到的 字典序最小 的字符串。
 *
 * 如果两个字符串长度相同，那么字符串 a 字典序比字符串 b 小可以这样定义：在 a 和 b 出现不同的第一个位置上，字符串 a
 * 中的字符出现在字母表中的时间早于 b 中的对应字符。例如，"0158” 字典序比 "0190" 小，因为不同的第一个位置是在第三个字符，显然 '5'
 * 出现在 '9' 之前。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：s = "5525", a = 9, b = 2
 * 输出："2050"
 * 解释：执行操作如下：
 * 初态："5525"
 * 轮转："2555"
 * 累加："2454"
 * 累加："2353"
 * 轮转："5323"
 * 累加："5222"
 * 累加："5121"
 * 轮转："2151"
 * 累加："2050"​​​​​​​​​​​​
 * 无法获得字典序小于 "2050" 的字符串。
 *
 *
 * 示例 2：
 *
 *
 * 输入：s = "74", a = 5, b = 1
 * 输出："24"
 * 解释：执行操作如下：
 * 初态："74"
 * 轮转："47"
 * 累加："42"
 * 轮转："24"​​​​​​​​​​​​
 * 无法获得字典序小于 "24" 的字符串。
 *
 *
 * 示例 3：
 *
 *
 * 输入：s = "0011", a = 4, b = 2
 * 输出："0011"
 * 解释：无法获得字典序小于 "0011" 的字符串。
 *
 *
 * 示例 4：
 *
 *
 * 输入：s = "43987654", a = 7, b = 3
 * 输出："00553311"
 *
 *
 *
 *
 * 提示：
 *
 *
 * 2
 * s.length 是偶数
 * s 仅由数字 0 到 9 组成
 * 1
 * 1
 *
 *
 */

// @lc code=start
/**
 * 执行操作后字典序最小的字符串
 *
 * 算法核心：BFS暴力枚举 + 状态去重
 *
 * 关键观察：
 * 1. 轮转操作最多产生 n 种不同的状态（周期性）
 * 2. 累加操作最多产生 10 种不同的状态（数字0-9循环）
 * 3. 当b为奇数时，可以影响偶数位置；b为偶数时，只能影响奇数位置
 */
function findLexSmallestString(s: string, a: number, b: number): string {
  const n = s.length;

  // vis数组用于标记已经访问过的轮转起始位置，避免重复计算
  const vis = new Array(n).fill(false);

  // res保存找到的字典序最小的字符串
  let res = s;

  // 将字符串s延长一倍，方便通过切片操作获取轮转后的字符串
  // 例如："5525" -> "55255525"，则s.slice(2, 6) = "2555" 是向右轮转2位的结果
  s = s + s;

  // 外层循环：枚举所有可能的轮转状态
  // i表示当前轮转的起始位置，每次增加b个位置（轮转b位）
  // 循环直到回到已经访问过的位置（形成循环）
  for (let i = 0; !vis[i]; i = (i + b) % n) {
    vis[i] = true;

    // 中层循环：枚举对奇数位置累加的次数（0-9次）
    // 因为累加a会让数字在0-9之间循环，所以最多只需要尝试10次
    for (let j = 0; j < 10; j++) {
      // 判断是否可以修改偶数位置
      // 当b为奇数时，经过多次轮转，奇数位置会变成偶数位置，因此可以影响所有位置
      // 当b为偶数时，奇数位置永远是奇数位置，只能累加奇数位置
      const kLimit = b % 2 === 0 ? 0 : 9;

      // 内层循环：枚举对偶数位置累加的次数（0-9次或0次）
      for (let k = 0; k <= kLimit; k++) {
        // 从延长后的字符串中截取当前轮转位置对应的子串
        const t = [...s.slice(i, i + n)];

        // 对所有奇数位置（下标为1, 3, 5, ...）进行累加操作
        // 累加 j * a 次，结果对10取模保持在0-9范围内
        for (let p = 1; p < n; p += 2) {
          t[p] = String.fromCharCode(
            "0".charCodeAt(0) +
              ((t[p].charCodeAt(0) - "0".charCodeAt(0) + j * a) % 10)
          );
        }

        // 如果b为奇数，还可以对所有偶数位置（下标为0, 2, 4, ...）进行累加操作
        // 累加 k * a 次，结果对10取模
        for (let p = 0; p < n; p += 2) {
          t[p] = String.fromCharCode(
            "0".charCodeAt(0) +
              ((t[p].charCodeAt(0) - "0".charCodeAt(0) + k * a) % 10)
          );
        }

        // 将字符数组转换为字符串
        const tStr = t.join("");

        // 更新字典序最小的结果
        // 字符串比较会按字典序比较
        if (tStr < res) {
          res = tStr;
        }
      }
    }
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 这是一个状态空间搜索问题，需要找到所有可能操作后的最小字典序字符串
   - 可以执行两种操作：累加（修改奇数位置）和轮转（循环移动字符串）
   - 目标是找到字典序最小的字符串

2. 算法分析：
   - 时间复杂度：O(n² × 10 × 10) = O(100n²)
     * 轮转操作最多产生n种状态（通过gcd(n,b)可以计算精确值）
     * 累加奇数位最多10种状态（0-9次累加）
     * 累加偶数位最多10种状态（当b为奇数时）
     * 每次操作需要O(n)时间构造新字符串
   - 空间复杂度：O(n)
     * vis数组O(n)
     * 临时字符串数组O(n)
   - 算法类型：暴力枚举 + 状态去重

3. 解题思路：

   核心思想：
   - 穷举所有可能的操作序列组合，找到字典序最小的结果
   - 利用操作的周期性进行剪枝优化
   
   关键观察：
   a) 轮转操作的周期性
      - 连续执行轮转b次，经过n/gcd(n,b)次后会回到原状态
      - 因此只需要枚举 n/gcd(n,b) 种不同的轮转状态
      
   b) 累加操作的周期性
      - 每次累加a，数字会在0-9之间循环
      - 因此对同一位置，最多只需要累加10次（0-9次）
      
   c) b的奇偶性影响可修改的位置
      - 当b为偶数时：奇数位置永远保持奇数，只能修改奇数位置
      - 当b为奇数时：经过轮转后，原奇数位置可以变为偶数位置，可以修改所有位置
   
   算法步骤：
   1. 将字符串s延长一倍（s + s），方便通过切片获取轮转后的字符串
   2. 外层循环枚举所有可能的轮转状态（i每次增加b，直到访问过的位置）
   3. 对每个轮转状态，枚举所有可能的累加组合：
      - 枚举对奇数位置累加的次数j（0-9次）
      - 枚举对偶数位置累加的次数k（0-9次，仅当b为奇数时）
   4. 对每种组合生成新字符串，更新最小字典序结果

4. 实现要点：

   数据结构选择：
   - 使用vis数组标记已访问的轮转位置，避免重复计算
   - 使用字符数组操作，最后转换为字符串比较
   
   核心技巧：
   - 字符串延长技巧：s + s 可以通过切片实现轮转
     例如："5525" + "5525" = "55255525"
     s.slice(2, 6) = "2555" 相当于向右轮转2位
   
   - 数字累加公式：
     new_digit = (old_digit + j * a) % 10
     将字符转为数字，累加后取模，再转回字符
   
   - b的奇偶性判断：
     kLimit = b % 2 === 0 ? 0 : 9
     决定是否需要枚举偶数位置的累加次数

5. 示例分析：

   示例 1：s = "5525", a = 9, b = 2
   
   初始状态："5525"
   
   轮转过程（i的变化）：
   - i = 0: "5525" (slice(0, 4))
   - i = 2: "2555" (slice(2, 6))
   - i = 0: 已访问，停止
   
   累加组合（b=2为偶数，只能修改奇数位）：
   对于 "2555"，枚举j从0到9：
   - j=0: "2555"
   - j=1: "2454" (奇数位+9: 5→4, 5→4)
   - j=2: "2353" (奇数位+18: 5→3, 5→3)
   - ...
   
   最优解："2050"
   - 通过适当的轮转和累加组合得到

   图解关键步骤：
   ```
   原始: 5 5 2 5
        ↓ ↓ ↓ ↓
   位置: 0 1 2 3 (偶 奇 偶 奇)
   
   轮转2位: 2 5 5 5
           ↓ ↓ ↓ ↓
   位置:   0 1 2 3
   
   累加奇数位(+9): 2 4 5 4
   累加奇数位(+9): 2 3 5 3
   ...
   最终: 2 0 5 0
   ```

6. 算法要点总结：

   核心技巧：
   - 状态空间枚举：系统地遍历所有可能的操作组合
   - 周期性剪枝：利用操作的周期性减少搜索空间
   - 字符串延长技巧：简化轮转操作的实现
   
   优化要点：
   - 使用vis数组避免重复访问相同的轮转状态
   - 利用累加操作的周期性（模10），最多枚举10次
   - 根据b的奇偶性决定是否需要枚举偶数位置
   
   需要注意的边界情况：
   - b可能是奇数或偶数，影响可修改的位置范围
   - gcd(n, b)决定了实际的轮转周期
   - 初始状态可能已经是最小字典序

7. 常见错误：

   容易犯的错误：
   - 忘记考虑b的奇偶性，错误地认为总能修改所有位置
   - 没有利用周期性，导致无限循环或超时
   - 字符串比较时没有正确处理字典序
   
   避免错误的方法：
   - 仔细分析b为偶数和奇数时的不同情况
   - 使用vis数组确保循环终止
   - 使用JavaScript的字符串自然字典序比较

8. 复杂度优化：

   可能的优化方向：
   - 使用BFS/DFS配合Set去重，可能更清晰
   - 预先计算gcd(n, b)确定精确的轮转周期
   - 使用位运算优化数字操作
   
   本题数据规模较小(n ≤ 100)，暴力枚举足够高效

9. 类似问题：
   - LeetCode 2734: 执行子串操作后的字典序最小字符串
   - LeetCode 1758: 生成交替二进制字符串的最少操作数
   - 涉及状态空间搜索和字符串变换的问题

10. 扩展思考：
   - 如果允许向左轮转，算法需要如何调整？
   - 如果a和n不互质，是否可以进一步优化？
   - 能否使用数学方法直接计算出最小字典序，而不需要枚举？
*/
