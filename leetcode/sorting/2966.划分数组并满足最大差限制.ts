/*
 * @lc app=leetcode.cn id=2966 lang=typescript
 *
 * [2966] 划分数组并满足最大差限制
 *
 * https://leetcode.cn/problems/divide-array-into-arrays-with-max-difference/description/
 *
 * algorithms
 * Medium (68.13%)
 * Likes:    14
 * Dislikes: 0
 * Total Accepted:    11K
 * Total Submissions: 14.3K
 * Testcase Example:  '[1,3,4,8,7,9,3,5,1]\n2'
 *
 * 给你一个长度为 n 的整数数组 nums，以及一个正整数 k 。
 *
 * 将这个数组划分为 n / 3 个长度为 3 的子数组，并满足以下条件：
 *
 *
 * 子数组中 任意 两个元素的差必须 小于或等于 k 。
 *
 *
 * 返回一个 二维数组 ，包含所有的子数组。如果不可能满足条件，就返回一个空数组。如果有多个答案，返回 任意一个 即可。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [1,3,4,8,7,9,3,5,1], k = 2
 *
 * 输出：[[1,1,3],[3,4,5],[7,8,9]]
 *
 * 解释：
 *
 * 每个数组中任何两个元素之间的差小于或等于 2。
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums = [2,4,2,2,5,2], k = 2
 *
 * 输出：[]
 *
 * 解释：
 *
 * 将 nums 划分为 2 个长度为 3 的数组的不同方式有：
 *
 *
 * [[2,2,2],[2,4,5]] （及其排列）
 * [[2,2,4],[2,2,5]] （及其排列）
 *
 *
 * 因为有四个 2，所以无论我们如何划分，都会有一个包含元素 2 和 5 的数组。因为 5 - 2 = 3 > k，条件无法被满足，所以没有合法的划分。
 *
 *
 * 示例 3：
 *
 *
 * 输入：nums = [4,2,9,8,2,12,7,12,10,5,8,5,5,7,9,2,5,11], k = 14
 *
 * 输出：[[2,2,12],[4,8,5],[5,9,7],[7,8,5],[5,9,10],[11,12,2]]
 *
 * 解释：
 *
 * 每个数组中任何两个元素之间的差小于或等于 14。
 *
 *
 *
 *
 * 提示：
 *
 *
 * n == nums.length
 * 1 <= n <= 10^5
 * n 是 3 的倍数
 * 1 <= nums[i] <= 10^5
 * 1 <= k <= 10^5
 *
 *
 */

// @lc code=start
// greedy
function divideArray(nums: number[], k: number): number[][] {
  // 1. 对数组进行排序，使相近的数字聚集在一起
  nums.sort((a, b) => a - b);

  const n = nums.length;
  const res: number[][] = [];

  // 2. 每次处理3个连续的元素
  // 从索引1开始，每次跳跃3步（i-1, i, i+1构成一组）
  for (let i = 1; i < n - 1; i += 3) {
    // 3. 检查当前3个元素的最大差值
    // 在排序后的数组中，最大值是nums[i+1]，最小值是nums[i-1]
    if (nums[i + 1] - nums[i - 1] > k) {
      // 如果最大差值超过k，则无法满足条件，返回空数组
      return [];
    }

    // 4. 将满足条件的3个元素组成子数组
    res.push([nums[i - 1], nums[i], nums[i + 1]]);
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 将长度为n的数组划分为n/3个长度为3的子数组
   - 每个子数组中任意两个元素的差值都不能超过k
   - 如果无法满足条件则返回空数组

2. 算法分析：
   - 时间复杂度：O(n log n) - 主要由排序操作决定
   - 空间复杂度：O(1) - 除了结果数组外，只使用常数额外空间
   - 算法类型：贪心算法

3. 实现要点：
   - 关键观察：排序后相邻的元素更容易满足差值限制
   - 贪心策略：每次选择3个连续的最小元素组成子数组
   - 验证条件：只需检查3个元素中最大值与最小值的差
   - 边界处理：一旦发现无法满足条件立即返回空数组

4. 算法步骤：
   - 步骤1：对数组进行升序排序
   - 步骤2：每3个连续元素为一组进行处理
   - 步骤3：检查每组中最大值与最小值的差是否≤k
   - 步骤4：如果满足条件则加入结果，否则返回空数组

5. 正确性证明：
   - 排序后的贪心选择是最优的：如果连续的3个最小元素都无法满足条件，
     那么包含更大元素的任何组合都不可能满足条件
   - 局部最优导致全局最优：每次选择当前最小的3个可用元素

6. 优化思路：
   - 排序是必要的，无法进一步优化时间复杂度
   - 可以在检查过程中提前返回，避免不必要的计算
   - 空间复杂度已经是最优的O(1)
*/
