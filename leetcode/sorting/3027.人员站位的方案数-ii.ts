/*
 * @lc app=leetcode.cn id=3027 lang=typescript
 *
 * [3027] 人员站位的方案数 II
 *
 * https://leetcode.cn/problems/find-the-number-of-ways-to-place-people-ii/description/
 *
 * algorithms
 * Hard (43.99%)
 * Likes:    16
 * Dislikes: 0
 * Total Accepted:    7.8K
 * Total Submissions: 13.2K
 * Testcase Example:  '[[1,1],[2,2],[3,3]]'
 *
 * 给你一个  n x 2 的二维数组 points ，它表示二维平面上的一些点坐标，其中 points[i] = [xi, yi] 。
 *
 * 我们定义 x 轴的正方向为 右 （x 轴递增的方向），x 轴的负方向为 左 （x 轴递减的方向）。类似的，我们定义 y 轴的正方向为 上 （y
 * 轴递增的方向），y 轴的负方向为 下 （y 轴递减的方向）。
 *
 * 你需要安排这 n 个人的站位，这 n 个人中包括 Alice 和 Bob 。你需要确保每个点处 恰好 有 一个 人。同时，Alice 想跟 Bob
 * 单独玩耍，所以 Alice 会以 Alice 的坐标为 左上角 ，Bob 的坐标为 右下角 建立一个矩形的围栏（注意，围栏可能 不
 * 包含任何区域，也就是说围栏可能是一条线段）。如果围栏的 内部 或者 边缘 上有任何其他人，Alice 都会难过。
 *
 * 请你在确保 Alice 不会 难过的前提下，返回 Alice 和 Bob 可以选择的 点对 数目。
 *
 * 注意，Alice 建立的围栏必须确保 Alice 的位置是矩形的左上角，Bob 的位置是矩形的右下角。比方说，以 (1, 1) ，(1, 3) ，(3,
 * 1) 和 (3, 3) 为矩形的四个角，给定下图的两个输入，Alice 都不能建立围栏，原因如下：
 *
 *
 * 图一中，Alice 在 (3, 3) 且 Bob 在 (1, 1) ，Alice 的位置不是左上角且 Bob 的位置不是右下角。
 * 图二中，Alice 在 (1, 3) 且 Bob 在 (1, 1) ，Bob 的位置不是在围栏的右下角。
 *
 *
 *
 *
 * 示例 1：
 *
 *
 *
 *
 * 输入：points = [[1,1],[2,2],[3,3]]
 * 输出：0
 * 解释：没有办法可以让 Alice 的围栏以 Alice 的位置为左上角且 Bob 的位置为右下角。所以我们返回 0 。
 *
 *
 * 示例 2：
 *
 *
 *
 *
 * 输入：points = [[6,2],[4,4],[2,6]]
 * 输出：2
 * 解释：总共有 2 种方案安排 Alice 和 Bob 的位置，使得 Alice 不会难过：
 * - Alice 站在 (4, 4) ，Bob 站在 (6, 2) 。
 * - Alice 站在 (2, 6) ，Bob 站在 (4, 4) 。
 * 不能安排 Alice 站在 (2, 6) 且 Bob 站在 (6, 2) ，因为站在 (4, 4) 的人处于围栏内。
 *
 *
 * 示例 3：
 *
 *
 *
 *
 * 输入：points = [[3,1],[1,3],[1,1]]
 * 输出：2
 * 解释：总共有 2 种方案安排 Alice 和 Bob 的位置，使得 Alice 不会难过：
 * - Alice 站在 (1, 1) ，Bob 站在 (3, 1) 。
 * - Alice 站在 (1, 3) ，Bob 站在 (1, 1) 。
 * 不能安排 Alice 站在 (1, 3) 且 Bob 站在 (3, 1) ，因为站在 (1, 1) 的人处于围栏内。
 * 注意围栏是可以不包含任何面积的，上图中第一和第二个围栏都是合法的。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 2 <= n <= 1000
 * points[i].length == 2
 * -10^9 <= points[i][0], points[i][1] <= 10^9
 * points[i] 点对两两不同。
 *
 *
 */

// @lc code=start
function numberOfPairs(points: number[][]): number {
  let res = 0;
  const n = points.length;

  // 关键：按照 x 坐标升序，y 坐标降序排序
  // 这样排序后，对于任意两个点 A 和 B，如果 A 在 B 前面，那么：
  // - A 的 x 坐标 <= B 的 x 坐标
  // - 如果 x 坐标相等，A 的 y 坐标 >= B 的 y 坐标
  // 这确保了 A 可以作为左上角，B 可以作为右下角
  points.sort((a, b) => a[0] - b[0] || b[1] - a[1]);

  // 遍历所有可能的点对
  for (let i = 0; i < n - 1; i++) {
    const pointA = points[i]; // Alice 的位置（左上角）

    // 定义围栏的边界范围
    // xRange: [x_min, x_max] - 围栏的 x 轴范围
    // yRange: [y_min, y_max] - 围栏的 y 轴范围
    // 初始时，围栏只包含 Alice 自己
    const xRange = [pointA[0] - 1, Infinity]; // x 轴左边界设为 Alice 左边，右边界设为无穷大
    const yRange = [-Infinity, pointA[1] + 1]; // y 轴下边界设为负无穷，上边界设为 Alice 上方

    // 寻找可以作为 Bob 位置的点（右下角）
    for (let j = i + 1; j < n; j++) {
      const pointB = points[j]; // Bob 的位置（右下角）

      // 检查 Bob 是否在当前的围栏范围内
      // 如果 Bob 在围栏内，说明这个围栏是合法的
      if (
        pointB[0] > xRange[0] && // Bob 的 x 坐标在围栏 x 轴范围内
        pointB[0] < xRange[1] && // Bob 的 x 坐标在围栏 x 轴范围内
        pointB[1] > yRange[0] && // Bob 的 y 坐标在围栏 y 轴范围内
        pointB[1] < yRange[1] // Bob 的 y 坐标在围栏 y 轴范围内
      ) {
        res++; // 找到一个合法的点对

        // 更新围栏边界，缩小范围以排除 Bob 位置
        // 这样确保围栏内没有其他人
        xRange[0] = pointB[0]; // 将 x 轴左边界移到 Bob 的 x 坐标
        yRange[0] = pointB[1]; // 将 y 轴下边界移到 Bob 的 y 坐标
      }
    }
  }
  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 在二维平面上安排 n 个人的站位，其中 Alice 和 Bob 要形成一个矩形围栏
   - Alice 必须在围栏的左上角，Bob 必须在围栏的右下角
   - 围栏内部和边缘不能有其他任何人
   - 求满足条件的 Alice 和 Bob 点对数量

2. 算法分析：
   - 时间复杂度：O(n²)，其中 n 是点的数量
   - 空间复杂度：O(1)，只使用了常数额外空间
   - 算法类型：排序 + 双指针/枚举

3. 实现要点：
   - 关键洞察：通过排序确保点对的相对位置关系
   - 排序策略：按 x 坐标升序，y 坐标降序
   - 围栏边界管理：动态更新围栏范围，确保内部无人
   - 合法性检查：验证 Bob 位置是否在围栏范围内

4. 核心算法步骤：
   a) 排序：确保对于任意点对 (A, B)，A 可以作为左上角，B 可以作为右下角
   b) 枚举：遍历所有可能的点对组合
   c) 验证：检查 Bob 位置是否在围栏范围内
   d) 更新：动态调整围栏边界，排除已占用的位置

5. 排序的重要性：
   - 按 x 升序：确保 A 的 x 坐标 <= B 的 x 坐标
   - 按 y 降序：当 x 相等时，确保 A 的 y 坐标 >= B 的 y 坐标
   - 这样排序后，对于任意 i < j，points[i] 都可以作为左上角，points[j] 都可以作为右下角

6. 围栏边界管理：
   - 初始围栏：以 Alice 位置为中心的最小围栏
   - 动态更新：每当找到一个合法的 Bob 位置，就缩小围栏范围
   - 边界收缩：确保围栏内没有其他人，只有 Alice 和 Bob

7. 优化思路：
   - 当前实现已经是最优的，因为必须检查所有可能的点对
   - 排序预处理使得后续的合法性检查变得简单
   - 动态边界更新避免了重复计算

8. 边界情况处理：
   - 空数组：返回 0
   - 单点：返回 0（无法形成围栏）
   - 两点：检查是否满足条件
   - 多点：需要考虑所有可能的组合

9. 类似问题：
   - 矩形面积计算
   - 点对距离问题
   - 几何约束满足问题
   - 区间覆盖问题

10. 常见错误：
    - 忘记排序或排序策略错误
    - 围栏边界更新逻辑错误
    - 合法性检查条件不完整
    - 边界值处理不当（如 Infinity 的使用）
*/
