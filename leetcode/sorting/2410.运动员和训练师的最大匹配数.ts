/*
 * @lc app=leetcode.cn id=2410 lang=typescript
 *
 * [2410] 运动员和训练师的最大匹配数
 *
 * https://leetcode.cn/problems/maximum-matching-of-players-with-trainers/description/
 *
 * algorithms
 * Medium (68.89%)
 * Likes:    29
 * Dislikes: 0
 * Total Accepted:    14.2K
 * Total Submissions: 19.9K
 * Testcase Example:  '[4,7,9]\n[8,2,5,8]'
 *
 * 给你一个下标从 0 开始的整数数组 players ，其中 players[i] 表示第 i 名运动员的 能力 值，同时给你一个下标从 0
 * 开始的整数数组 trainers ，其中 trainers[j] 表示第 j 名训练师的 训练能力值 。
 *
 * 如果第 i 名运动员的能力值 小于等于 第 j 名训练师的能力值，那么第 i 名运动员可以 匹配 第 j
 * 名训练师。除此以外，每名运动员至多可以匹配一位训练师，每位训练师最多可以匹配一位运动员。
 *
 * 请你返回满足上述要求 players 和 trainers 的 最大 匹配数。
 *
 *
 *
 * 示例 1：
 *
 * 输入：players = [4,7,9], trainers = [8,2,5,8]
 * 输出：2
 * 解释：
 * 得到两个匹配的一种方案是：
 * - players[0] 与 trainers[0] 匹配，因为 4 <= 8 。
 * - players[1] 与 trainers[3] 匹配，因为 7 <= 8 。
 * 可以证明 2 是可以形成的最大匹配数。
 *
 *
 * 示例 2：
 *
 * 输入：players = [1,1,1], trainers = [10]
 * 输出：1
 * 解释：
 * 训练师可以匹配所有 3 个运动员
 * 每个运动员至多只能匹配一个训练师，所以最大答案是 1 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= players.length, trainers.length <= 10^5
 * 1 <= players[i], trainers[j] <= 10^9
 *
 *
 */

// @lc code=start
function matchPlayersAndTrainers(
  players: number[],
  trainers: number[]
): number {
  // 对两个数组进行升序排序
  // 排序后便于使用贪心策略：优先让能力强的运动员匹配能力强的训练师
  players.sort((a, b) => a - b);
  trainers.sort((a, b) => a - b);

  // 使用双指针从最大值开始匹配
  let i = players.length - 1; // 指向能力最强的运动员
  let j = trainers.length - 1; // 指向能力最强的训练师
  let count = 0; // 匹配计数

  // 贪心策略：从能力最强的运动员开始，尝试匹配能力最强的可用训练师
  while (i >= 0 && j >= 0) {
    // 如果当前运动员能力 <= 当前训练师能力，可以匹配
    if (players[i] <= trainers[j]) {
      count++; // 匹配成功，计数加1
      j--; // 训练师已被使用，指针左移
    }
    // 无论是否匹配成功，都要移动到下一个运动员
    i--;
  }

  return count;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 这是一个典型的贪心算法问题，要求在一对一匹配的约束下，找到最大匹配数
   - 核心思想：优先让能力强的运动员匹配能力强的训练师，这样可以最大化利用训练师资源
   - 匹配条件：运动员能力值 <= 训练师能力值

2. 算法分析：
   - 时间复杂度：O(n log n + m log m)，主要消耗在排序上，n为运动员数量，m为训练师数量
   - 空间复杂度：O(1)，只使用了常数级别的额外空间（不考虑排序的额外空间）
   - 算法类型：贪心算法 + 双指针技术

3. 实现要点：
   - 关键数据结构：使用双指针遍历两个已排序数组
   - 核心算法步骤：
     1. 对两个数组进行升序排序
     2. 使用双指针从数组末尾（最大值）开始
     3. 贪心匹配：优先让能力强的运动员匹配能力强的训练师
     4. 如果匹配成功，两个指针都向前移动；否则只移动运动员指针
   - 边界情况处理：当任一数组遍历完成时，循环结束

4. 优化思路：
   - 贪心策略的正确性：如果能力强的运动员不能匹配当前最强的训练师，那么能力弱的运动员也不能匹配
   - 双指针技术：避免了嵌套循环，在排序后的数组上一次遍历即可完成匹配
   - 从大到小匹配：确保每个训练师都能被最适合的运动员使用，避免资源浪费

5. 算法证明：
   - 反证法：假设存在更优解，其中能力为 a 的运动员匹配能力为 b 的训练师，能力为 c 的运动员匹配能力为 d 的训练师
   - 如果 a > c 且 b < d，那么交换匹配关系不会影响总匹配数，但更符合贪心原则
   - 因此贪心策略能够得到最优解

6. 类似问题：
   - 分发饼干问题：每个孩子都有一个满足度，每个饼干都有一个大小，求最多能满足多少孩子
   - 区间调度问题：在不重叠的前提下，选择最多的活动数量
   - 任务分配问题：将任务分配给工人，使得完成的任务数最多
*/
