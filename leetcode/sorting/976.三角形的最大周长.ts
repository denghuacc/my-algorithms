/*
 * @lc app=leetcode.cn id=976 lang=typescript
 *
 * [976] 三角形的最大周长
 *
 * https://leetcode-cn.com/problems/largest-perimeter-triangle/description/
 *
 * algorithms
 * Easy (56.00%)
 * Likes:    95
 * Dislikes: 0
 * Total Accepted:    25.6K
 * Total Submissions: 44.7K
 * Testcase Example:  '[2,1,2]'
 *
 * 给定由一些正数（代表长度）组成的数组 A，返回由其中三个长度组成的、面积不为零的三角形的最大周长。
 *
 * 如果不能形成任何面积不为零的三角形，返回 0。
 *
 *
 *
 *
 *
 *
 * 示例 1：
 *
 * 输入：[2,1,2]
 * 输出：5
 *
 *
 * 示例 2：
 *
 * 输入：[1,2,1]
 * 输出：0
 *
 *
 * 示例 3：
 *
 * 输入：[3,2,3,4]
 * 输出：10
 *
 *
 * 示例 4：
 *
 * 输入：[3,6,2,3]
 * 输出：8
 *
 *
 *
 *
 * 提示：
 *
 *
 * 3 <= A.length <= 10000
 * 1 <= A[i] <= 10^6
 *
 *
 */

// @lc code=start
function largestPerimeter(nums: number[]): number {
  // 1. 将数组按降序排序，最大的边在前面
  // 这样能确保我们优先检查可能构成最大周长的三边组合
  nums.sort((a, b) => b - a);

  const n = nums.length;

  // 2. 从最大的边开始，检查每个可能的三边组合
  // 由于已经降序排序，只要找到第一个满足三角形条件的组合，就是最大周长
  for (let i = 0; i < n - 2; i++) {
    const a = nums[i]; // 最长边
    const b = nums[i + 1]; // 次长边
    const c = nums[i + 2]; // 第三长边

    // 3. 检查三角形不等式：两边之和大于第三边
    // 由于a >= b >= c，只需要检查 b + c > a 即可
    // 其他两个不等式 a + c > b 和 a + b > c 必然成立
    if (b + c > a) {
      return a + b + c;
    }
  }

  // 4. 如果没有找到有效的三角形，返回0
  return 0;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 从给定数组中选择三个数，使其能构成三角形，并且周长最大
   - 三角形成立条件：任意两边之和大于第三边
   - 目标：在所有可能的三角形中找到周长最大的

2. 算法分析：
   - 时间复杂度：O(n log n) - 主要是排序的时间复杂度
   - 空间复杂度：O(1) - 只使用了常数级别的额外空间
   - 算法类型：贪心算法 + 排序

3. 解题思路：
   - 核心思想：要使周长最大，应该优先选择较大的边
   - 关键观察：将数组降序排列后，从最大的边开始检查，第一个满足条件的就是答案
   - 三角形判定：对于降序排列的三边 a >= b >= c，只需检查 b + c > a

4. 实现要点：
   - 数据结构选择：使用原地排序，节省空间
   - 边界条件处理：数组长度至少为3，如果无法构成三角形返回0
   - 优化技巧：降序排序 + 贪心策略，找到第一个就是最优解

5. 示例分析：
   
   示例1：[3,6,2,3] → 排序后 [6,3,3,2]
   - i=0: 检查(6,3,3) → 3+3=6 不大于6 → 不能构成三角形
   - i=1: 检查(3,3,2) → 3+2=5 > 3 → 能构成三角形
   - 返回 3+3+2 = 8

   示例2：[3,2,3,4] → 排序后 [4,3,3,2]  
   - i=0: 检查(4,3,3) → 3+3=6 > 4 → 能构成三角形
   - 返回 4+3+3 = 10

6. 算法正确性证明：
   - 贪心策略：由于我们按降序遍历，第一个满足条件的三边组合必然是周长最大的
   - 三角形判定：对于 a >= b >= c，如果 b + c > a，则其他两个不等式自动满足
     * a + c > b：因为 a >= b 且 c > 0，所以 a + c >= b + c > b
     * a + b > c：因为 a >= c 且 b > 0，所以 a + b >= c + b > c

7. 常见陷阱：
   - 忘记排序：如果不排序，无法保证贪心策略的正确性
   - 三角形判定错误：需要检查所有三个不等式，但降序排序后只需检查一个
   - 边界条件：数组长度小于3时无法构成三角形

8. 扩展思考：
   - 如果要求所有可能的三角形：需要三重循环遍历所有组合
   - 如果要求面积最大的三角形：需要用海伦公式计算面积
   - 类似问题：最大三角形面积、判断三角形类型等

9. 优化要点：
   - 排序选择：使用内置排序算法，通常是优化的快速排序或归并排序
   - early return：一旦找到满足条件的三角形就立即返回
   - 空间优化：原地排序，不使用额外数组

10. 时间复杂度分析：
    - 排序：O(n log n)
    - 遍历：O(n)
    - 总体：O(n log n)
    
    空间复杂度分析：
    - 排序：O(1) 原地排序
    - 其他变量：O(1)
    - 总体：O(1)
*/
