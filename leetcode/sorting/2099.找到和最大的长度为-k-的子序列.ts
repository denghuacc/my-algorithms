/*
 * @lc app=leetcode.cn id=2099 lang=typescript
 *
 * [2099] 找到和最大的长度为 K 的子序列
 *
 * https://leetcode.cn/problems/find-subsequence-of-length-k-with-the-largest-sum/description/
 *
 * algorithms
 * Easy (49.99%)
 * Likes:    64
 * Dislikes: 0
 * Total Accepted:    21.4K
 * Total Submissions: 37.9K
 * Testcase Example:  '[2,1,3,3]\n2'
 *
 * 给你一个整数数组 nums 和一个整数 k 。你需要找到 nums 中长度为 k 的 子序列 ，且这个子序列的 和最大 。
 *
 * 请你返回 任意 一个长度为 k 的整数子序列。
 *
 * 子序列 定义为从一个数组里删除一些元素后，不改变剩下元素的顺序得到的数组。
 *
 *
 *
 * 示例 1：
 *
 * 输入：nums = [2,1,3,3], k = 2
 * 输出：[3,3]
 * 解释：
 * 子序列有最大和：3 + 3 = 6 。
 *
 * 示例 2：
 *
 * 输入：nums = [-1,-2,3,4], k = 3
 * 输出：[-1,3,4]
 * 解释：
 * 子序列有最大和：-1 + 3 + 4 = 6 。
 *
 *
 * 示例 3：
 *
 * 输入：nums = [3,4,3,3], k = 2
 * 输出：[3,4]
 * 解释：
 * 子序列有最大和：3 + 4 = 7 。
 * 另一个可行的子序列为 [4, 3] 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 1000
 * -10^5 <= nums[i] <= 10^5
 * 1 <= k <= nums.length
 *
 *
 */

// @lc code=start
function maxSubsequence(nums: number[], k: number): number[] {
  const n = nums.length;

  // 步骤1: 创建 [索引, 值] 对的数组，用于记录每个元素的原始位置
  const vals: [number, number][] = [];
  for (let i = 0; i < n; i++) {
    vals.push([i, nums[i]]);
  }

  // 步骤2: 按值从大到小排序，找出最大的 k 个元素
  vals.sort((a, b) => b[1] - a[1]);

  // 步骤3: 取前 k 个最大的元素
  const topK = vals.slice(0, k);

  // 步骤4: 按原始索引排序，保持子序列的相对顺序
  topK.sort((a, b) => a[0] - b[0]);

  // 步骤5: 提取值构成结果数组
  const res: number[] = [];
  for (let i = 0; i < k; i++) {
    res.push(topK[i][1]);
  }

  return res;
}
// @lc code=end

export {};

/*
解题思路详解：

1. 问题本质：
   - 从数组中选择 k 个元素，使得这 k 个元素的和最大
   - 选择的元素必须保持原有的相对顺序（子序列的定义）
   - 关键特点：需要兼顾"值最大"和"顺序保持"两个要求

2. 算法分析：
   - 时间复杂度：O(n log n)
     * 主要开销在两次排序：按值排序 O(n log n) + 按索引排序 O(k log k)
     * 由于 k ≤ n，总体复杂度为 O(n log n)
   - 空间复杂度：O(n)
     * 需要额外空间存储 [索引, 值] 对数组
   - 算法类型：贪心算法 + 排序

3. 实现要点：
   - 关键数据结构：使用 [索引, 值] 对来同时记录元素的值和原始位置
   - 核心算法步骤：
     1. 创建索引-值对数组，记录每个元素的位置和值
     2. 按值降序排序，识别出最大的 k 个元素
     3. 对选中的 k 个元素按原始索引升序排序，恢复相对顺序
     4. 提取值构成最终结果
   - 边界情况处理：
     * k = 1：返回数组中的最大值
     * k = nums.length：返回原数组（按贪心策略排序后的结果）
     * 存在负数：算法依然有效，会优先选择较大的负数

4. 优化思路：
   - 性能优化：已经是最优解法，无需进一步优化
   - 空间优化：可以使用优先队列（最小堆）来减少空间使用，但会增加代码复杂度
   - 代码简化：使用 TypeScript 的类型注解提高代码可读性

5. 算法正确性证明：
   - 贪心策略：选择值最大的 k 个元素一定能获得最大和
   - 顺序保持：通过索引排序确保子序列的相对顺序不变
   - 完整性：算法覆盖了所有可能的情况，包括负数和重复值

6. 类似问题：
   - 数组中第 k 大元素
   - 最大子序列和
   - 保持相对顺序的排序问题
*/
