/*
 * @lc app=leetcode.cn id=2348 lang=typescript
 *
 * [2348] 全 0 子数组的数目
 *
 * https://leetcode.cn/problems/number-of-zero-filled-subarrays/description/
 *
 * algorithms
 * Medium (58.19%)
 * Likes:    36
 * Dislikes: 0
 * Total Accepted:    16.9K
 * Total Submissions: 26.7K
 * Testcase Example:  '[1,3,0,0,2,0,0,4]'
 *
 * 给你一个整数数组 nums ，返回全部为 0 的 子数组 数目。
 *
 * 子数组 是一个数组中一段连续非空元素组成的序列。
 *
 *
 *
 * 示例 1：
 *
 * 输入：nums = [1,3,0,0,2,0,0,4]
 * 输出：6
 * 解释：
 * 子数组 [0] 出现了 4 次。
 * 子数组 [0,0] 出现了 2 次。
 * 不存在长度大于 2 的全 0 子数组，所以我们返回 6 。
 *
 * 示例 2：
 *
 * 输入：nums = [0,0,0,2,0,0]
 * 输出：9
 * 解释：
 * 子数组 [0] 出现了 5 次。
 * 子数组 [0,0] 出现了 3 次。
 * 子数组 [0,0,0] 出现了 1 次。
 * 不存在长度大于 3 的全 0 子数组，所以我们返回 9 。
 *
 *
 * 示例 3：
 *
 * 输入：nums = [2,10,2019]
 * 输出：0
 * 解释：没有全 0 子数组，所以我们返回 0 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 10^5
 * -10^9 <= nums[i] <= 10^9
 *
 *
 */

// @lc code=start
function zeroFilledSubarray(nums: number[]): number {
  const n = nums.length;
  let cnt = 0; // 记录全0子数组的总数
  let last = -1; // 记录上一个非0元素的位置，初始为-1

  // 遍历数组，计算每个位置结尾的全0子数组数量
  for (let i = 0; i < n; i++) {
    if (nums[i] !== 0) {
      last = i; // 遇到非0元素，更新last位置
    } else {
      cnt += i - last; // 以当前0为结尾的子数组数量
    }
  }

  return cnt;
}
// @lc code=end

/*
解题思路：

1. 题目理解
---------------------
问题本质：
- 计算数组中全0子数组的总数量
- 子数组必须是连续的，且内部全为0
- 子数组不能为空

关键特点：
- 子数组必须是连续的
- 子数组内的所有元素都必须是0
- 子数组不能为空

2. 解题思路
---------------------
核心思想：
- 利用滑动窗口的思想，每当遇到0时，计算以当前0为结尾的所有可能子数组数量
- 遇到非0数字时更新分隔点，从而重新开始计算新的全0子数组

算法步骤：
1. 维护一个指针last，记录上一个非0元素的位置
2. 遍历数组，当遇到0时：
   - 从last+1到当前位置i的所有位置都可以作为子数组的起点
   - 这样的子数组数量就是i-last个
3. 累加所有可能的子数组数量

示例分析：
对于数组 [1,0,0,0]：
- i=1时：last=0，生成子数组 [0]，cnt+=1
- i=2时：last=0，生成子数组 [0],[0,0]，cnt+=2
- i=3时：last=0，生成子数组 [0],[0,0],[0,0,0]，cnt+=3
最终结果：cnt = 1+2+3 = 6

3. 复杂度分析
---------------------
时间复杂度：O(n)
- 只需要遍历数组一次
- 每次操作都是O(1)的

空间复杂度：O(1)
- 只使用了两个变量：cnt和last
- 不需要额外的数据结构

4. 边界情况
---------------------
1. 空数组：直接返回0
2. 全是非0元素：cnt始终为0
3. 全是0元素：会得到 n+(n-1)+...+1 个子数组
4. 数组中有正数和负数：不影响算法，因为我们只关注0

5. 优化思路
---------------------
当前解法已经是最优解：
1. 时间上：必须遍历每个元素至少一次
2. 空间上：已经达到了O(1)的最优空间复杂度
3. 代码简洁性：使用了简单的数学原理，逻辑清晰
*/
