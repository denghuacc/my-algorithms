/*
 * @lc app=leetcode.cn id=3350 lang=typescript
 *
 * [3350] 检测相邻递增子数组 II
 *
 * https://leetcode.cn/problems/adjacent-increasing-subarrays-detection-ii/description/
 *
 * algorithms
 * Medium (40.98%)
 * Likes:    23
 * Dislikes: 0
 * Total Accepted:    15.4K
 * Total Submissions: 28.4K
 * Testcase Example:  '[2,5,7,8,9,2,3,4,3,1]'
 *
 * 给你一个由 n 个整数组成的数组 nums ，请你找出 k 的 最大值，使得存在 两个 相邻 且长度为 k 的 严格递增
 * 子数组。具体来说，需要检查是否存在从下标 a 和 b (a < b) 开始的 两个 子数组，并满足下述全部条件：
 *
 *
 * 这两个子数组 nums[a..a + k - 1] 和 nums[b..b + k - 1] 都是 严格递增 的。
 * 这两个子数组必须是 相邻的，即 b = a + k。
 *
 *
 * 返回 k 的 最大可能 值。
 *
 * 子数组 是数组中的一个连续 非空 的元素序列。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [2,5,7,8,9,2,3,4,3,1]
 *
 * 输出：3
 *
 * 解释：
 *
 *
 * 从下标 2 开始的子数组是 [7, 8, 9]，它是严格递增的。
 * 从下标 5 开始的子数组是 [2, 3, 4]，它也是严格递增的。
 * 这两个子数组是相邻的，因此 3 是满足题目条件的 最大 k 值。
 *
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums = [1,2,3,4,4,4,4,5,6,7]
 *
 * 输出：2
 *
 * 解释：
 *
 *
 * 从下标 0 开始的子数组是 [1, 2]，它是严格递增的。
 * 从下标 2 开始的子数组是 [3, 4]，它也是严格递增的。
 * 这两个子数组是相邻的，因此 2 是满足题目条件的 最大 k 值。
 *
 *
 *
 *
 *
 * 提示：
 *
 *
 * 2 <= nums.length <= 2 * 10^5
 * -10^9 <= nums[i] <= 10^9
 *
 *
 */

// @lc code=start
function maxIncreasingSubarrays(nums: number[]): number {
  const n = nums.length;

  // res: 记录满足条件的最大 k 值
  let res = 0;

  // cnt: 当前正在统计的严格递增子数组的长度
  let cnt = 1;

  // preCnt: 前一个严格递增子数组的长度
  // 用于检查两个相邻的严格递增子数组
  let preCnt = 0;

  // 遍历数组，维护递增子数组的长度信息
  for (let i = 1; i < n; i++) {
    // 如果当前元素大于前一个元素，递增子数组长度加1
    if (nums[i] > nums[i - 1]) {
      cnt++;
    } else {
      // 遇到非递增元素，说明当前递增子数组结束
      // 保存当前递增子数组的长度作为前一个子数组的长度
      preCnt = cnt;
      // 重新开始统计新的递增子数组（从当前元素开始，长度为1）
      cnt = 1;
    }

    // 情况1: 检查前一个递增子数组和当前递增子数组是否相邻
    // 如果相邻，k 的最大值是两者长度的较小值
    res = Math.max(res, Math.min(preCnt, cnt));

    // 情况2: 检查单个递增子数组能否分成两个相邻的递增子数组
    // 如果当前递增子数组长度为 cnt，可以分成两个长度为 cnt/2 的相邻子数组
    res = Math.max(res, Math.floor(cnt / 2));
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 在数组中找到两个相邻的严格递增子数组，使得它们的公共长度 k 最大
   - "相邻"的定义：第二个子数组紧接着第一个子数组开始（b = a + k）
   - "严格递增"的定义：子数组中每个元素都严格大于前一个元素

2. 算法分析：
   - 时间复杂度：O(n) - 只需遍历数组一次
   - 空间复杂度：O(1) - 只使用常数个变量
   - 算法类型：贪心 + 动态维护

3. 核心思路：
   在遍历数组的过程中，动态维护以下信息：
   - cnt: 当前正在统计的严格递增子数组的长度
   - preCnt: 前一个严格递增子数组的长度
   
   对于每个位置，有两种可能产生答案的情况：
   
   情况1：前一个递增子数组 + 当前递增子数组（跨越分界点）
   - 如果 preCnt 和 cnt 分别代表两个相邻的递增子数组
   - k 的最大值是 min(preCnt, cnt)
   - 例如：[7,8,9] 和 [2,3,4]，k = min(3,3) = 3
   
   情况2：单个长递增子数组内部分割（不跨越分界点）
   - 如果当前递增子数组长度为 cnt
   - 可以将它分成两个相邻的长度为 k 的递增子数组
   - k 的最大值是 floor(cnt / 2)
   - 例如：[1,2,3,4,5,6] 可以分成 [1,2,3] 和 [4,5,6]，k = 3

4. 算法步骤：
   1. 初始化 res=0（答案），cnt=1（当前递增长度），preCnt=0（前一个递增长度）
   2. 从第二个元素开始遍历数组：
      - 如果 nums[i] > nums[i-1]：递增继续，cnt++
      - 否则：递增中断，保存 preCnt = cnt，重置 cnt = 1
   3. 每次迭代更新答案：
      - res = max(res, min(preCnt, cnt)) // 检查相邻两个子数组
      - res = max(res, floor(cnt / 2))   // 检查单个子数组分割
   4. 返回 res

5. 示例分析：

   示例1：nums = [2,5,7,8,9,2,3,4,3,1]
   
   遍历过程：
   i=1: 5>2, cnt=2, res=max(0, min(0,2), 2/2)=1
   i=2: 7>5, cnt=3, res=max(1, min(0,3), 3/2)=1
   i=3: 8>7, cnt=4, res=max(1, min(0,4), 4/2)=2
   i=4: 9>8, cnt=5, res=max(2, min(0,5), 5/2)=2
   i=5: 2<9, preCnt=5, cnt=1, res=max(2, min(5,1), 1/2)=2
   i=6: 3>2, cnt=2, res=max(2, min(5,2), 2/2)=2
   i=7: 4>3, cnt=3, res=max(2, min(5,3), 3/2)=3
   i=8: 3<4, preCnt=3, cnt=1, res=max(3, min(3,1), 1/2)=3
   i=9: 1<3, preCnt=1, cnt=1, res=max(3, min(1,1), 1/2)=3
   
   最终答案：3（对应 [7,8,9] 和 [2,3,4]）
   
   示例2：nums = [1,2,3,4,4,4,4,5,6,7]
   
   关键步骤：
   i=1,2,3: 持续递增，cnt=4
   i=4: 4=4（非递增），preCnt=4, cnt=1
   继续遍历后，最优解是 min(4,1)=1 或 floor(4/2)=2
   最终答案：2（对应 [1,2] 和 [3,4] 或将 [1,2,3,4] 分割）

6. 算法优势：
   - 一次遍历：无需预处理或多次扫描
   - 空间优化：不需要额外数组存储递增子数组信息
   - 实时更新：边遍历边计算答案，高效利用信息

7. 关键观察：
   - 答案只可能来自两种情况：相邻的两个递增段，或单个递增段的分割
   - 维护"当前递增长度"和"前一个递增长度"足以覆盖所有情况
   - 每个位置都可能产生新的最优解，需要实时更新

8. 边界情况：
   - 数组长度为2：最多只能有一个长度为1的相邻递增子数组对
   - 整个数组严格递增：答案是 floor(n/2)
   - 数组完全不递增：答案是1（任意两个相邻的单元素子数组）
   - 多个递增段：需要检查每对相邻递增段的长度

9. 常见错误：
   - 忘记更新 preCnt：当递增中断时，必须保存当前 cnt 到 preCnt
   - 忽略单个递增段分割的情况：只考虑跨越分界点的相邻子数组
   - 边界处理错误：循环从 i=1 开始，避免访问 nums[i-1] 越界

10. 扩展思考：
    - 如果要找三个相邻的递增子数组，需要维护更多历史信息
    - 如果允许非递增（递减或相等），算法需要调整递增条件
    - 如果要求返回具体的子数组位置，需要记录每个递增段的起始位置
*/
