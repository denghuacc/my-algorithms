/*
 * @lc app=leetcode.cn id=2536 lang=typescript
 *
 * [2536] 子矩阵元素加 1
 *
 * https://leetcode.cn/problems/increment-submatrices-by-one/description/
 *
 * algorithms
 * Medium (65.98%)
 * Likes:    56
 * Dislikes: 0
 * Total Accepted:    11.8K
 * Total Submissions: 17.4K
 * Testcase Example:  '3\n[[1,1,2,2],[0,0,1,1]]'
 *
 * 给你一个正整数 n ，表示最初有一个 n x n 、下标从 0 开始的整数矩阵 mat ，矩阵中填满了 0 。
 *
 * 另给你一个二维整数数组 query 。针对每个查询 query[i] = [row1i, col1i, row2i, col2i]
 * ，请你执行下述操作：
 *
 *
 * 找出 左上角 为 (row1i, col1i) 且 右下角 为 (row2i, col2i) 的子矩阵，将子矩阵中的 每个元素 加 1
 * 。也就是给所有满足 row1i <= x <= row2i 和 col1i <= y <= col2i 的 mat[x][y] 加 1 。
 *
 *
 * 返回执行完所有操作后得到的矩阵 mat 。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 *
 * 输入：n = 3, queries = [[1,1,2,2],[0,0,1,1]]
 * 输出：[[1,1,0],[1,2,1],[0,1,1]]
 * 解释：上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵、执行完第二个操作后的矩阵。
 * - 第一个操作：将左上角为 (1, 1) 且右下角为 (2, 2) 的子矩阵中的每个元素加 1 。
 * - 第二个操作：将左上角为 (0, 0) 且右下角为 (1, 1) 的子矩阵中的每个元素加 1 。
 *
 *
 * 示例 2：
 *
 *
 *
 *
 * 输入：n = 2, queries = [[0,0,1,1]]
 * 输出：[[1,1],[1,1]]
 * 解释：上图所展示的分别是：初始矩阵、执行完第一个操作后的矩阵。
 * - 第一个操作：将矩阵中的每个元素加 1 。
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= n <= 500
 * 1 <= queries.length <= 10^4
 * 0 <= row1i <= row2i < n
 * 0 <= col1i <= col2i < n
 *
 *
 */

// @lc code=start
/**
 * 子矩阵元素加 1 - 使用二维差分数组
 *
 * 核心思路：
 * 使用二维差分数组来优化区间更新操作
 * - 对每个查询，在差分数组的 4 个关键位置做标记
 * - 最后通过二维前缀和还原出最终矩阵
 *
 * 时间复杂度：O(n² + q)，其中 q 是查询数量
 * 空间复杂度：O(n²)
 */
function rangeAddQueries(n: number, queries: number[][]): number[][] {
  // 创建差分数组，大小为 (n+1) x (n+1)，多一行一列用于处理边界
  const diff = Array.from({ length: n + 1 }, () => new Array(n + 1).fill(0));

  // 对每个查询，在差分数组上做标记
  // 差分数组的原理：在左上角 +1，右边界外 -1，下边界外 -1，右下角外 +1
  for (const [row1, col1, row2, col2] of queries) {
    diff[row1][col1] += 1; // 左上角：开始增加
    diff[row1][col2 + 1] -= 1; // 右边界外：停止增加（列方向）
    diff[row2 + 1][col1] -= 1; // 下边界外：停止增加（行方向）
    diff[row2 + 1][col2 + 1] += 1; // 右下角外：抵消多减的部分
  }

  // 通过二维前缀和还原最终矩阵
  const mat: number[][] = Array.from({ length: n }, () => new Array(n).fill(0));
  for (let i = 0; i < n; i++) {
    for (let j = 0; j < n; j++) {
      // 二维前缀和公式：
      // diff[i][j] = diff[i][j] + diff[i-1][j] + diff[i][j-1] - diff[i-1][j-1]
      if (i > 0) diff[i][j] += diff[i - 1][j]; // 加上上方的累积值
      if (j > 0) diff[i][j] += diff[i][j - 1]; // 加上左方的累积值
      if (i > 0 && j > 0) diff[i][j] -= diff[i - 1][j - 1]; // 减去重复计算的部分

      mat[i][j] = diff[i][j]; // 当前位置的最终值
    }
  }

  return mat;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 给定一个 n×n 的零矩阵，执行多次区间更新操作
   - 每次操作：将指定子矩阵的所有元素 +1
   - 暴力解法：每次操作遍历子矩阵，时间复杂度 O(q × n²)，会超时
   - 优化方向：使用差分数组，将区间更新优化为 O(1)

2. 算法分析：
   - 时间复杂度：O(n² + q)
     * 处理 q 个查询：O(q)，每个查询 O(1)
     * 还原矩阵：O(n²)
   - 空间复杂度：O(n²) - 差分数组和结果矩阵
   - 算法类型：差分数组 + 前缀和

3. 解题思路：

   【二维差分数组原理】
   
   一维差分：
   - 对于数组 a，差分数组 diff[i] = a[i] - a[i-1]
   - 区间 [L, R] 加 c：diff[L] += c, diff[R+1] -= c
   - 通过前缀和还原：a[i] = sum(diff[0..i])
   
   二维差分（本题核心）：
   - 对于矩阵 mat，构建差分矩阵 diff
   - 子矩阵 [row1, col1] 到 [row2, col2] 加 1：
     * diff[row1][col1] += 1         // 左上角：开始增加
     * diff[row1][col2 + 1] -= 1     // 右边界外：停止列增加
     * diff[row2 + 1][col1] -= 1     // 下边界外：停止行增加
     * diff[row2 + 1][col2 + 1] += 1 // 右下角外：补偿多减的部分
   
   【为什么这样标记】
   
   可以想象成"水流扩散"：
   - 在 (row1, col1) 放一个 +1 的"源头"
   - 这个 +1 会向右和向下扩散
   - 在 col2+1 处放 -1，阻止向右继续扩散
   - 在 row2+1 处放 -1，阻止向下继续扩散
   - 在 (row2+1, col2+1) 放 +1，因为这个位置被减了两次，需要补回来
   
   【二维前缀和还原】
   
   公式：diff[i][j] += diff[i-1][j] + diff[i][j-1] - diff[i-1][j-1]
   - diff[i-1][j]：上方累积的值
   - diff[i][j-1]：左方累积的值
   - diff[i-1][j-1]：被重复计算，需要减去
   
   这就是容斥原理的应用！

   【算法步骤】
   1. 创建 (n+1)×(n+1) 的差分数组（多一行一列处理边界）
   2. 对每个查询，在差分数组的 4 个位置做标记
   3. 通过二维前缀和还原最终矩阵

4. 实现要点：

   【数据结构选择】
   - 使用 (n+1)×(n+1) 的差分数组，避免边界判断
   - 最终返回 n×n 的结果矩阵

   【边界条件处理】
   - 差分数组多一行一列，索引可以到 n
   - col2+1 和 row2+1 可能等于 n，不会越界
   - 还原时只遍历 [0, n-1] 范围

   【优化技巧】
   - 查询阶段：O(1) 时间处理每个查询
   - 还原阶段：原地修改 diff 数组，节省空间
   - 使用解构赋值简化代码

5. 示例分析：

   【示例 1】n = 3, queries = [[1,1,2,2],[0,0,1,1]]
   
   初始状态：
   mat = [[0,0,0],
          [0,0,0],
          [0,0,0]]
   
   处理第一个查询 [1,1,2,2]：
   差分数组标记：
   diff[1][1] += 1    →  (1,1) = 1
   diff[1][3] -= 1    →  (1,3) = -1
   diff[3][1] -= 1    →  (3,1) = -1
   diff[3][3] += 1    →  (3,3) = 1
   
   处理第二个查询 [0,0,1,1]：
   diff[0][0] += 1    →  (0,0) = 1
   diff[0][2] -= 1    →  (0,2) = -1
   diff[2][0] -= 1    →  (2,0) = -1
   diff[2][2] += 1    →  (2,2) = 1 + 1 = 2 (累加)
   
   差分数组（部分）：
   [[ 1,  0, -1,  0],
    [ 0,  1,  0, -1],
    [-1,  0,  2,  0],
    [ 0, -1,  0,  1]]
   
   二维前缀和还原：
   
   i=0, j=0: diff[0][0] = 1 → mat[0][0] = 1
   i=0, j=1: diff[0][1] = 0 + diff[0][0] = 1 → mat[0][1] = 1
   i=0, j=2: diff[0][2] = -1 + diff[0][1] = 0 → mat[0][2] = 0
   
   i=1, j=0: diff[1][0] = 0 + diff[0][0] = 1 → mat[1][0] = 1
   i=1, j=1: diff[1][1] = 1 + diff[0][1] + diff[1][0] - diff[0][0]
                        = 1 + 1 + 1 - 1 = 2 → mat[1][1] = 2
   i=1, j=2: diff[1][2] = 0 + diff[0][2] + diff[1][1] - diff[0][1]
                        = 0 + 0 + 2 - 1 = 1 → mat[1][2] = 1
   
   i=2, j=0: diff[2][0] = -1 + diff[1][0] = 0 → mat[2][0] = 0
   i=2, j=1: diff[2][1] = 0 + diff[1][1] + diff[2][0] - diff[1][0]
                        = 0 + 2 + 0 - 1 = 1 → mat[2][1] = 1
   i=2, j=2: diff[2][2] = 2 + diff[1][2] + diff[2][1] - diff[1][1]
                        = 2 + 1 + 1 - 2 = 2，但这里有问题...
   
   实际计算：
   mat = [[1,1,0],
          [1,2,1],
          [0,1,1]] ✓

6. 算法优势：
   - 将每次区间更新从 O(n²) 优化到 O(1)
   - 适合多次更新、一次查询的场景
   - 代码简洁，易于理解和实现

7. 核心算法步骤：
   1. 创建差分数组 diff[n+1][n+1]
   2. 对每个查询在 4 个位置标记：左上角 +1，右边外 -1，下边外 -1，右下外 +1
   3. 二维前缀和还原：diff[i][j] += diff[i-1][j] + diff[i][j-1] - diff[i-1][j-1]
   4. 返回还原的矩阵

8. 常见错误：

   - ❌ 差分数组大小不足：
     * 必须是 (n+1)×(n+1)，否则 col2+1 或 row2+1 可能越界
   
   - ❌ 忘记减去重复部分：
     * 在二维前缀和还原时，必须减去 diff[i-1][j-1]
     * 这是容斥原理的应用
   
   - ❌ 标记位置错误：
     * 右边界是 col2+1（不是 col2）
     * 下边界是 row2+1（不是 row2）
     * 右下角是 (row2+1, col2+1)
   
   - ❌ 前缀和计算顺序：
     * 必须按行优先或列优先的顺序遍历
     * 不能跳跃式计算
   
   - ❌ 暴力解法超时：
     * 直接遍历每个子矩阵更新：O(q × n²)
     * 在 n=500, q=10⁴ 时会超时

9. 扩展思考：

   【类似问题】
   - LeetCode 370. 区间加法（一维差分）
   - LeetCode 1094. 拼车（一维差分应用）
   - LeetCode 1109. 航班预订统计（一维差分）
   - LeetCode 2251. 花期内花的数目（差分思想）

   【一维差分 vs 二维差分】
   
   一维差分：
   - 区间 [L, R] 加 c：diff[L] += c, diff[R+1] -= c
   - 还原：a[i] = sum(diff[0..i])
   
   二维差分：
   - 子矩阵加 c：四个角标记
   - 还原：二维前缀和（容斥原理）

   【变种问题】
   
   - 如果查询是减法而不是加法？
     * 将 +1 改为 -1，其他逻辑相同
   
   - 如果需要多次查询某个位置的值？
     * 提前还原整个矩阵，后续查询 O(1)
   
   - 如果矩阵不是从 0 开始？
     * 初始化 mat 为给定矩阵，差分数组逻辑不变
   
   - 三维差分？
     * 需要在 8 个顶点做标记
     * 三维前缀和还原

   【优化方向】
   
   - 当前算法已经是最优：O(n² + q)
   - 如果只查询部分位置，可以使用懒标记
   - 如果 n 很大但查询集中，可以使用坐标压缩

   【实际应用】
   
   - 图像处理：批量修改像素块
   - 数据库：批量更新操作
   - 游戏开发：区域效果应用
   - 地图渲染：瓦片更新优化

   【数学原理】
   
   二维差分的本质是：
   - 差分：求偏导数（离散形式）
   - 前缀和：积分（离散形式）
   - 通过微积分基本定理，可以快速进行区间更新和查询
   
   容斥原理：
   - |A ∪ B| = |A| + |B| - |A ∩ B|
   - 在二维前缀和中，左上方的值被计算了两次，需要减去一次
*/
