/*
 * @lc app=leetcode.cn id=3000 lang=typescript
 *
 * [3000] 对角线最长的矩形的面积
 *
 * https://leetcode.cn/problems/maximum-area-of-longest-diagonal-rectangle/description/
 *
 * algorithms
 * Easy (51.84%)
 * Likes:    15
 * Dislikes: 0
 * Total Accepted:    17.5K
 * Total Submissions: 33K
 * Testcase Example:  '[[9,3],[8,6]]'
 *
 * 给你一个下标从 0 开始的二维整数数组 dimensions。
 *
 * 对于所有下标 i（0 <= i < dimensions.length），dimensions[i][0] 表示矩形  i 的长度，而
 * dimensions[i][1] 表示矩形  i 的宽度。
 *
 * 返回对角线最 长 的矩形的 面积 。如果存在多个对角线长度相同的矩形，返回面积最 大 的矩形的面积。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：dimensions = [[9,3],[8,6]]
 * 输出：48
 * 解释：
 * 下标 = 0，长度 = 9，宽度 = 3。对角线长度 = sqrt(9 * 9 + 3 * 3) = sqrt(90) ≈ 9.487。
 * 下标 = 1，长度 = 8，宽度 = 6。对角线长度 = sqrt(8 * 8 + 6 * 6) = sqrt(100) = 10。
 * 因此，下标为 1 的矩形对角线更长，所以返回面积 = 8 * 6 = 48。
 *
 *
 * 示例 2：
 *
 *
 * 输入：dimensions = [[3,4],[4,3]]
 * 输出：12
 * 解释：两个矩形的对角线长度相同，为 5，所以最大面积 = 12。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= dimensions.length <= 100
 * dimensions[i].length == 2
 * 1 <= dimensions[i][0], dimensions[i][1] <= 100
 *
 *
 */

// @lc code=start
/**
 * 计算对角线最长的矩形的面积，如果有多个最长对角线，返回最大面积
 * @param dimensions 矩形的长宽数组，每个元素为 [length, width]
 * @returns 对角线最长的矩形的面积
 */
function areaOfMaxDiagonal(dimensions: number[][]): number {
  // 记录最大面积
  let maxArea = 0;
  // 记录最长对角线的平方（避免开方运算）
  let maxDiagonalSquare = 0;

  // 遍历所有矩形
  for (const [x, y] of dimensions) {
    // 计算当前矩形对角线长度的平方
    // 根据勾股定理：对角线² = 长² + 宽²
    const diagonalSquare = x * x + y * y;

    if (diagonalSquare > maxDiagonalSquare) {
      // 找到更长的对角线，更新最大值
      maxDiagonalSquare = diagonalSquare;
      maxArea = x * y; // 更新面积
    } else if (diagonalSquare === maxDiagonalSquare) {
      // 对角线长度相等时，取较大的面积
      maxArea = Math.max(maxArea, x * y);
    }
    // 如果对角线更短，则忽略当前矩形
  }

  return maxArea;
}
// @lc code=end

/*
解题思路：

1. 题目理解
---------------------
问题本质：
- 在一组矩形中找到对角线最长的矩形
- 如果有多个矩形对角线相等，返回其中面积最大的
- 需要同时考虑对角线长度和面积两个条件

关键特点：
- 对角线长度由勾股定理计算
- 需要处理对角线相等的情况
- 只需要返回面积，不需要返回具体是哪个矩形

2. 解题思路
---------------------
核心思想：
使用对角线长度的平方进行比较（避免开方运算），
当找到更长的对角线时更新答案，当对角线相等时取最大面积。

算法步骤：
1. 维护两个变量：
   - maxDiagonalSquare：记录最长对角线的平方
   - maxArea：记录符合条件的最大面积

2. 遍历每个矩形：
   - 计算当前矩形对角线长度的平方
   - 如果大于当前最大值，更新两个变量
   - 如果等于当前最大值，只更新面积（取较大值）

3. 返回记录的最大面积

示例分析：
dimensions = [[9,3],[8,6]]
1. 第一个矩形：
   - 对角线² = 9² + 3² = 90
   - 面积 = 9 * 3 = 27
2. 第二个矩形：
   - 对角线² = 8² + 6² = 100 > 90
   - 面积 = 8 * 6 = 48
3. 返回48（第二个矩形的面积）

3. 复杂度分析
---------------------
时间复杂度：O(n)
- 只需要遍历一次数组
- 每次操作都是O(1)的计算

空间复杂度：O(1)
- 只使用了两个变量存储结果
- 不需要额外的数据结构

4. 边界情况
---------------------
1. 只有一个矩形：
   - 直接返回其面积
2. 多个矩形对角线相等：
   - 返回它们中的最大面积
3. 矩形退化为正方形：
   - 算法仍然有效
4. 输入数组长度为1：
   - 直接返回唯一矩形的面积

5. 优化思路
---------------------
1. 数值计算优化：
   - 使用平方进行比较，避免开方运算
   - 减少不必要的乘法运算

2. 代码优化：
   - 可以使用解构赋值简化代码
   - 使用Math.max简化比较逻辑

3. 扩展思考：
   - 如果要返回具体是哪个矩形，需要额外记录索引
   - 如果要返回所有最大面积的矩形，需要使用数组存储
   - 如果矩形数量很大，可以考虑并行计算

注意事项：
- 不需要实际计算对角线长度，使用平方比较即可
- 面积计算要在确定对角线最长后进行
- 注意数值范围，防止整数溢出
*/
