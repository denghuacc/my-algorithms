/*
 * @lc app=leetcode.cn id=3354 lang=typescript
 *
 * [3354] 使数组元素等于零
 *
 * https://leetcode.cn/problems/make-array-elements-equal-to-zero/description/
 *
 * algorithms
 * Easy (56.20%)
 * Likes:    24
 * Dislikes: 0
 * Total Accepted:    12.3K
 * Total Submissions: 20.4K
 * Testcase Example:  '[1,0,2,0,3]'
 *
 * 给你一个整数数组 nums 。
 *
 * 开始时，选择一个满足 nums[curr] == 0 的起始位置 curr ，并选择一个移动 方向 ：向左或者向右。
 *
 * 此后，你需要重复下面的过程：
 *
 *
 * 如果 curr 超过范围 [0, n - 1] ，过程结束。
 * 如果 nums[curr] == 0 ，沿当前方向继续移动：如果向右移，则 递增 curr ；如果向左移，则 递减 curr 。
 * 如果 nums[curr] > 0:
 *
 * 将 nums[curr] 减 1 。
 * 反转 移动方向（向左变向右，反之亦然）。
 * 沿新方向移动一步。
 *
 *
 *
 *
 * 如果在结束整个过程后，nums 中的所有元素都变为 0 ，则认为选出的初始位置和移动方向 有效 。
 *
 * 返回可能的有效选择方案数目。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [1,0,2,0,3]
 *
 * 输出：2
 *
 * 解释：
 *
 * 可能的有效选择方案如下：
 *
 *
 * 选择 curr = 3 并向左移动。
 *
 *
 * [1,0,2,0,3] -> [1,0,2,0,3] -> [1,0,1,0,3] -> [1,0,1,0,3] -> [1,0,1,0,2] ->
 * [1,0,1,0,2] -> [1,0,0,0,2] -> [1,0,0,0,2] -> [1,0,0,0,1] -> [1,0,0,0,1] ->
 * [1,0,0,0,1] -> [1,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,1] -> [0,0,0,0,1] ->
 * [0,0,0,0,1] -> [0,0,0,0,0].
 *
 *
 * 选择 curr = 3 并向右移动。
 *
 * [1,0,2,0,3] -> [1,0,2,0,3] -> [1,0,2,0,2] -> [1,0,2,0,2] -> [1,0,1,0,2] ->
 * [1,0,1,0,2] -> [1,0,1,0,1] -> [1,0,1,0,1] -> [1,0,0,0,1] -> [1,0,0,0,1] ->
 * [1,0,0,0,0] -> [1,0,0,0,0] -> [1,0,0,0,0] -> [1,0,0,0,0] ->
 * [0,0,0,0,0].
 *
 *
 *
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums = [2,3,4,0,4,1,0]
 *
 * 输出：0
 *
 * 解释：
 *
 * 不存在有效的选择方案。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 100
 * 0 <= nums[i] <= 100
 * 至少存在一个元素 i 满足 nums[i] == 0 。
 *
 *
 */

// @lc code=start
function countValidSelections(nums: number[]): number {
  // 计算数组所有元素的总和
  const sum = nums.reduce((a, b) => a + b, 0);
  const n = nums.length;
  let res = 0; // 记录有效选择方案数

  // left 表示当前位置左侧所有元素的和（初始为0）
  // right 表示当前位置右侧所有元素的和（初始为总和）
  let left = 0;
  let right = sum;

  // 遍历数组，寻找所有值为0的位置作为起始点
  for (let i = 0; i < n; i++) {
    if (nums[i] === 0) {
      // 关键观察：如果从位置 i 开始能够将所有元素变为0
      // 则左侧元素和与右侧元素和必须接近相等

      // 情况1：向左移动可行的条件
      // left >= right 时，向左可以消耗更多的左侧元素
      // 差值 <= 1 表示左右两侧基本平衡，可以通过来回移动消耗完所有元素
      if (left >= right && left - right <= 1) {
        res++;
      }

      // 情况2：向右移动可行的条件
      // left <= right 时，向右可以消耗更多的右侧元素
      // 差值 <= 1 表示左右两侧基本平衡
      if (left <= right && right - left <= 1) {
        res++;
      }
    } else {
      // 当前元素不为0，更新左侧和与右侧和
      left += nums[i]; // 左侧和增加当前元素
      right -= nums[i]; // 右侧和减少当前元素
    }
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 从数组中某个值为 0 的位置开始，选择向左或向右移动
   - 遇到 0 继续前进，遇到正数则减 1 并反转方向
   - 判断有多少种起始位置和方向的组合能让所有元素最终都变为 0

2. 算法分析：
   - 时间复杂度：O(n) - 只需遍历数组一次
   - 空间复杂度：O(1) - 只使用常量额外空间
   - 算法类型：贪心 + 数学推导

3. 核心洞察：
   
   关键观察：如果从位置 i（nums[i] == 0）开始能成功将所有元素变为 0，
   那么必然满足一个重要条件：左侧元素和与右侧元素和必须基本相等（差值 ≤ 1）
   
   为什么？
   - 假设左侧元素和为 L，右侧元素和为 R
   - 每次遇到正数，会将其减 1 并反转方向
   - 最终要让所有元素变为 0，意味着左右两侧的元素需要被"平衡"地消耗
   - 如果 L 和 R 相差太大，无论如何移动都无法完全消耗所有元素

4. 算法步骤：
   
   步骤 1：计算数组总和 sum
   步骤 2：初始化左侧和 left = 0，右侧和 right = sum
   步骤 3：遍历数组的每个位置 i
     - 如果 nums[i] == 0（可作为起始位置）：
       * 检查向左移动是否可行：left >= right 且 left - right <= 1
       * 检查向右移动是否可行：left <= right 且 right - left <= 1
       * 将满足条件的方案数加入结果
     - 如果 nums[i] > 0：
       * 更新 left += nums[i]（将当前元素加入左侧）
       * 更新 right -= nums[i]（将当前元素从右侧移除）
   步骤 4：返回有效方案总数

5. 条件判断详解：

   向左移动可行的条件：left >= right && left - right <= 1
   - left >= right：左侧和不小于右侧和，向左移动时会先处理左侧元素
   - left - right <= 1：差值不超过 1，保证可以通过来回移动平衡消耗
   
   向右移动可行的条件：left <= right && right - left <= 1
   - left <= right：右侧和不小于左侧和，向右移动时会先处理右侧元素
   - right - left <= 1：差值不超过 1，同样保证平衡消耗

   特殊情况：当 left == right 时
   - 两个条件都满足，意味着向左和向右都可行
   - 此时会贡献 2 个有效方案

6. 示例分析：

   示例 1：nums = [1,0,2,0,3]
   
   遍历过程：
   i=0, nums[0]=1 → left=1, right=5
   i=1, nums[1]=0 → 检查条件
     - left=1, right=5：不满足任何条件（差值 4 > 1）
   i=2, nums[2]=2 → left=3, right=3
   i=3, nums[3]=0 → 检查条件
     - left=3, right=3：满足两个条件！
     - 向左可行：3 >= 3 且 3-3=0 <= 1 ✓
     - 向右可行：3 <= 3 且 3-3=0 <= 1 ✓
     - res += 2
   i=4, nums[4]=3 → left=6, right=0
   
   结果：2 个有效方案

   示例 2：nums = [2,3,4,0,4,1,0]
   总和 = 14
   
   遍历过程：
   i=0~2: 更新 left 和 right
   i=3, nums[3]=0 → left=9, right=5
     - 9-5=4 > 1，不满足条件
   i=4~5: 继续更新
   i=6, nums[6]=0 → left=14, right=0
     - 14-0=14 > 1，不满足条件
   
   结果：0 个有效方案

7. 算法要点总结：

   核心技巧：
   - 将模拟过程转化为数学条件判断
   - 使用前缀和思想（左侧和 + 右侧和 = 总和）
   - 关键在于发现"平衡条件"：差值 ≤ 1

   优化要点：
   - 避免直接模拟移动过程（会超时）
   - 一次遍历同时维护左右两侧的和
   - 利用数学性质快速判断有效性

   类似问题：
   - 数组分割问题（判断能否分成和相等的两部分）
   - 平衡点问题（寻找左右两侧和相等的位置）

8. 常见错误：
   
   错误 1：尝试模拟整个移动过程
   - 时间复杂度太高，对于较长数组会超时
   - 应该通过数学推导找到判断条件

   错误 2：忽略差值为 1 的情况
   - 不仅仅是 left == right 可行
   - left - right == 1 或 right - left == 1 也可能可行
   - 因为移动过程中可以通过多次反转来平衡

   错误 3：没有正确理解方向选择
   - 每个值为 0 的位置可以尝试两个方向
   - 需要分别判断向左和向右是否满足条件

9. 扩展思考：
   
   变种 1：如果要求输出具体的起始位置和方向？
   - 在满足条件时记录 (i, direction)
   
   变种 2：如果元素可以是负数？
   - 需要调整判断条件，考虑绝对值的平衡
   
   变种 3：如果每次减少的不是 1 而是其他值？
   - 基本思路不变，但判断条件需要相应调整
*/
