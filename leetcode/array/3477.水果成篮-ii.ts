/*
 * @lc app=leetcode.cn id=3477 lang=typescript
 *
 * [3477] 水果成篮 II
 *
 * https://leetcode.cn/problems/fruits-into-baskets-ii/description/
 *
 * algorithms
 * Easy (67.15%)
 * Likes:    14
 * Dislikes: 0
 * Total Accepted:    14.7K
 * Total Submissions: 20.1K
 * Testcase Example:  '[4,2,5]\n[3,5,4]'
 *
 * 给你两个长度为 n 的整数数组，fruits 和 baskets，其中 fruits[i] 表示第 i 种水果的 数量，baskets[j] 表示第 j
 * 个篮子的 容量。
 *
 * 你需要对 fruits 数组从左到右按照以下规则放置水果：
 *
 *
 * 每种水果必须放入第一个 容量大于等于 该水果数量的 最左侧可用篮子 中。
 * 每个篮子只能装 一种 水果。
 * 如果一种水果 无法放入 任何篮子，它将保持 未放置。
 *
 *
 * 返回所有可能分配完成后，剩余未放置的水果种类的数量。
 *
 *
 *
 * 示例 1
 *
 *
 * 输入： fruits = [4,2,5], baskets = [3,5,4]
 *
 * 输出： 1
 *
 * 解释：
 *
 *
 * fruits[0] = 4 放入 baskets[1] = 5。
 * fruits[1] = 2 放入 baskets[0] = 3。
 * fruits[2] = 5 无法放入 baskets[2] = 4。
 *
 *
 * 由于有一种水果未放置，我们返回 1。
 *
 *
 * 示例 2
 *
 *
 * 输入： fruits = [3,6,1], baskets = [6,4,7]
 *
 * 输出： 0
 *
 * 解释：
 *
 *
 * fruits[0] = 3 放入 baskets[0] = 6。
 * fruits[1] = 6 无法放入 baskets[1] = 4（容量不足），但可以放入下一个可用的篮子 baskets[2] = 7。
 * fruits[2] = 1 放入 baskets[1] = 4。
 *
 *
 * 由于所有水果都已成功放置，我们返回 0。
 *
 *
 *
 *
 * 提示：
 *
 *
 * n == fruits.length == baskets.length
 * 1 <= n <= 100
 * 1 <= fruits[i], baskets[i] <= 1000
 *
 *
 */

// @lc code=start
function numOfUnplacedFruits(fruits: number[], baskets: number[]): number {
  // 记录无法放置的水果种类数量
  let res = 0;
  const n = fruits.length;

  // 遍历每种水果，按照从左到右的顺序尝试放置
  for (const fruit of fruits) {
    // 标记当前水果是否成功放置
    let unset = 1;

    // 从左到右遍历所有篮子，寻找第一个容量足够且未被使用的篮子
    for (let i = 0; i < n; i++) {
      // 检查当前篮子容量是否足够且未被使用
      if (fruit <= baskets[i]) {
        // 将篮子标记为已使用（容量设为0）
        baskets[i] = 0;
        // 标记水果已成功放置
        unset = 0;
        break; // 找到合适的篮子后立即退出
      }
    }

    // 如果水果无法放置，计数器加1
    res += unset;
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 这是一个贪心分配问题，需要将水果按顺序分配到最合适的篮子中
   - 核心约束：每种水果必须放入第一个容量足够的最左侧可用篮子
   - 目标：计算无法放置的水果种类数量

2. 算法分析：
   - 时间复杂度：O(n²)，其中 n 是水果和篮子的数量
     * 外层循环遍历每种水果：O(n)
     * 内层循环寻找合适的篮子：O(n)
   - 空间复杂度：O(1)，只使用了常数个变量
   - 算法类型：贪心算法

3. 实现要点：
   - 关键数据结构：直接使用输入数组，通过修改篮子容量来标记使用状态
   - 核心算法步骤：
     * 按顺序遍历每种水果
     * 从左到右寻找第一个容量足够且未使用的篮子
     * 找到后立即标记篮子为已使用并跳出内层循环
     * 统计无法放置的水果数量
   - 边界情况处理：
     * 所有篮子容量都不足时，水果无法放置
     * 篮子被使用后容量设为0，确保不会被重复使用

4. 优化思路：
   - 当前实现已经是最优的贪心策略
   - 可以通过提前排序来优化某些特殊情况，但会增加复杂度
   - 使用哈希表记录篮子状态可以避免修改原数组，但会增加空间复杂度

5. 算法正确性：
   - 贪心选择正确性：选择最左侧的合适篮子不会影响后续水果的放置
   - 这是因为题目要求"第一个容量大于等于该水果数量的最左侧可用篮子"
   - 如果当前水果选择右侧的篮子，不会让后续水果获得更好的放置机会

6. 示例分析：
   示例1：[4,2,5] 和 [3,5,4]
   - 水果4：放入篮子[1]=5，篮子变为[3,0,4]
   - 水果2：放入篮子[0]=3，篮子变为[0,0,4]  
   - 水果5：无法放入篮子[2]=4（容量不足），无法放置
   - 结果：1种水果未放置

7. 常见错误：
   - 忘记标记篮子为已使用，导致同一篮子被重复使用
   - 没有按照从左到右的顺序寻找篮子
   - 错误地认为需要尝试所有可能的分配方案

8. 类似问题：
   - 任务调度问题：将任务分配给可用的处理器
   - 资源分配问题：将资源分配给需求方
   - 区间调度问题：选择不重叠的区间
*/
