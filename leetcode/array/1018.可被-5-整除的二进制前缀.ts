/*
 * @lc app=leetcode.cn id=1018 lang=typescript
 *
 * [1018] 可被 5 整除的二进制前缀
 *
 * https://leetcode-cn.com/problems/binary-prefix-divisible-by-5/description/
 *
 * algorithms
 * Easy (47.63%)
 * Likes:    68
 * Dislikes: 0
 * Total Accepted:    17.1K
 * Total Submissions: 34.3K
 * Testcase Example:  '[0,1,1]'
 *
 * 给定由若干 0 和 1 组成的数组 A。我们定义 N_i：从 A[0] 到 A[i] 的第 i
 * 个子数组被解释为一个二进制数（从最高有效位到最低有效位）。
 *
 * 返回布尔值列表 answer，只有当 N_i 可以被 5 整除时，答案 answer[i] 为 true，否则为 false。
 *
 *
 *
 * 示例 1：
 *
 * 输入：[0,1,1]
 * 输出：[true,false,false]
 * 解释：
 * 输入数字为 0, 01, 011；也就是十进制中的 0, 1, 3 。只有第一个数可以被 5 整除，因此 answer[0] 为真。
 *
 *
 * 示例 2：
 *
 * 输入：[1,1,1]
 * 输出：[false,false,false]
 *
 *
 * 示例 3：
 *
 * 输入：[0,1,1,1,1,1]
 * 输出：[true,false,false,false,true,false]
 *
 *
 * 示例 4：
 *
 * 输入：[1,1,1,0,1]
 * 输出：[false,false,false,false,false]
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= A.length <= 30000
 * A[i] 为 0 或 1
 *
 *
 */

// @lc code=start
/**
 * 逐位构造前缀的十进制值，并在每一步记录能否被 5 整除。
 *
 * @param A - 仅包含 0/1 的比特数组，长度不超过 30000
 * @returns 对应每个前缀的可整除标记列表
 */
function prefixesDivBy5(A: number[]): boolean[] {
  const res: boolean[] = [];
  let prefix = 0; // 保存当前前缀的十进制值对 5 的余数

  for (const num of A) {
    // 左移一位相当于乘 2，再加上当前比特；仅保留对 5 的余数避免大数
    prefix = ((prefix << 1) + num) % 5;
    res.push(prefix === 0); // 余数为 0 代表当前前缀可被 5 整除
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 判断数组每个前缀构成的二进制数是否能被 5 整除。
   - 需要在 O(n) 时间内给出所有前缀的布尔结果。

2. 算法分析：
   - 时间复杂度：O(n)，单次遍历数组。
   - 空间复杂度：O(1)，仅维护一个余数变量，结果数组不计入额外空间。
   - 算法类型：数学 + 模运算（前缀迭代）。

3. 解题思路：
   - 核心思想：逐位累积二进制前缀，并持续维护它对 5 的余数，避免大数溢出。
   - 推导过程：新前缀值 = 旧值 * 2 + 当前位；(a * 2 + b) % 5 只依赖旧余数。
   - 主要步骤概述：
     1) 初始化余数 prefix=0。
     2) 迭代每个比特，更新 prefix=(prefix<<1)+bit，再对 5 取模。
     3) 若余数为 0，则该前缀可整除 5，加入 true，否则加入 false。

4. 实现要点：
   - 关键数据结构：常量时间更新的余数变量；结果用布尔数组存储。
   - 核心算法步骤：左移并加当前比特后取模，保证值不溢出且更新高效。
   - 边界情况处理：初始余数为 0；输入为单元素时同样按上述步骤处理。

5. 算法优势（可选）
   - 只需一次遍历、常数级状态，空间开销极小；模运算避免大整数处理。

6. 核心算法步骤（可选）
   - 累积余数 -> 取模 -> 记录布尔结果。

7. 示例分析
   - 示例一 A=[0,1,1]：
     - 前缀 0：余数 0，记录 true；
     - 前缀 01：余数 1，false；
     - 前缀 011：余数 3，false。
   - 示例二 A=[0,1,1,1,1,1]：
     - 依次余数为 0,1,3,2,0,1，对应 true,false,false,false,true,false。
   - 示例三 A=[1,1,1]：
     - 余数 1,3,2，对应 false,false,false。

8. 常见错误
   - 错误：直接存储完整前缀值，导致超出数字范围或性能下降。
     规避：每次更新后立即对 5 取模。
   - 错误：忘记左移操作，使用 prefix+bit 计算，导致值错误。
     规避：用 `(prefix << 1) + bit` 或 `prefix * 2 + bit`。
   - 错误：在循环外复用同一个布尔变量，最终结果全相同。
     规避：每次迭代都向结果数组推入新的布尔值。

10. 扩展思考
   - 优化思路：若改为判断能否被 k 整除，只需将取模改为 k。
   - 类似问题：检测二进制前缀是否被 3、7 等整除，或流式数据的可整除性判断。
   - 实际应用：流式比特流的整除校验、快速检测编码有效性。
   - 数学公式：新余数 r' = (r * 2 + bit) mod 5，依赖于上一状态，符合状态机思想。
*/
