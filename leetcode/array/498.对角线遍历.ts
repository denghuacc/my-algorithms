/*
 * @lc app=leetcode.cn id=498 lang=typescript
 *
 * [498] 对角线遍历
 *
 * https://leetcode.cn/problems/diagonal-traverse/description/
 *
 * algorithms
 * Medium (50.29%)
 * Likes:    316
 * Dislikes: 0
 * Total Accepted:    66.6K
 * Total Submissions: 129K
 * Testcase Example:  '[[1,2,3],[4,5,6],[7,8,9]]'
 *
 * 给你一个大小为 m x n 的矩阵 mat ，请以对角线遍历的顺序，用一个数组返回这个矩阵中的所有元素。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：mat = [[1,2,3],[4,5,6],[7,8,9]]
 * 输出：[1,2,4,7,5,3,6,8,9]
 *
 *
 * 示例 2：
 *
 *
 * 输入：mat = [[1,2],[3,4]]
 * 输出：[1,2,3,4]
 *
 *
 *
 *
 * 提示：
 *
 *
 * m == mat.length
 * n == mat[i].length
 * 1 <= m, n <= 10^4
 * 1 <= m * n <= 10^4
 * -10^5 <= mat[i][j] <= 10^5
 *
 *
 */

// @lc code=start
/**
 * 按对角线顺序遍历矩阵并返回遍历结果
 * @param mat m x n的二维矩阵
 * @returns 对角线遍历顺序的一维数组
 */
function findDiagonalOrder(mat: number[][]): number[] {
  // 获取矩阵的行数和列数
  const m = mat.length;
  const n = mat[0].length;

  // 创建结果数组，大小为矩阵元素总数
  const res: number[] = new Array(m * n).fill(0);
  let pos = 0; // 结果数组的当前位置

  // 遍历每条对角线，总共有 m+n-1 条对角线
  for (let i = 0; i < m + n - 1; i++) {
    if (i % 2 === 1) {
      // 奇数对角线，从左上到右下方向
      // 确定起始位置的坐标
      let x = i < n ? 0 : i - n + 1; // 行坐标
      let y = i < n ? i : n - 1; // 列坐标

      // 遍历当前对角线上的所有元素
      while (x < m && y >= 0) {
        res[pos] = mat[x][y];
        pos++;
        x++; // 向下移动
        y--; // 向左移动
      }
    } else {
      // 偶数对角线，从右下到左上方向
      // 确定起始位置的坐标
      let x = i < m ? i : m - 1; // 行坐标
      let y = i < m ? 0 : i - m + 1; // 列坐标

      // 遍历当前对角线上的所有元素
      while (x >= 0 && y < n) {
        res[pos] = mat[x][y];
        pos++;
        x--; // 向上移动
        y++; // 向右移动
      }
    }
  }

  return res;
}
// @lc code=end

/*
解题思路：

1. 题目理解
---------------------
问题本质：
- 将二维矩阵按照对角线方向遍历，方向交替变化
- 偶数对角线从右下到左上遍历
- 奇数对角线从左上到右下遍历
- 需要按顺序将遍历结果存入一维数组

关键特点：
- 对角线方向交替变化
- 每条对角线上的元素坐标和等于对角线编号
- 需要处理边界情况
- 每个元素只访问一次

2. 解题思路
---------------------
核心思想：
按照对角线编号遍历矩阵，根据编号的奇偶性决定遍历方向，
同时计算每条对角线的起始位置和遍历方向。

算法步骤：
1. 计算对角线总数：m + n - 1
2. 遍历每条对角线：
   - 对于偶数对角线（i % 2 === 0）：
     * 起始位置：(min(i, m-1), i < m ? 0 : i-m+1)
     * 向右上方向遍历
   - 对于奇数对角线（i % 2 === 1）：
     * 起始位置：(i < n ? 0 : i-n+1, min(i, n-1))
     * 向左下方向遍历
3. 将遍历到的元素依次放入结果数组

示例分析：
对于矩阵：
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
]

对角线遍历顺序：
0号对角线(偶)：1
1号对角线(奇)：2,4
2号对角线(偶)：7,5,3
3号对角线(奇)：6,8
4号对角线(偶)：9

3. 复杂度分析
---------------------
时间复杂度：O(m*n)
- 需要访问矩阵中的每个元素一次
- 总共有m*n个元素需要遍历

空间复杂度：O(1)
- 除了要求的返回数组外
- 只使用了常数个变量来存储坐标和计数器

4. 边界情况
---------------------
1. 矩阵只有一行或一列
   - 直接按顺序或逆序遍历即可
2. 矩阵只有一个元素
   - 直接返回该元素
3. 不规则矩阵（m != n）
   - 算法仍然有效，只需注意边界条件

5. 优化思路
---------------------
1. 坐标计算优化：
   - 可以使用数学公式简化起始坐标的计算
   - 对角线上的点坐标和等于对角线编号

2. 遍历方向优化：
   - 可以统一遍历方向，然后根据奇偶性反转子数组
   - 但这样会增加空间复杂度

3. 代码简化：
   - 可以将奇偶两种情况的代码合并
   - 使用方向数组来控制移动
   - 但可能会降低代码可读性

4. 内存优化：
   - 如果允许修改输入矩阵，可以原地标记已访问元素
   - 但这样会改变输入数据
*/
