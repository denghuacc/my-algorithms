/*
 * @lc app=leetcode.cn id=2221 lang=typescript
 *
 * [2221] 数组的三角和
 *
 * https://leetcode.cn/problems/find-triangular-sum-of-an-array/description/
 *
 * algorithms
 * Medium (78.90%)
 * Likes:    31
 * Dislikes: 0
 * Total Accepted:    17K
 * Total Submissions: 21.2K
 * Testcase Example:  '[1,2,3,4,5]'
 *
 * 给你一个下标从 0 开始的整数数组 nums ，其中 nums[i] 是 0 到 9 之间（两者都包含）的一个数字。
 *
 * nums 的 三角和 是执行以下操作以后最后剩下元素的值：
 *
 *
 * nums 初始包含 n 个元素。如果 n == 1 ，终止 操作。否则，创建 一个新的下标从 0 开始的长度为 n - 1 的整数数组 newNums
 * 。
 * 对于满足 0 <= i < n - 1 的下标 i ，newNums[i] 赋值 为 (nums[i] + nums[i+1]) % 10 ，%
 * 表示取余运算。
 * 将 newNums 替换 数组 nums 。
 * 从步骤 1 开始 重复 整个过程。
 *
 *
 * 请你返回 nums 的三角和。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 *
 * 输入：nums = [1,2,3,4,5]
 * 输出：8
 * 解释：
 * 上图展示了得到数组三角和的过程。
 *
 * 示例 2：
 *
 *
 * 输入：nums = [5]
 * 输出：5
 * 解释：
 * 由于 nums 中只有一个元素，数组的三角和为这个元素自己。
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 1000
 * 0 <= nums[i] <= 9
 *
 *
 */

// @lc code=start
/**
 * 数组的三角和 - 模拟计算
 *
 * 核心思想：按照题目描述逐层计算，每次将相邻元素相加取模，直到只剩一个元素
 * 这是一个典型的模拟问题，关键是理解三角和的计算过程
 */
var triangularSum = function (nums: number[]): number {
  // 当前层的数组，初始为输入数组
  let curNums = nums;

  // 持续计算直到只剩一个元素（三角形的顶点）
  while (curNums.length > 1) {
    // 创建下一层的数组，长度比当前层少1
    const newNums: number[] = [];

    // 遍历当前层，计算相邻元素之和
    // 第i个新元素 = (第i个元素 + 第i+1个元素) % 10
    for (let i = 0; i < curNums.length - 1; i++) {
      // 相邻元素相加并取模10，确保结果在0-9范围内
      newNums.push((curNums[i] + curNums[i + 1]) % 10);
    }

    // 更新当前层为新计算的层
    curNums = newNums;
  }

  // 返回最后剩余的唯一元素（三角和）
  return curNums[0];
};

// 方法2：原地修改
var triangularSum = function (nums: number[]): number {
  for (let len = nums.length; len > 1; len--) {
    for (let i = 0; i < len - 1; i++) {
      nums[i] = (nums[i] + nums[i + 1]) % 10;
    }
  }
  return nums[0];
};

// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 对数组进行层层归约，每次将相邻元素相加取模
   - 最终得到一个数字，即"三角和"
   - 本质上是一个模拟计算过程，类似于帕斯卡三角形的构造

2. 算法分析：
   - 时间复杂度：O(n²) - n层计算，每层平均n/2个元素
   - 空间复杂度：O(n) - 存储中间结果数组
   - 算法类型：模拟 + 数组操作

3. 三角和计算过程：
   
   ### 图解示例 nums = [1,2,3,4,5]：
   ```
   第0层：[1, 2, 3, 4, 5]     (5个元素)
            ↓   ↓   ↓   ↓
   第1层：  [3, 5, 7, 9]      (4个元素)
             ↓   ↓   ↓
   第2层：    [8, 2, 6]       (3个元素)  
              ↓   ↓
   第3层：      [0, 8]        (2个元素)
                ↓
   第4层：        [8]         (1个元素) ← 最终结果
   ```
   
   ### 具体计算：
   - 第1层：(1+2)%10=3, (2+3)%10=5, (3+4)%10=7, (4+5)%10=9
   - 第2层：(3+5)%10=8, (5+7)%10=2, (7+9)%10=6
   - 第3层：(8+2)%10=0, (2+6)%10=8
   - 第4层：(0+8)%10=8

4. 算法步骤：
   
   ### 迭代过程：
   1. **初始化**：当前层 = 输入数组
   2. **循环条件**：当前层长度 > 1
   3. **层间转换**：
      - 创建新层数组（长度减1）
      - 计算相邻元素之和并取模
      - 更新当前层为新层
   4. **返回结果**：最后剩余的唯一元素

5. 实现要点：
   
   ### 边界处理：
   - 输入数组长度为1：直接返回该元素
   - 循环终止条件：当前层只剩1个元素
   
   ### 取模操作的重要性：
   - 确保每个中间结果都在0-9范围内
   - 防止数值溢出（虽然在这个问题中不太可能）
   - 符合题目要求的数字范围约束
   
   ### 空间优化考虑：
   - 当前实现：每层都创建新数组，空间清晰但占用较多
   - 优化方案：可以原地修改，但会降低代码可读性

6. 算法可视化：
   
   ### 三角形结构：
   ```
   层数 | 元素个数 | 计算公式
   -----|----------|----------
   0    | n        | 输入数组
   1    | n-1      | (a[i] + a[i+1]) % 10
   2    | n-2      | 继续相邻相加取模
   ... | ...      | ...
   n-1  | 1        | 最终结果
   ```
   
   ### 数学规律：
   - 总共需要 n-1 轮计算
   - 第k轮生成 n-k 个元素
   - 总计算次数：(n-1) + (n-2) + ... + 1 = n(n-1)/2

7. 复杂度详细分析：
   
   ### 时间复杂度推导：
   ```
   第1轮：n-1次计算
   第2轮：n-2次计算
   ...
   第n-1轮：1次计算
   
   总计算次数 = Σ(i=1 to n-1) i = n(n-1)/2 = O(n²)
   ```
   
   ### 空间复杂度分析：
   - 最大空间占用：第一轮的新数组，大小为n-1
   - 总体空间复杂度：O(n)

8. 优化思路：
   
   ### 方法1：原地修改
   ```typescript
   // 可以重用原数组，节省空间
   for (let len = nums.length; len > 1; len--) {
     for (let i = 0; i < len - 1; i++) {
       nums[i] = (nums[i] + nums[i + 1]) % 10;
     }
   }
   return nums[0];
   ```
   
   ### 方法2：数学公式（高级）
   - 利用组合数学，直接计算每个原始元素对最终结果的贡献
   - 时间复杂度可降至O(n)，但实现复杂度较高

9. 相关问题：
   - 帕斯卡三角形：类似的逐层构造过程
   - 杨辉三角：二项式系数的三角形排列
   - 数字三角形路径问题：动态规划的经典应用

10. 测试用例分析：
    
    ### 边界情况：
    - nums = [5]：直接返回5
    - nums = [0,0]：(0+0)%10 = 0
    - nums = [9,9,9]：会产生进位和取模效果
    
    ### 典型案例验证：
    ```
    输入：[1,2,3,4,5]
    预期输出：8
    
    验证过程：
    [1,2,3,4,5] → [3,5,7,9] → [8,2,6] → [0,8] → [8] ✓
    ```

11. 编程技巧：
    - 使用描述性变量名：curNums, newNums
    - 清晰的循环结构：外层控制轮数，内层处理相邻元素
    - 及时取模：保持数值范围，避免不必要的大数运算
    
12. 扩展思考：
    - 如果不限制取模10，最终结果的数值范围是多少？
    - 能否找到输入与输出之间的直接数学关系？
    - 这个过程是否可逆？给定三角和能否反推原数组？
*/
