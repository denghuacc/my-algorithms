/*
 * @lc app=leetcode.cn id=1437 lang=typescript
 *
 * [1437] 是否所有 1 都至少相隔 k 个元素
 *
 * https://leetcode.cn/problems/check-if-all-1s-are-at-least-length-k-places-away/description/
 *
 * algorithms
 * Easy (56.28%)
 * Likes:    42
 * Dislikes: 0
 * Total Accepted:    26K
 * Total Submissions: 44.7K
 * Testcase Example:  '[1,0,0,0,1,0,0,1]\n2'
 *
 * 给你一个由若干 0 和 1 组成的数组 nums 以及整数 k。如果所有 1 都至少相隔 k 个元素，则返回 true ；否则，返回 false
 * 。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 *
 * 输入：nums = [1,0,0,0,1,0,0,1], k = 2
 * 输出：true
 * 解释：每个 1 都至少相隔 2 个元素。
 *
 * 示例 2：
 *
 *
 *
 *
 * 输入：nums = [1,0,0,1,0,1], k = 2
 * 输出：false
 * 解释：第二个 1 和第三个 1 之间只隔了 1 个元素。
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 10^5
 * 0 <= k <= nums.length
 * nums[i] 的值为 0 或 1
 *
 *
 */

// @lc code=start
/**
 * 检查数组中任意两个 1 之间是否至少隔开 k 个元素
 *
 * @param nums - 仅由 0/1 组成的数组
 * @param k - 相邻 1 之间的最小允许间距
 * @returns 若所有 1 均满足间距要求返回 true，否则返回 false
 */
function kLengthApart(nums: number[], k: number): boolean {
  let prevIndex = -1; // 记录上一个 1 出现的位置，初始化为 -1 表示尚未遇到 1

  for (let i = 0; i < nums.length; i++) {
    if (nums[i] === 1) {
      // 如果之前遇到过 1，检查当前 1 与上一个 1 之间的空位数量是否满足要求
      if (prevIndex !== -1 && i - prevIndex - 1 < k) {
        return false;
      }
      prevIndex = i; // 更新最近一次出现 1 的索引
    }
  }
  return true; // 遍历结束未发现违规间距则返回 true
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 判断任意两个值为 1 的元素之间是否至少存在 k 个 0。
   - 关键在于找到所有 1 的位置并比较它们之间的距离。

2. 算法分析：
   - 时间复杂度：O(n)，只需一次遍历即可完成检查。
   - 空间复杂度：O(1)，仅使用常数级变量记录上一个 1 的位置。
   - 算法类型：线性扫描 / 双指针（前后 1 的距离检测）。

3. 解题思路：
   - 核心思想：在遍历过程中保存上一个 1 的索引，与当前 1 相比对距离。
   - 推导过程：当前 1 与上一次 1 的间隔等于 `i - prevIndex - 1`，小于 k 则不满足要求。
   - 主要步骤概述：
     1. 初始化 `prevIndex = -1`，表示尚未遇到 1。
     2. 遍历数组，遇到 1 时若 `prevIndex !== -1` 则计算间距并判断。
     3. 每次遇到 1 都更新 `prevIndex`。

4. 实现要点：
   - 关键数据结构：常数变量 `prevIndex` 追踪上一次 1 的位置。
   - 核心算法步骤：遍历、检查、更新。
   - 边界情况处理：若数组中只有一个 1 或没有 1，则直接返回 true。

5. 算法优势（可选）
   - 常数空间、单次遍历即可完成。

6. 核心算法步骤（可选）
   1. 逐元素扫描。
   2. 碰到 1 时检查前后距离。
   3. 更新上一个 1 的索引。

7. 示例分析
   - 示例一 `[1,0,0,0,1,0,0,1], k = 2`：前两次 1 间隔 3、最后两次间隔 2，均满足返回 true。
   - 示例二 `[1,0,0,1,0,1], k = 2`：第二个 1 与第三个 1 之间间隔 1，小于 k，返回 false。
   - 边界情况：若 `k = 0`，任何 1 相邻都合法；若数组长度为 1，则永远满足。

8. 常见错误
   - 忘记在遇到新 1 时更新 `prevIndex`，导致后续比较错误。
   - 直接比较索引差 `i - prevIndex`，忽略两端 1 自身占位，应减去 1。
   - 未考虑数组开头或末尾只有一个 1 的场景，初始化/更新逻辑不当。

10. 扩展思考
   - 优化思路：可提前跳跃 `i += k + 1` 加速遍历，但在 TS 中直接线性扫足够。
   - 类似问题：需要检测距离或间隔的多点扫描题，如“至少距离 k 的预约安排”。
   - 实际应用：检测硬件信号中脉冲的间隔是否满足安全标准。
 */
