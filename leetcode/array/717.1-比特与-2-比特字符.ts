/*
 * @lc app=leetcode.cn id=717 lang=typescript
 *
 * [717] 1比特与2比特字符
 *
 * https://leetcode-cn.com/problems/1-bit-and-2-bit-characters/description/
 *
 * algorithms
 * Easy (52.47%)
 * Likes:    217
 * Dislikes: 0
 * Total Accepted:    37.9K
 * Total Submissions: 72.3K
 * Testcase Example:  '[1,0,0]'
 *
 * 有两种特殊字符：
 *
 *
 * 第一种字符可以用一个比特 0 来表示
 * 第二种字符可以用两个比特(10 或 11)来表示、
 *
 *
 * 给定一个以 0 结尾的二进制数组 bits ，如果最后一个字符必须是一位字符，则返回 true 。
 *
 *
 *
 * 示例 1:
 *
 *
 * 输入: bits = [1, 0, 0]
 * 输出: true
 * 解释: 唯一的编码方式是一个两比特字符和一个一比特字符。
 * 所以最后一个字符是一比特字符。
 *
 *
 * 示例 2:
 *
 *
 * 输入: bits = [1, 1, 1, 0]
 * 输出: false
 * 解释: 唯一的编码方式是两比特字符和两比特字符。
 * 所以最后一个字符不是一比特字符。
 *
 *
 *
 *
 * 提示:
 *
 *
 * 1 <= bits.length <= 1000
 * bits[i] == 0 or 1
 *
 *
 */

export {};

// @lc code=start
/**
 * 正向遍历：依据当前比特的起始位数直接跳过被编码的字符
 *
 * @param bits - 仅由 0/1 构成且以 0 结尾的编码数组
 * @returns 最后一个字符是否必然是一位字符
 */
var isOneBitCharacter = function (bits: number[]): boolean {
  const n = bits.length;
  let i = 0;

  // 只需检查到倒数第二位，最后一位留给判断
  while (i < n - 1) {
    // 0 开头的一位字符，光标右移 1
    if (bits[i] === 0) {
      i += 1;
    } else {
      // 1 开头的一定是两位字符（10 或 11），直接跳过两位
      i += 2;
    }
  }

  // 能精确落在最后一位，说明最后剩下的比特无法与前面组合，
  // 因此它只能作为一位字符独立存在
  return i === n - 1;
};

/**
 * 反向统计：从倒数第二位起向左数连续的 1
 *
 * @param bits - 仅由 0/1 构成且以 0 结尾的编码数组
 * @returns 最后一个字符是否必然是一位字符
 */
var isOneBitCharacter = function (bits: number[]): boolean {
  const n = bits.length;
  let cnt = 0;

  // 倒序统计紧挨着结尾 0 的连续 1 个数
  for (let i = n - 2; i >= 0 && bits[i] === 1; i -= 1) {
    cnt += 1;
  }

  // 连续 1 的个数若为偶数 => 能组成若干个两比特字符
  // 因而最后留下的末尾位一定是一位字符
  return cnt % 2 === 0;
};
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 题目使用变长前缀编码（0=一位，10/11=两位），
     需要判断末尾比特是否只能独立构成字符。
   - 数组结尾固定为 0，意味着最后一个比特始终可能充当一位字符的起点。

2. 算法分析：
   - 时间复杂度：O(n)。无论正向还是反向方案都只遍历一次。
   - 空间复杂度：O(1)。除了指针或计数器没有额外消耗。
   - 算法类型：贪心 + 模拟。

3. 解题思路：
   - 核心思想：遇到 0 就消耗一位，遇到 1 就连同下一位消耗两位，
     然后检查最终停留的位置。
   - 推导过程：1 开头的字符必占两位，因此指针增量完全由当前位决定；
     从末尾观察时只有紧贴终点的连续 1 会影响答案。
   - 主要步骤概述：方案一正向跳指针；方案二反向数连续 1，并用奇偶性
     判断末尾 0 是否被配对。

4. 实现要点：
   - 数据结构：只用整型变量即可，便于在 O(1) 空间内完成判断。
   - 核心步骤：正向循环条件维持 `i < n - 1`；
     反向循环在遇到第一个 0 时立刻停下。
   - 边界情况：长度为 1 的数组直接返回 true；全部为 1 但末尾必须是 0，
     逻辑依然成立。

5. 算法优势：
   - 正向方案写法朴素，能清晰展示编码规则。
   - 反向方案仅考察末尾局部，更利于快速判断。

6. 核心算法步骤：
   - 正向：初始化指针 → 逐段跳过字符 → 若最终落在 `n - 1`
     则末位是一比特字符。
   - 反向：从倒数第二位向左统计连续 1 → 计数为偶数则末位独立，
     若为奇数则被配对。

7. 示例分析：
   - `[1,0,0]`：跳过 `10` 后停在索引 2，或统计连续 1=0（偶数），
     因此返回 true。
   - `[1,1,1,0]`：正向无法停在末尾，反向连续 1=3（奇数），
     末尾 0 会被配成两位字符。
   - `[0,0]`：正向遍历落在末尾，反向连续 1=0（偶数），答案仍为 true。

8. 常见错误：
   - 将不相邻的 1 也加入奇偶性统计，导致错误判断。
   - 忽略循环边界，在 `i === n - 1` 时仍访问 `bits[i + 1]` 造成越界。
   - 仅凭数组长度的奇偶来推断答案，忽视编码结构。

10. 扩展思考：
   - 优化思路：若只需要结论，保留反向奇偶性方案即可覆盖所有用例。
   - 类似问题：固定前缀编码或位运算模拟题（如 1108、482）
     可借鉴这种线性扫描。
   - 实际应用：UTF-8 校验也会统计连续 1 的数量来界定字符长度，
     思路一脉相承。
   - 深入变种：若存在三比特字符，可扩展“连续 1 的计数规则”
     后重用该框架。
   - 数学公式：正向方案等价于累计 `i += bits[i] === 0 ? 1 : 2`
     并验证结尾位置。
*/
