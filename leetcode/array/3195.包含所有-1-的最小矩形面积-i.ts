/*
 * @lc app=leetcode.cn id=3195 lang=typescript
 *
 * [3195] 包含所有 1 的最小矩形面积 I
 *
 * https://leetcode.cn/problems/find-the-minimum-area-to-cover-all-ones-i/description/
 *
 * algorithms
 * Medium (79.96%)
 * Likes:    19
 * Dislikes: 0
 * Total Accepted:    21K
 * Total Submissions: 25.8K
 * Testcase Example:  '[[0,1,0],[1,0,1]]'
 *
 * 给你一个二维 二进制 数组 grid。请你找出一个边在水平方向和竖直方向上、面积 最小 的矩形，并且满足 grid 中所有的 1 都在矩形的内部。
 *
 * 返回这个矩形可能的 最小 面积。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入： grid = [[0,1,0],[1,0,1]]
 *
 * 输出： 6
 *
 * 解释：
 *
 *
 *
 * 这个最小矩形的高度为 2，宽度为 3，因此面积为 2 * 3 = 6。
 *
 *
 * 示例 2：
 *
 *
 * 输入： grid = [[0,0],[1,0]]
 *
 * 输出： 1
 *
 * 解释：
 *
 *
 *
 * 这个最小矩形的高度和宽度都是 1，因此面积为 1 * 1 = 1。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= grid.length, grid[i].length <= 1000
 * grid[i][j] 是 0 或 1。
 * 输入保证 grid 中至少有一个 1 。
 *
 *
 */

// @lc code=start
/**
 * 寻找包含所有1的最小矩形面积
 * @param grid 二维二进制数组
 * @returns 包含所有1的最小矩形面积
 */
function minimumArea(grid: number[][]): number {
  // 获取矩阵的行数和列数
  const m = grid.length;
  const n = grid[0].length;

  // 初始化边界值
  // 最小行坐标初始化为最大可能值
  let minI = m;
  // 最大行坐标初始化为最小可能值
  let maxI = -1;
  // 最小列坐标初始化为最大可能值
  let minJ = n;
  // 最大列坐标初始化为最小可能值
  let maxJ = -1;

  // 遍历整个矩阵，找到包含所有1的最小外接矩形的边界
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      if (grid[i][j] === 1) {
        // 更新四个边界值
        minI = Math.min(minI, i); // 更新最小行坐标
        maxI = Math.max(maxI, i); // 更新最大行坐标
        minJ = Math.min(minJ, j); // 更新最小列坐标
        maxJ = Math.max(maxJ, j); // 更新最大列坐标
      }
    }
  }

  // 如果没有找到任何1（maxI仍为初始值-1），返回0
  if (maxI === -1) return 0;

  // 计算最小矩形的高度和宽度
  const height = maxI - minI + 1; // 高度 = 最大行坐标 - 最小行坐标 + 1
  const width = maxJ - minJ + 1; // 宽度 = 最大列坐标 - 最小列坐标 + 1

  // 返回矩形的面积
  return height * width;
}
// @lc code=end

/*
解题思路：

1. 题目理解
---------------------
问题本质：
- 在二维矩阵中找到一个最小的矩形，包含所有的1
- 矩形的边必须平行于坐标轴（水平和竖直方向）
- 需要计算这个最小矩形的面积

关键特点：
- 矩阵中只包含0和1
- 矩形必须覆盖所有的1
- 矩形的边必须是水平或竖直的
- 保证输入矩阵中至少有一个1

2. 解题思路
---------------------
核心思想：
找到所有1的最小外接矩形（包围盒），这个矩形一定是所求的最小矩形。

算法步骤：
1. 初始化四个边界值：
   - minI: 最小行坐标，初始化为m
   - maxI: 最大行坐标，初始化为-1
   - minJ: 最小列坐标，初始化为n
   - maxJ: 最大列坐标，初始化为-1

2. 遍历整个矩阵：
   - 当遇到1时，更新四个边界值
   - minI = min(minI, 当前行)
   - maxI = max(maxI, 当前行)
   - minJ = min(minJ, 当前列)
   - maxJ = max(maxJ, 当前列)

3. 计算最小矩形面积：
   - 高度 = maxI - minI + 1
   - 宽度 = maxJ - minJ + 1
   - 面积 = 高度 * 宽度

示例分析：
对于矩阵：
[
  [0,1,0],
  [1,0,1]
]

- 遍历找到的边界值：
  minI = 0 (第一行有1)
  maxI = 1 (第二行有1)
  minJ = 0 (最左边的1在第0列)
  maxJ = 2 (最右边的1在第2列)
- 计算：
  高度 = 1 - 0 + 1 = 2
  宽度 = 2 - 0 + 1 = 3
  面积 = 2 * 3 = 6

3. 复杂度分析
---------------------
时间复杂度：O(m*n)
- 需要遍历整个矩阵一次
- m和n分别是矩阵的行数和列数

空间复杂度：O(1)
- 只使用了几个变量存储边界值
- 不需要额外的数据结构

4. 边界情况
---------------------
1. 矩阵中只有一个1：
   - 返回面积1
2. 所有的1都在同一行：
   - 高度为1，宽度为最左和最右1之间的距离+1
3. 所有的1都在同一列：
   - 宽度为1，高度为最上和最下1之间的距离+1
4. 矩阵全是1：
   - 返回整个矩阵的面积

5. 优化思路
---------------------
当前解法已经是最优解：
1. 时间复杂度：
   - 必须至少遍历一次矩阵才能找到所有的1
   - 无法进一步优化时间复杂度
2. 空间复杂度：
   - 已经达到了O(1)的最优空间复杂度
3. 算法简洁性：
   - 思路清晰，实现简单
   - 不需要复杂的数据结构
*/
