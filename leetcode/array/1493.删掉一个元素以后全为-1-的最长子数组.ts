/*
 * @lc app=leetcode.cn id=1493 lang=typescript
 *
 * [1493] 删掉一个元素以后全为 1 的最长子数组
 *
 * https://leetcode.cn/problems/longest-subarray-of-1s-after-deleting-one-element/description/
 *
 * algorithms
 * Medium (67.54%)
 * Likes:    194
 * Dislikes: 0
 * Total Accepted:    73.5K
 * Total Submissions: 108K
 * Testcase Example:  '[1,1,0,1]'
 *
 * 给你一个二进制数组 nums ，你需要从中删掉一个元素。
 *
 * 请你在删掉元素的结果数组中，返回最长的且只包含 1 的非空子数组的长度。
 *
 * 如果不存在这样的子数组，请返回 0 。
 *
 *
 *
 * 提示 1：
 *
 *
 * 输入：nums = [1,1,0,1]
 * 输出：3
 * 解释：删掉位置 2 的数后，[1,1,1] 包含 3 个 1 。
 *
 * 示例 2：
 *
 *
 * 输入：nums = [0,1,1,1,0,1,1,0,1]
 * 输出：5
 * 解释：删掉位置 4 的数字后，[0,1,1,1,1,1,0,1] 的最长全 1 子数组为 [1,1,1,1,1] 。
 *
 * 示例 3：
 *
 *
 * 输入：nums = [1,1,1]
 * 输出：2
 * 解释：你必须要删除一个元素。
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 10^5
 * nums[i] 要么是 0 要么是 1 。
 *
 *
 */

// @lc code=start
/**
 * 计算删除一个元素后全为1的最长子数组长度
 * @param nums 二进制数组
 * @returns 删除一个元素后全为1的最长子数组长度
 */
function longestSubarray(nums: number[]): number {
  const n = nums.length;
  // pre[i]表示以位置i结尾的连续1的个数
  const pre = new Array(n).fill(0);
  // suf[i]表示以位置i开始的连续1的个数
  const suf = new Array(n).fill(0);

  // 计算前缀连续1的个数
  pre[0] = nums[0]; // 初始化第一个位置
  for (let i = 1; i < n; i++) {
    // 如果当前位置是0，重置计数；否则，累加前一位置的计数
    pre[i] = nums[i] === 0 ? 0 : pre[i - 1] + 1;
  }

  // 计算后缀连续1的个数
  suf[n - 1] = nums[n - 1]; // 初始化最后一个位置
  for (let i = n - 2; i >= 0; i--) {
    // 如果当前位置是0，重置计数；否则，累加后一位置的计数
    suf[i] = nums[i] === 0 ? 0 : suf[i + 1] + 1;
  }

  // 遍历每个位置，计算删除该位置后可以得到的最长连续1子数组
  let res = 0;
  for (let i = 0; i < n; i++) {
    // 获取删除位置i后，左边的连续1的个数
    const left = i === 0 ? 0 : pre[i - 1];
    // 获取删除位置i后，右边的连续1的个数
    const right = i === n - 1 ? 0 : suf[i + 1];
    // 更新最大长度
    res = Math.max(res, left + right);
  }

  return res;
}
// @lc code=end

/*
解题思路：

1. 题目理解
---------------------
问题本质：
- 给定一个二进制数组，必须删除其中一个元素
- 找到删除后包含最多连续1的子数组长度
- 即使数组全为1，也必须删除一个元素

关键特点：
- 必须删除一个元素（不能不删）
- 寻找最长的全1子数组
- 删除的元素可以是0或1

2. 解题思路
---------------------
核心思想：
使用前缀和后缀数组记录每个位置的连续1的数量，然后遍历每个位置，
计算删除该位置后能得到的最长连续1子数组。

算法步骤：
1. 创建两个辅助数组：
   - pre[i]：记录以位置i结尾的连续1的个数
   - suf[i]：记录以位置i开始的连续1的个数

2. 计算前缀数组pre：
   - 从左向右遍历
   - 遇到1时，累加前一个位置的值
   - 遇到0时，重置为0

3. 计算后缀数组suf：
   - 从右向左遍历
   - 遇到1时，累加后一个位置的值
   - 遇到0时，重置为0

4. 遍历每个位置i：
   - 计算删除位置i后，左边的连续1个数(pre[i-1])
   - 计算删除位置i后，右边的连续1个数(suf[i+1])
   - 两者之和即为删除位置i后的连续1个数
   - 更新最大值

示例分析：
对于数组 [1,1,0,1]：
pre = [1,2,0,1]
suf = [1,1,1,1]

遍历每个位置：
- i=0: left=0, right=1 => 1
- i=1: left=1, right=1 => 2
- i=2: left=2, right=1 => 3 (最大值)
- i=3: left=0, right=0 => 0

3. 复杂度分析
---------------------
时间复杂度：O(n)
- 需要遍历数组三次
  1. 计算前缀数组
  2. 计算后缀数组
  3. 查找最大值

空间复杂度：O(n)
- 需要两个长度为n的辅助数组pre和suf

4. 边界情况
---------------------
1. 数组长度为1：
   - 必须删除该元素，返回0
2. 数组全是1：
   - 必须删除一个1，返回n-1
3. 数组全是0：
   - 返回0
4. 只有一个0：
   - 删除这个0，得到最长连续1

5. 优化思路
---------------------
1. 空间优化：
   - 可以用滑动窗口方法优化到O(1)空间
   - 维护一个包含至多一个0的窗口

2. 代码优化：
   - 可以在一次遍历中同时计算前缀和后缀
   - 可以用动态规划的思想优化空间使用

3. 其他考虑：
   - 如果不要求必须删除一个元素，可以简化问题
   - 如果允许删除多个元素，需要修改解法
*/
