/*
 * @lc app=leetcode.cn id=2210 lang=typescript
 *
 * [2210] 统计数组中峰和谷的数量
 *
 * https://leetcode.cn/problems/count-hills-and-valleys-in-an-array/description/
 *
 * algorithms
 * Easy (59.69%)
 * Likes:    19
 * Dislikes: 0
 * Total Accepted:    16.9K
 * Total Submissions: 27.4K
 * Testcase Example:  '[2,4,1,1,6,5]'
 *
 * 给你一个下标从 0 开始的整数数组 nums 。如果两侧距 i 最近的不相等邻居的值均小于 nums[i] ，则下标 i 是 nums
 * 中，某个峰的一部分。类似地，如果两侧距 i 最近的不相等邻居的值均大于 nums[i] ，则下标 i 是 nums 中某个谷的一部分。对于相邻下标 i
 * 和 j ，如果 nums[i] == nums[j] ，则认为这两下标属于 同一个 峰或谷。
 *
 * 注意，要使某个下标所做峰或谷的一部分，那么它左右两侧必须 都 存在不相等邻居。
 *
 * 返回 nums 中峰和谷的数量。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [2,4,1,1,6,5]
 * 输出：3
 * 解释：
 * 在下标 0 ：由于 2 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。
 * 在下标 1 ：4 的最近不相等邻居是 2 和 1 。由于 4 > 2 且 4 > 1 ，下标 1 是一个峰。
 * 在下标 2 ：1 的最近不相等邻居是 4 和 6 。由于 1 < 4 且 1 < 6 ，下标 2 是一个谷。
 * 在下标 3 ：1 的最近不相等邻居是 4 和 6 。由于 1 < 4 且 1 < 6 ，下标 3 符合谷的定义，但需要注意它和下标 2
 * 是同一个谷的一部分。
 * 在下标 4 ：6 的最近不相等邻居是 1 和 5 。由于 6 > 1 且 6 > 5 ，下标 4 是一个峰。
 * 在下标 5 ：由于 5 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。
 * 共有 3 个峰和谷，所以返回 3 。
 *
 * 示例 2：
 *
 *
 * 输入：nums = [6,6,5,5,4,1]
 * 输出：0
 * 解释：
 * 在下标 0 ：由于 6 的左侧不存在不相等邻居，所以下标 0 既不是峰也不是谷。
 * 在下标 1 ：由于 6 的左侧不存在不相等邻居，所以下标 1 既不是峰也不是谷。
 * 在下标 2 ：5 的最近不相等邻居是 6 和 4 。由于 5 < 6 且 5 > 4 ，下标 2 既不是峰也不是谷。
 * 在下标 3 ：5 的最近不相等邻居是 6 和 4 。由于 5 < 6 且 5 > 4 ，下标 3 既不是峰也不是谷。
 * 在下标 4 ：4 的最近不相等邻居是 5 和 1 。由于 4 < 5 且 4 > 1 ，下标 4 既不是峰也不是谷。
 * 在下标 5 ：由于 1 的右侧不存在不相等邻居，所以下标 5 既不是峰也不是谷。
 * 共有 0 个峰和谷，所以返回 0 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 3 <= nums.length <= 100
 * 1 <= nums[i] <= 100
 *
 *
 */

export {};

// @lc code=start
var countHillValley = function (nums: number[]): number {
  const n = nums.length;
  let cnt = 0;
  for (let i = 1; i < n - 1; i++) {
    if (nums[i] > nums[i - 1]) {
      if (nums[i] > nums[i + 1]) {
        cnt++;
      } else if (nums[i] === nums[i + 1]) {
        let j = i + 1;
        while (j < n && nums[i] === nums[j]) {
          j++;
        }
        if (nums[i] > nums[j]) {
          cnt++;
        }
      }
    } else if (nums[i] < nums[i - 1]) {
      if (nums[i] < nums[i + 1]) {
        cnt++;
      } else if (nums[i] === nums[i + 1]) {
        let j = i + 1;
        while (j < n && nums[i] === nums[j]) {
          j++;
        }
        if (nums[i] < nums[j]) {
          cnt++;
        }
      }
    }
  }
  return cnt;
};

// method2: improve
var countHillValley = function (nums: number[]): number {
  const n = nums.length;
  let count = 0;

  let i = 1;
  while (i < n - 1) {
    // 如果当前元素与前一个元素相等，跳过
    if (nums[i] === nums[i - 1]) {
      i++;
      continue;
    }

    // 找到当前相等段的结束位置
    let j = i + 1;
    while (j < n && nums[i] === nums[j]) {
      j++;
    }

    // 检查是否为峰或谷
    if (j < n) {
      // 峰：当前值大于左邻居且大于右邻居
      // 谷：当前值小于左邻居且小于右邻居
      if (
        (nums[i] > nums[i - 1] && nums[i] > nums[j]) ||
        (nums[i] < nums[i - 1] && nums[i] < nums[j])
      ) {
        count++;
      }
    }

    // 直接跳到下一个不同的元素位置，避免重复处理
    i = j;
  }

  return count;
};
// @lc code=end

/*
解题思路详解：

1. 问题本质
   - 核心问题：识别数组中的峰和谷，相邻相等元素视为同一个峰/谷
   - 峰的定义：两侧最近不相等邻居都小于当前值
   - 谷的定义：两侧最近不相等邻居都大于当前值
   - 关键约束：左右两侧必须都存在不相等邻居

2. 两种解法对比

   方法一：朴素遍历法
   - 逐个位置检查，处理相等元素时需要额外查找
   - for (let i = 1; i < n - 1; i++) 逐一递增
   - 分别处理峰和谷的情况，遇到相等元素时向前查找
   - 特点：
     * 时间复杂度：O(n²) 最坏情况（大量连续相等元素）
     * 空间复杂度：O(1)
     * 逻辑清晰但效率较低

   方法二：跳跃式优化法  
   - 智能跳过连续相等元素段
   - while (i < n - 1) 手动控制循环
   - 跳过与前一个相等的元素，找到整个相等段
   - i = j 关键：直接跳跃而非 i++
   - 特点：
     * 时间复杂度：O(n) - 每个元素最多访问一次
     * 空间复杂度：O(1)
     * 高效处理连续相等元素

3. 核心优化技巧

   跳跃式处理：
   - j = i + 1：从下一个位置开始寻找
   - while (j < n && nums[i] === nums[j])：找到相等段结束位置
   - i = j：直接跳到下一个不同元素，避免重复检查

   统一判断逻辑：
   - if ((nums[i] > nums[i - 1] && nums[i] > nums[j]) ||
         (nums[i] < nums[i - 1] && nums[i] < nums[j]))
   - 同时处理峰和谷，简化分支逻辑

4. 算法执行示例
   输入：[2,4,1,1,6,5]
   
   i=1, nums[i]=4: 4>2, j=2, nums[j]=1, 4>1 → 峰
   i=2, nums[i]=1: 1<4, j=4, nums[j]=6, 1<6 → 谷  
   i=4, nums[i]=6: 6>1, j=5, nums[j]=5, 6>5 → 峰
   
   关键观察：i=3时的1被跳过，因为与i=2的1属于同一谷

5. 性能分析
   - 时间复杂度：O(n) - 优化后每个元素最多访问一次
   - 空间复杂度：O(1) - 只使用常数额外空间
   - 实际提升：在有大量连续相等元素的数组中性能显著提升

6. 代码风格改进
   - while代替for：更适合手动控制循环变量的跳跃
   - 语义明确：j直接指向下一个不同元素
   - 逻辑统一：峰谷判断合并为单一条件
*/
