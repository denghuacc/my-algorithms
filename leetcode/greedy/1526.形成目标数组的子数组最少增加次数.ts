/*
 * @lc app=leetcode.cn id=1526 lang=typescript
 *
 * [1526] 形成目标数组的子数组最少增加次数
 *
 * https://leetcode.cn/problems/minimum-number-of-increments-on-subarrays-to-form-a-target-array/description/
 *
 * algorithms
 * Hard (69.26%)
 * Likes:    116
 * Dislikes: 0
 * Total Accepted:    15.3K
 * Total Submissions: 21K
 * Testcase Example:  '[1,2,3,2,1]'
 *
 * 给你一个整数数组 target 和一个数组 initial ，initial 数组与 target  数组有同样的维度，且一开始全部为 0 。
 *
 * 请你返回从 initial 得到  target 的最少操作次数，每次操作需遵循以下规则：
 *
 *
 * 在 initial 中选择 任意 子数组，并将子数组中每个元素增加 1 。
 *
 *
 * 答案保证在 32 位有符号整数以内。
 *
 *
 *
 * 示例 1：
 *
 * 输入：target = [1,2,3,2,1]
 * 输出：3
 * 解释：我们需要至少 3 次操作从 intial 数组得到 target 数组。
 * [0,0,0,0,0] 将下标为 0 到 4 的元素（包含二者）加 1 。
 * [1,1,1,1,1] 将下标为 1 到 3 的元素（包含二者）加 1 。
 * [1,2,2,2,1] 将下表为 2 的元素增加 1 。
 * [1,2,3,2,1] 得到了目标数组。
 *
 *
 * 示例 2：
 *
 * 输入：target = [3,1,1,2]
 * 输出：4
 * 解释：(initial)[0,0,0,0] -> [1,1,1,1] -> [1,1,1,2] -> [2,1,1,2] -> [3,1,1,2]
 * (target) 。
 *
 *
 * 示例 3：
 *
 * 输入：target = [3,1,5,4,2]
 * 输出：7
 * 解释：(initial)[0,0,0,0,0] -> [1,1,1,1,1] -> [2,1,1,1,1] -> [3,1,1,1,1]
 * ⁠                                 -> [3,1,2,2,2] -> [3,1,3,3,2] ->
 * [3,1,4,4,2] -> [3,1,5,4,2] (target)。
 *
 *
 * 示例 4：
 *
 * 输入：target = [1,1,1,1]
 * 输出：1
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= target.length <= 10^5
 * 1 <= target[i] <= 10^5
 *
 *
 */

// @lc code=start
function minNumberOperations(target: number[]): number {
  const n = target.length;

  // 初始化结果为第一个元素的值
  // 因为要将第一个位置从 0 变成 target[0]，至少需要 target[0] 次操作
  let res = target[0];

  // 从第二个元素开始遍历
  for (let i = 1; i < n; i++) {
    // 关键思路：只在当前元素大于前一个元素时，才需要额外的操作
    // 如果 target[i] > target[i-1]，说明需要"爬坡"，需要额外增加的操作次数为差值
    // 如果 target[i] <= target[i-1]，说明是"下坡"或"平地"，可以利用之前的操作，不需要额外操作
    if (target[i] > target[i - 1]) {
      res += target[i] - target[i - 1];
    }
    // 当 target[i] <= target[i-1] 时，不需要额外操作
    // 因为之前对 target[i-1] 的操作可以"覆盖"到 target[i]
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 从全0数组开始，通过选择子数组并将其中每个元素 +1 的操作，最终得到目标数组
   - 求最少需要多少次操作
   - 关键观察：每次操作必须是连续的子数组

2. 算法分析：
   - 时间复杂度：O(n) - 只需遍历数组一次
   - 空间复杂度：O(1) - 只使用常量额外空间
   - 算法类型：贪心算法、数组遍历

3. 解题思路：

   核心思想：
   - 将数组想象成一个"高度图"或"直方图"
   - 每次操作相当于在某个连续区间上"涂一层"
   - 关键洞察：只需要关注"上升"的部分（爬坡），"下降"的部分（下坡）可以利用之前的操作
   
   贪心策略：
   - 从左到右遍历数组
   - 当遇到高度上升时（target[i] > target[i-1]），需要额外操作
   - 当遇到高度下降或持平时（target[i] <= target[i-1]），不需要额外操作
   
   为什么这样是最优的？
   - 想象我们从底部开始"堆积"高度
   - 每次操作可以覆盖一个连续区间
   - 下降的部分可以"复用"之前的操作区间
   - 只有上升的部分需要新的操作来"填补"高度差

   算法步骤：
   1. 初始化结果为 target[0]，因为第一个位置至少需要 target[0] 次操作
   2. 从第二个元素开始遍历
   3. 如果当前元素大于前一个元素，累加差值到结果
   4. 如果当前元素小于等于前一个元素，不做任何操作（利用之前的操作）
   5. 返回累积的操作次数

4. 实现要点：

   数据结构选择：
   - 只需要一个变量记录累积的操作次数
   - 不需要额外的数组或复杂数据结构

   关键判断：
   - target[i] > target[i-1]：需要"爬坡"，累加差值
   - target[i] <= target[i-1]：可以"复用"，不累加

   边界条件：
   - 第一个元素特殊处理，直接作为初始值
   - 单元素数组直接返回该元素值

5. 示例分析：

   示例1：target = [1,2,3,2,1]
   
   可视化（想象成直方图）：
   ```
       3
     2 2 2
   1 1 1 1 1
   ```
   
   执行过程：
   - 初始：res = 1（第一个元素）
   - i=1: target[1]=2 > target[0]=1，res += (2-1) = 2
   - i=2: target[2]=3 > target[1]=2，res += (3-2) = 3
   - i=3: target[3]=2 < target[2]=3，不累加（下降，复用之前操作）
   - i=4: target[4]=1 < target[3]=2，不累加（下降，复用之前操作）
   - 返回：3
   
   操作方式理解：
   - 操作1：对 [0,4] 区间 +1 → [1,1,1,1,1]
   - 操作2：对 [1,3] 区间 +1 → [1,2,2,2,1]
   - 操作3：对 [2,2] 区间 +1 → [1,2,3,2,1]
   
   示例2：target = [3,1,1,2]
   
   可视化：
   ```
   3
   2     2
   1 1 1 1
   ```
   
   执行过程：
   - 初始：res = 3
   - i=1: target[1]=1 < target[0]=3，不累加（下降）
   - i=2: target[2]=1 = target[1]=1，不累加（持平）
   - i=3: target[3]=2 > target[2]=1，res += (2-1) = 4
   - 返回：4
   
   示例3：target = [3,1,5,4,2]
   
   可视化：
   ```
       5
       4 4
   3   3 3
   2   2 2 2
   1 1 1 1 1
   ```
   
   执行过程：
   - 初始：res = 3
   - i=1: target[1]=1 < target[0]=3，不累加（res = 3）
   - i=2: target[2]=5 > target[1]=1，res += (5-1) = 7
   - i=3: target[3]=4 < target[2]=5，不累加（res = 7）
   - i=4: target[4]=2 < target[3]=4，不累加（res = 7）
   - 返回：7

6. 算法要点总结：

   核心技巧：
   - 将问题转化为"直方图堆积"问题
   - 利用贪心思想：只关注上升段，忽略下降段
   - 通过相邻元素的比较来判断是否需要额外操作

   优化要点：
   - 一次遍历解决问题，无需回溯
   - 不需要记录具体的操作序列，只需要统计次数
   - 空间复杂度最优（O(1)）

   数学原理：
   - 最少操作次数 = 第一个元素 + 所有上升段的高度差之和
   - 公式：res = target[0] + Σ max(0, target[i] - target[i-1])
   
   类似问题：
   - 接雨水问题（LeetCode 42）
   - 柱状图中最大的矩形（LeetCode 84）
   - 其他涉及"高度图"处理的问题

7. 常见错误：

   错误1：认为需要记录每次具体的操作
   - 实际上只需要统计操作次数，不需要记录操作细节
   - 贪心策略保证了结果的正确性

   错误2：忽略下降段的"复用"特性
   ```typescript
   // ❌ 错误做法：累加所有元素
   let res = 0;
   for (let i = 0; i < n; i++) {
     res += target[i];  // 这样会重复计算
   }
   ```
   - 下降段可以复用之前的操作，不需要额外计数

   错误3：使用复杂的动态规划或回溯
   - 这个问题有简单的贪心解法，不需要复杂算法
   - 贪心策略：从左到右，只累加上升差值

8. 扩展思考：

   直观理解（画图法）：
   - 将 target 数组画成柱状图
   - 每次操作相当于在某些连续柱子上涂一层
   - 从下往上涂，每层可以涂不同的连续区间
   - 关键：下降时可以"停止涂色"，上升时必须"继续涂色"

   证明正确性：
   1. 第一个元素必须涂 target[0] 层
   2. 对于位置 i，如果 target[i] > target[i-1]：
      - 前 target[i-1] 层可以从 i-1 延续过来
      - 额外需要 target[i] - target[i-1] 层只涂 i 及之后的位置
   3. 对于位置 i，如果 target[i] <= target[i-1]：
      - 所有层都可以从 i-1 延续过来
      - 不需要额外操作

   变种问题：
   - 如果每次操作可以让子数组 +k（k > 1），如何调整？
   - 如果可以选择 +1 或 -1，最少操作次数是多少？
   - 如果初始数组不是全0，而是给定的数组，如何计算？

   时间优化：
   - 当前算法已经是 O(n) 最优解
   - 无法进一步优化时间复杂度

   空间优化：
   - 当前算法已经是 O(1) 最优解
   - 不使用任何额外空间
*/
