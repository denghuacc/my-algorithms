/*
 * @lc app=leetcode.cn id=1323 lang=typescript
 *
 * [1323] 6 和 9 组成的最大数字
 *
 * https://leetcode.cn/problems/maximum-69-number/description/
 *
 * algorithms
 * Easy (75.53%)
 * Likes:    98
 * Dislikes: 0
 * Total Accepted:    57K
 * Total Submissions: 73.8K
 * Testcase Example:  '9669'
 *
 * 给你一个仅由数字 6 和 9 组成的正整数 num。
 *
 * 你最多只能翻转一位数字，将 6 变成 9，或者把 9 变成 6 。
 *
 * 请返回你可以得到的最大数字。
 *
 *
 *
 * 示例 1：
 *
 * 输入：num = 9669
 * 输出：9969
 * 解释：
 * 改变第一位数字可以得到 6669 。
 * 改变第二位数字可以得到 9969 。
 * 改变第三位数字可以得到 9699 。
 * 改变第四位数字可以得到 9666 。
 * 其中最大的数字是 9969 。
 *
 *
 * 示例 2：
 *
 * 输入：num = 9996
 * 输出：9999
 * 解释：将最后一位从 6 变到 9，其结果 9999 是最大的数。
 *
 * 示例 3：
 *
 * 输入：num = 9999
 * 输出：9999
 * 解释：无需改变就已经是最大的数字了。
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= num <= 10^4
 * num 每一位上的数字都是 6 或者 9 。
 *
 *
 */

// @lc code=start
/**
 * 方法一：贪心算法 + 字符串操作
 * 思路：将数字转换为字符串，从左到右找到第一个6并替换为9
 * 时间复杂度：O(n)，n为数字的位数
 * 空间复杂度：O(n)，需要额外的字符数组空间
 */
function maximum69Number(num: number): number {
  // 将数字转换为字符数组，便于操作
  const charArray = num.toString().split("");

  // 从左到右扫描，找到第一个6就替换为9
  // 贪心策略：越靠左的位置权重越大，优先替换左边的6
  for (let i = 0; i < charArray.length; i++) {
    if (charArray[i] === "6") {
      charArray[i] = "9";
      break; // 只能翻转一位，找到第一个6后立即停止
    }
  }

  // 将字符数组重新组合为数字
  return Number(charArray.join(""));
}

/**
 * 方法二：贪心算法 + 数学运算
 * 思路：通过数学运算直接定位并修改最高位的6
 * 时间复杂度：O(n)，n为数字的位数
 * 空间复杂度：O(1)，只使用常数额外空间
 */
function maximum69NumberMath(num: number): number {
  // 计算数字的最高位权重：10^(位数-1)
  let digitBase = Math.pow(10, Math.trunc(Math.log10(num)));

  // 从最高位开始检查每一位
  while (digitBase > 0) {
    // 提取当前位的数字：先除以权重得到高位部分，再取模10得到当前位
    const currentDigit = Math.trunc(num / digitBase) % 10;

    if (currentDigit === 6) {
      // 将6变为9：差值是3，所以加上3*当前位权重
      num += 3 * digitBase;
      return num; // 只能翻转一位，找到后立即返回
    }

    // 移动到下一位（权重除以10）
    digitBase = Math.trunc(digitBase / 10);
  }

  return num; // 没有6可以翻转，返回原数字
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 在只由6和9组成的数字中，最多翻转一位数字使结果最大
   - 核心是找到能产生最大收益的翻转位置

2. 算法分析：
   - 时间复杂度：O(n)，n为数字的位数，需要遍历每一位
   - 空间复杂度：方法一O(n)需要字符数组，方法二O(1)纯数学运算
   - 算法类型：贪心算法

3. 实现要点：
   
   核心贪心策略：
   - 只有将6变为9才能让数字变大（9变6会变小）
   - 越高位的改变对结果影响越大
   - 因此从左到右找第一个6进行翻转即可获得最大值
   
   方法一（字符串）：
   - 转换为字符数组便于逐位操作
   - 从左到右线性扫描，找到第一个'6'就替换为'9'
   - 使用break确保只翻转一位
   
   方法二（数学）：
   - 计算最高位权重：10^(log10(num))
   - 逐位提取数字：(num / digitBase) % 10
   - 直接加上差值：6变9需要加3倍当前位权重
   - 避免字符串操作，空间效率更高

4. 优化思路：
   - 方法二避免了字符串转换，空间复杂度更优
   - 两种方法时间复杂度相同，都是O(n)
   - 实际应用中方法一更直观易懂，方法二更节省空间

5. 边界情况：
   - 全部是9：无法翻转，返回原数字
   - 全部是6：翻转最高位的6
   - 只有一位：6变9，9保持不变

6. 算法要点总结：
   - 贪心选择：优先翻转高位的6
   - 局部最优导致全局最优：高位权重大，优先翻转高位必然最优
   - 只翻转6为9：这是唯一能增大数值的操作
*/
