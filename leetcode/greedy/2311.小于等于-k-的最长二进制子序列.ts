/*
 * @lc app=leetcode.cn id=2311 lang=typescript
 *
 * [2311] 小于等于 K 的最长二进制子序列
 *
 * https://leetcode.cn/problems/longest-binary-subsequence-less-than-or-equal-to-k/description/
 *
 * algorithms
 * Medium (38.44%)
 * Likes:    51
 * Dislikes: 0
 * Total Accepted:    12.2K
 * Total Submissions: 28.4K
 * Testcase Example:  '"1001010"\n5'
 *
 * 给你一个二进制字符串 s 和一个正整数 k 。
 *
 * 请你返回 s 的 最长 子序列的长度，且该子序列对应的 二进制 数字小于等于 k 。
 *
 * 注意：
 *
 *
 * 子序列可以有 前导 0 。
 * 空字符串视为 0 。
 * 子序列 是指从一个字符串中删除零个或者多个字符后，不改变顺序得到的剩余字符序列。
 *
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：s = "1001010", k = 5
 * 输出：5
 * 解释：s 中小于等于 5 的最长子序列是 "00010" ，对应的十进制数字是 2 。
 * 注意 "00100" 和 "00101" 也是可行的最长子序列，十进制分别对应 4 和 5 。
 * 最长子序列的长度为 5 ，所以返回 5 。
 *
 *
 * 示例 2：
 *
 *
 * 输入：s = "00101001", k = 1
 * 输出：6
 * 解释："000001" 是 s 中小于等于 1 的最长子序列，对应的十进制数字是 1 。
 * 最长子序列的长度为 6 ，所以返回 6 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= s.length <= 1000
 * s[i] 要么是 '0' ，要么是 '1' 。
 * 1 <= k <= 10^9
 *
 *
 */

// @lc code=start
function longestSubsequence(s: string, k: number): number {
  const n = s.length;
  let cnt = 0; // 当前子序列的长度
  let small = 0; // 当前子序列表示的十进制值
  const bits = Math.log2(k) + 1; // k 的二进制位数上限

  // 从右往左遍历字符串（从低位到高位）
  for (let i = 0; i < n; i++) {
    const ch = s[n - i - 1]; // 获取第 i 位的字符

    if (ch === "1") {
      // 对于 '1'，需要判断是否可以添加到子序列中
      // 条件1: 当前位数不能超过 k 的位数（防止溢出）
      // 条件2: 添加这个 '1' 后总值不能超过 k
      if (i < bits && small + (1 << i) <= k) {
        small += 1 << i; // 在第 i 位加上 1 的贡献
        cnt++;
      }
      // 如果不满足条件，跳过这个 '1'
    } else {
      // 对于 '0'，总是可以添加，因为不会增加数值
      cnt++;
    }
  }

  return cnt;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 在二进制字符串中找最长子序列，使得该子序列表示的二进制数 ≤ k
   - 子序列可以有前导0，空字符串视为0
   - 需要贪心地选择字符来最大化子序列长度

2. 算法分析：
   - 时间复杂度：O(n)，其中 n 是字符串长度
   - 空间复杂度：O(1)，只使用常数额外空间
   - 算法类型：贪心算法

3. 实现要点：
   
   a) 贪心策略：
      - 对于 '0'：总是选择，因为添加 '0' 不会增加数值
      - 对于 '1'：只有在不超过 k 时才选择
   
   b) 从右往左处理（关键洞察）：
      - 从低位到高位处理，可以准确控制数值增长
      - 高位的 '1' 贡献更大，需要更谨慎处理
      - 低位的 '1' 优先考虑，因为贡献较小
   
   c) 位数限制优化：
      - 计算 k 的二进制位数：bits = log2(k) + 1
      - 超过这个位数的 '1' 必然会使结果 > k
      - 提前剪枝，避免不必要的计算
   
   d) 数值维护：
      - small 变量记录当前选择的子序列的十进制值
      - 每次选择 '1' 时，检查 small + 2^i ≤ k

4. 优化思路：
   
   a) 位运算优化：
      - 使用 (1 << i) 计算 2^i，比 Math.pow(2, i) 更高效
      - 位移操作的时间复杂度是 O(1)
   
   b) 早期剪枝：
      - 当位数超过 k 的位数时，所有后续的 '1' 都不能选择
      - 避免无效的计算和比较
   
   c) 内存优化：
      - 只需要维护当前数值和计数器
      - 不需要构造实际的子序列字符串

5. 算法正确性证明：
   
   a) 贪心选择的最优性：
      - '0' 总是有益的，因为不增加数值但增加长度
      - '1' 的选择遵循从低位到高位的原则
      - 低位的 '1' 比高位的 '1' 更容易满足约束
   
   b) 子问题最优性：
      - 每一步都做出局部最优选择
      - 局部最优解能够导向全局最优解

6. 示例分析：
   
   输入：s = "1001010", k = 5
   - bits = log2(5) + 1 = 3.32 ≈ 4
   - 从右往左处理: "0101001"
   - i=0, ch='0': cnt=1
   - i=1, ch='1': 1≤5, small=2, cnt=2
   - i=2, ch='0': cnt=3
   - i=3, ch='1': 2+8=10>5, 跳过
   - i=4, ch='0': cnt=4
   - i=5, ch='0': cnt=5
   - i=6, ch='1': 6≥4, 跳过
   - 结果: cnt=5, 对应子序列 "00010"

7. 边界情况处理：
   - k = 1：只能选择 '0' 和最多一个最低位的 '1'
   - s 全为 '1'：从低位开始累加，直到超过 k
   - s 全为 '0'：全部选择
   - k 很大：几乎所有字符都能选择
*/
