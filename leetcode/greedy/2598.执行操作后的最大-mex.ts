/*
 * @lc app=leetcode.cn id=2598 lang=typescript
 *
 * [2598] 执行操作后的最大 MEX
 *
 * https://leetcode.cn/problems/smallest-missing-non-negative-integer-after-operations/description/
 *
 * algorithms
 * Medium (40.61%)
 * Likes:    39
 * Dislikes: 0
 * Total Accepted:    14.9K
 * Total Submissions: 31.1K
 * Testcase Example:  '[1,-10,7,13,6,8]\n5'
 *
 * 给你一个下标从 0 开始的整数数组 nums 和一个整数 value 。
 *
 * 在一步操作中，你可以对 nums 中的任一元素加上或减去 value 。
 *
 *
 * 例如，如果 nums = [1,2,3] 且 value = 2 ，你可以选择 nums[0] 减去 value ，得到 nums = [-1,2,3]
 * 。
 *
 *
 * 数组的 MEX (minimum excluded) 是指其中数组中缺失的最小非负整数。
 *
 *
 * 例如，[-1,2,3] 的 MEX 是 0 ，而 [1,0,3] 的 MEX 是 2 。
 *
 *
 * 返回在执行上述操作 任意次 后，nums 的最大 MEX 。
 *
 *
 *
 * 示例 1：
 *
 * 输入：nums = [1,-10,7,13,6,8], value = 5
 * 输出：4
 * 解释：执行下述操作可以得到这一结果：
 * - nums[1] 加上 value 两次，nums = [1,0,7,13,6,8]
 * - nums[2] 减去 value 一次，nums = [1,0,2,13,6,8]
 * - nums[3] 减去 value 两次，nums = [1,0,2,3,6,8]
 * nums 的 MEX 是 4 。可以证明 4 是可以取到的最大 MEX 。
 *
 *
 * 示例 2：
 *
 * 输入：nums = [1,-10,7,13,6,8], value = 7
 * 输出：2
 * 解释：执行下述操作可以得到这一结果：
 * - nums[2] 减去 value 一次，nums = [1,-10,0,13,6,8]
 * nums 的 MEX 是 2 。可以证明 2 是可以取到的最大 MEX 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length, value <= 10^5
 * -10^9 <= nums[i] <= 10^9
 *
 *
 */

// @lc code=start
function findSmallestInteger(nums: number[], value: number): number {
  // 核心观察：将 nums 中的每个数对 value 取模
  // 具有相同模余的数可以通过加减 value 的倍数相互转换
  // 例如，对于 value=5：
  //   - 模余为 0 的数：0, 5, 10, -5, -10, ...
  //   - 模余为 1 的数：1, 6, 11, -4, -9, ...
  //   - 模余为 2 的数：2, 7, 12, -3, -8, ...

  // count[i] 记录模余为 i 的元素个数
  const count = new Array(value).fill(0);

  // 遍历所有元素，计算每个模余类中的元素个数
  for (const num of nums) {
    // 计算 num 对 value 的模余
    // 注意：JavaScript 中负数的模运算结果可能为负数
    // 例如：(-1) % 5 = -1，而不是 4
    let mod = num % value;

    // 处理负数的模余，转换为 [0, value) 范围内的值
    // 例如：-1 % 5 = -1，加上 5 得到 4，这样 -1 和 4 被视为同一类
    if (mod < 0) mod += value;

    // 增加该模余类的计数
    count[mod]++;
  }

  // 贪心地构造 MEX：从 0 开始逐个尝试填充
  let res = 0;

  // 当存在可以转换为 res 的元素时（即 res % value 对应的类中还有剩余元素）
  // 使用一个元素来代表 res，然后尝试填充 res+1
  while (count[res % value] > 0) {
    // 使用一个来自 res % value 类的元素来代表 res
    count[res % value]--;

    // 尝试下一个数
    res++;
  }

  // 当某个数无法被填充时，该数就是最小缺失的非负整数（MEX）
  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - MEX 是指缺失的最小非负整数（Minimum Excluded）
   - 通过对数组元素进行加减 value 的操作，改变数组内容
   - 目标是最大化 MEX 值，即让数组从 0 开始尽可能连续地包含非负整数
   
2. 核心观察（关键洞察）：
   - 关键发现：num1 和 num2 能否相互转换的条件是什么？
   - 如果 num1 - num2 是 value 的倍数，则它们可以相互转换
   - 这等价于 num1 % value === num2 % value（模余相同）
   
   - 具体例子（value=5）：
     * 模余为 0：..., -10, -5, 0, 5, 10, 15, ...
     * 模余为 1：..., -9, -4, 1, 6, 11, 16, ...
     * 模余为 2：..., -8, -3, 2, 7, 12, 17, ...
   
   - 因此，我们可以将数组分成 value 个"模余类"
   - 每个模余类中的数可以任意转换为该类的任何其他数
   - 问题转化为：从这些模余类中选择元素填充 [0, 1, 2, ...]

3. 算法分析：
   - 时间复杂度：O(n + MEX) ≈ O(n) - 因为 MEX ≤ n
     * 第一次循环：遍历 n 个元素
     * 第二次循环：最多迭代 n 次（MEX 最大为 n）
   - 空间复杂度：O(value) - 模余计数数组
   - 算法类型：贪心 + 哈希统计

4. 算法步骤：
   第一阶段：模余分类统计
   ① 创建长度为 value 的计数数组 count
   ② 遍历 nums，计算每个元素的模余（处理负数情况）
   ③ 统计每个模余类中的元素个数
   
   第二阶段：贪心填充
   ① 从 res=0 开始逐个尝试填充
   ② 检查是否存在可转换为 res 的元素（即 count[res % value] > 0）
   ③ 如果存在，使用一个元素来代表 res，减少该模余类的计数
   ④ 继续尝试 res+1
   ⑤ 当某个数无法被填充时，返回该数作为 MEX

5. 示例分析1：nums = [1,-10,7,13,6,8], value = 5

   第一步：计算模余
   - 1 % 5 = 1
   - -10 % 5 = 0（注意：处理后为 0）
   - 7 % 5 = 2
   - 13 % 5 = 3
   - 6 % 5 = 1
   - 8 % 5 = 3
   
   count = [1, 2, 1, 2, 0]
           (模余 0 有 1 个，模余 1 有 2 个，模余 2 有 1 个，模余 3 有 2 个)
   
   第二步：贪心填充
   - res=0: count[0%5=0]=1>0，使用一个元素代表 0，count[0]--，res=1
   - res=1: count[1%5=1]=2>0，使用一个元素代表 1，count[1]--，res=2
   - res=2: count[2%5=2]=1>0，使用一个元素代表 2，count[2]--，res=3
   - res=3: count[3%5=3]=2>0，使用一个元素代表 3，count[3]--，res=4
   - res=4: count[4%5=4]=0，无法填充 4，返回 4
   
   答案：4 ✓
   
   对应的转换：
   - 原数组：[1, -10, 7, 13, 6, 8]
   - -10 加两次 5 得 0
   - 7 减一次 5 得 2
   - 13 减两次 5 得 3
   - 结果：[1, 0, 2, 3, 6, 8]
   - MEX = 4

6. 示例分析2：nums = [1,-10,7,13,6,8], value = 7

   第一步：计算模余
   - 1 % 7 = 1
   - -10 % 7 = 4（-10 % 7 = -3，-3+7=4）
   - 7 % 7 = 0
   - 13 % 7 = 6
   - 6 % 7 = 6
   - 8 % 7 = 1
   
   count = [1, 2, 0, 0, 1, 0, 2]
   
   第二步：贪心填充
   - res=0: count[0]=1>0，res=1
   - res=1: count[1]=2>0，res=2
   - res=2: count[2]=0，无法填充 2，返回 2
   
   答案：2 ✓

7. 负数模余处理（重要细节）：
   - JavaScript 中：(-1) % 5 = -1（而不是 4）
   - 但我们需要：-1 和 4 属于同一个模余类
   - 处理方式：if (mod < 0) mod += value
   - 这样 -1 变成 4，-6 变成 4，都代表同一类
   
   为什么有效？
   - -1 = -1 * 5 + 4（在通常的除法表示中）
   - -1 和 4 的差是 -5（value 的倍数）
   - 所以 -1 可以加 5 得到 4（属于同一转换链）

8. 贪心性质证明：
   - 为什么贪心从 0 开始逐个填充一定能得到最大 MEX？
   - 假设最优解不是从 0 开始连续填充
   - 那一定存在某个位置 k，k 之前都能填充，k 无法填充
   - 这意味着没有可用的元素的模余为 k % value
   - 我们的算法也会在 k 处停止
   - 因此贪心策略是最优的

9. 为什么使用模余分类：
   - 直接存储所有元素再排序效率不高（元素值范围太大）
   - 通过模余分类：
     * 减少存储空间：只需 value 个计数
     * 简化判断逻辑：模余相同 ⟹ 可以相互转换
     * 提高效率：O(value) 的空间而非 O(max_value)

10. 边界情况：
    - 空数组或单元素数组：MEX = 0 或 1
    - value = 1：所有数都属于模余类 0，MEX = n
    - value > n：不同的数可能属于不同的模余类
    - 负数：正确处理负数模余是关键

11. 常见错误：
    - 忘记处理负数模余：直接使用 % 得到错误结果
    - 逻辑反向：应该是 count > 0 才能继续填充
    - 模余计算：res % value 而非 res / value

12. 扩展思考：
    - 如果题目要求返回能达到最大 MEX 的具体操作序列？
    - 需要反向追踪哪个元素被用来代表每个位置
    - 可以记录每个模余类中的具体元素列表
    - 然后根据需要计算每个元素需要加减多少倍的 value
*/
