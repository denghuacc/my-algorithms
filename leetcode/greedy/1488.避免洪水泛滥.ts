/*
 * @lc app=leetcode.cn id=1488 lang=typescript
 *
 * [1488] 避免洪水泛滥
 *
 * https://leetcode.cn/problems/avoid-flood-in-the-city/description/
 *
 * algorithms
 * Medium (26.33%)
 * Likes:    157
 * Dislikes: 0
 * Total Accepted:    16.4K
 * Total Submissions: 59.1K
 * Testcase Example:  '[1,2,3,4]'
 *
 * 你的国家有无数个湖泊，所有湖泊一开始都是空的。当第 n 个湖泊下雨前是空的，那么它就会装满水。如果第 n 个湖泊下雨前是 满的 ，这个湖泊会发生 洪水
 * 。你的目标是避免任意一个湖泊发生洪水。
 *
 * 给你一个整数数组 rains ，其中：
 *
 *
 * rains[i] > 0 表示第 i 天时，第 rains[i] 个湖泊会下雨。
 * rains[i] == 0 表示第 i 天没有湖泊会下雨，你可以选择 一个 湖泊并 抽干 这个湖泊的水。
 *
 *
 * 请返回一个数组 ans ，满足：
 *
 *
 * res.length == rains.length
 * 如果 rains[i] > 0 ，那么ans[i] == -1 。
 * 如果 rains[i] == 0 ，ans[i] 是你第 i 天选择抽干的湖泊。
 *
 *
 * 如果有多种可行解，请返回它们中的 任意一个 。如果没办法阻止洪水，请返回一个 空的数组 。
 *
 * 请注意，如果你选择抽干一个装满水的湖泊，它会变成一个空的湖泊。但如果你选择抽干一个空的湖泊，那么将无事发生。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：rains = [1,2,3,4]
 * 输出：[-1,-1,-1,-1]
 * 解释：第一天后，装满水的湖泊包括 [1]
 * 第二天后，装满水的湖泊包括 [1,2]
 * 第三天后，装满水的湖泊包括 [1,2,3]
 * 第四天后，装满水的湖泊包括 [1,2,3,4]
 * 没有哪一天你可以抽干任何湖泊的水，也没有湖泊会发生洪水。
 *
 *
 * 示例 2：
 *
 *
 * 输入：rains = [1,2,0,0,2,1]
 * 输出：[-1,-1,2,1,-1,-1]
 * 解释：第一天后，装满水的湖泊包括 [1]
 * 第二天后，装满水的湖泊包括 [1,2]
 * 第三天后，我们抽干湖泊 2 。所以剩下装满水的湖泊包括 [1]
 * 第四天后，我们抽干湖泊 1 。所以暂时没有装满水的湖泊了。
 * 第五天后，装满水的湖泊包括 [2]。
 * 第六天后，装满水的湖泊包括 [1,2]。
 * 可以看出，这个方案下不会有洪水发生。同时， [-1,-1,1,2,-1,-1] 也是另一个可行的没有洪水的方案。
 *
 *
 * 示例 3：
 *
 *
 * 输入：rains = [1,2,0,1,2]
 * 输出：[]
 * 解释：第二天后，装满水的湖泊包括 [1,2]。我们可以在第三天抽干一个湖泊的水。
 * 但第三天后，湖泊 1 和 2 都会再次下雨，所以不管我们第三天抽干哪个湖泊的水，另一个湖泊都会发生洪水。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= rains.length <= 10^5
 * 0 <= rains[i] <= 10^9
 *
 *
 */

// @lc code=start

/**
 * 避免洪水泛滥 - 贪心算法 + 二分搜索
 *
 * 核心思想：
 * 1. 当湖泊下雨时，检查是否已经有水，如果有则需要在之前的某个空闲日抽干
 * 2. 使用贪心策略：总是选择最早的可用空闲日来抽干即将重复下雨的湖泊
 * 3. 用二分搜索快速找到合适的空闲日
 */
function avoidFlood(rains: number[]): number[] {
  const n = rains.length;

  // 结果数组，初始化为1（空闲日的默认抽水选择）
  const res = new Array(n).fill(1);

  // st数组存储所有空闲日的索引（按时间顺序）
  const st: number[] = [];

  // map记录每个湖泊上次下雨的日期
  const map = new Map<number, number>();

  // 遍历每一天
  for (let i = 0; i < n; i++) {
    if (rains[i] === 0) {
      // 空闲日：记录索引，稍后可能用来抽水
      st.push(i);
    } else {
      // 下雨日：设置结果为-1
      res[i] = -1;

      // 检查这个湖泊之前是否下过雨
      if (map.has(rains[i])) {
        // 湖泊已有水，需要在上次下雨后找一个空闲日抽干
        const lastRainDay = map.get(rains[i])!;

        // 在空闲日列表中找到第一个大于lastRainDay的索引
        const idx = getFirstIndex(st, lastRainDay);

        if (idx === -1) {
          // 没有合适的空闲日可以抽水，无法避免洪水
          return [];
        }

        // 在找到的空闲日抽干这个湖泊
        res[st[idx]] = rains[i];

        // 移除已使用的空闲日
        st.splice(idx, 1);
      }

      // 更新湖泊的最新下雨日期
      map.set(rains[i], i);
    }
  }

  return res;

  /**
   * 二分搜索：在有序数组arr中找到第一个大于k的元素的索引
   *
   * 🔍 关键理解：为什么必须找"大于k"的元素？
   * - 业务逻辑：只能在上次下雨(k)之后的空闲日抽水
   * - 时间约束：在第k天之前抽水是无效的（湖泊可能还是空的）
   * - 贪心策略：选择最早的有效空闲日（即第一个 > k 的日期）
   *
   * @param arr 有序数组（存储空闲日索引）
   * @param k 目标值（上次下雨的日期）
   * @returns 第一个大于k的元素索引，如果不存在则返回-1
   */
  function getFirstIndex(arr: number[], k: number): number {
    // 边界检查：空数组或k大于等于最大值
    if (arr.length === 0 || k >= arr[arr.length - 1]) {
      return -1;
    }

    let low = 0;
    let high = arr.length - 1;

    // 二分搜索找到第一个大于k的位置
    while (low <= high) {
      const mid = low + Math.floor((high - low) / 2);

      if (arr[mid] > k) {
        // 当前值大于k，可能是答案，继续在左半部分搜索
        high = mid - 1;
      } else {
        // 当前值小于等于k，答案在右半部分
        // 注意：arr[mid] <= k 的情况都不符合要求
        low = mid + 1;
      }
    }

    // low指向第一个大于k的位置
    return low < arr.length ? low : -1;
  }
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 湖泊下雨时会装满水，如果已经有水就会发生洪水
   - 空闲日可以选择抽干一个湖泊的水
   - 目标：合理安排抽水计划，避免任何湖泊发生洪水

2. 核心观察：
   - 只有当湖泊即将第二次下雨时才需要考虑抽水
   - 贪心策略：当发现湖泊重复下雨时，立即寻找最近的空闲日进行抽水
   - 关键时机：必须在上次下雨之后、这次下雨之前的空闲日抽水

3. 算法分析：
   时间复杂度：O(n²) - 每次删除空闲日需要O(n)时间
   空间复杂度：O(n) - 存储空闲日索引和湖泊状态
   
   优化版本可以用平衡二叉搜索树达到O(nlogn)时间复杂度

4. 算法步骤：
   - 遍历每一天的天气情况
   - 空闲日(rains[i] = 0)：记录索引，留待后用
   - 下雨日(rains[i] > 0)：
     * 设置res[i] = -1
     * 检查该湖泊是否之前下过雨
     * 如果是重复下雨，在空闲日中找合适的时机抽水
     * 更新湖泊的最新下雨时间

5. 关键技巧：
   - 使用HashMap记录每个湖泊的上次下雨时间
   - 用数组维护所有空闲日的索引（按时间顺序）
   - 二分搜索快速找到第一个可用的空闲日
   - 贪心选择：总是选择最早的可用空闲日

6. 示例分析 - rains = [1,2,0,0,2,1]：
   
   第0天：湖泊1下雨
   - res[0] = -1，map = {1: 0}
   
   第1天：湖泊2下雨
   - res[1] = -1，map = {1: 0, 2: 1}
   
   第2天：空闲日
   - st = [2]
   
   第3天：空闲日
   - st = [2, 3]
   
   第4天：湖泊2下雨（重复！）
   - 湖泊2上次在第1天下雨，需要在第1天后的空闲日抽水
   - 在st中找第一个大于1的索引：st[0] = 2 > 1，选择第2天
   - res[2] = 2，st = [3]
   - res[4] = -1，map = {1: 0, 2: 4}
   
   第5天：湖泊1下雨（重复！）
   - 湖泊1上次在第0天下雨，需要在第0天后的空闲日抽水
   - 在st中找第一个大于0的索引：st[0] = 3 > 0，选择第3天
   - res[3] = 1，st = []
   - res[5] = -1
   
   最终结果：[-1, -1, 2, 1, -1, -1]

7. 二分搜索细节：
   - 目标：在有序数组中找第一个大于target的元素
   - 标准的"寻找右边界"模板
   - 边界条件：空数组或target大于等于最大值时返回-1

8. 贪心正确性证明：
   - 当湖泊重复下雨时，必须在两次下雨之间抽水
   - 选择最早的空闲日不会影响后续决策的可行性
   - 如果最早的空闲日都不能满足，那么后面的空闲日也无法满足

9. 边界情况处理：
   - 没有空闲日但有重复下雨：返回空数组
   - 所有空闲日都在重复下雨之前：返回空数组
   - 只有空闲日没有下雨：所有空闲日可以随意抽水

10. 常见错误：
    - 忘记在使用空闲日后从列表中移除
    - 二分搜索边界条件处理错误
    - 没有正确理解"第一个大于k"的含义
    - 贪心策略理解错误，选择了错误的空闲日

11. 优化思考：
    - 可以用TreeSet等平衡二叉搜索树优化删除操作
    - 预处理：提前计算每个湖泊的所有下雨日期
    - 延迟决策：不立即分配空闲日，而是在最后统一处理

12. 类似问题：
    - 会议室调度问题
    - 任务分配与资源管理
    - 区间调度优化问题
*/
