/*
 * @lc app=leetcode.cn id=1717 lang=typescript
 *
 * [1717] 删除子字符串的最大得分
 *
 * https://leetcode.cn/problems/maximum-score-from-removing-substrings/description/
 *
 * algorithms
 * Medium (50.85%)
 * Likes:    61
 * Dislikes: 0
 * Total Accepted:    11.9K
 * Total Submissions: 20.3K
 * Testcase Example:  '"cdbcbbaaabab"\n4\n5'
 *
 * 给你一个字符串 s 和两个整数 x 和 y 。你可以执行下面两种操作任意次。
 *
 *
 * 删除子字符串 "ab" 并得到 x 分。
 *
 *
 * 比方说，从 "cabxbae" 删除 ab ，得到 "cxbae" 。
 *
 *
 * 删除子字符串"ba" 并得到 y 分。
 *
 * 比方说，从 "cabxbae" 删除 ba ，得到 "cabxe" 。
 *
 *
 *
 *
 * 请返回对 s 字符串执行上面操作若干次能得到的最大得分。
 *
 *
 *
 * 示例 1：
 *
 * 输入：s = "cdbcbbaaabab", x = 4, y = 5
 * 输出：19
 * 解释：
 * - 删除 "cdbcbbaaabab" 中加粗的 "ba" ，得到 s = "cdbcbbaaab" ，加 5 分。
 * - 删除 "cdbcbbaaab" 中加粗的 "ab" ，得到 s = "cdbcbbaa" ，加 4 分。
 * - 删除 "cdbcbbaa" 中加粗的 "ba" ，得到 s = "cdbcba" ，加 5 分。
 * - 删除 "cdbcba" 中加粗的 "ba" ，得到 s = "cdbc" ，加 5 分。
 * 总得分为 5 + 4 + 5 + 5 = 19 。
 *
 * 示例 2：
 *
 * 输入：s = "aabbaaxybbaabb", x = 5, y = 4
 * 输出：20
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= s.length <= 10^5
 * 1 <= x, y <= 10^4
 * s 只包含小写英文字母。
 *
 *
 */

export {};

// @lc code=start
function maximumGain(s: string, x: number, y: number): number {
  // 贪心策略：优先删除得分更高的子字符串
  // 如果 y > x，交换 x, y 并转换字符串，确保 x >= y
  if (x < y) {
    [x, y] = [y, x];
    // 将字符串中的 'a' 和 'b' 互换，这样就可以统一处理
    // 原来删除 "ba" 得 y 分，现在删除 "ab" 得 x 分
    s = s.replace(/./g, (c) => (c === "a" ? "b" : c === "b" ? "a" : c));
  }

  let res = 0;
  let i = 0;

  // 遍历整个字符串
  while (i < s.length) {
    let cntA = 0; // 记录当前连续片段中 'a' 的个数
    let cntB = 0; // 记录当前连续片段中剩余 'b' 的个数

    // 处理连续的 'a' 和 'b' 片段
    while (i < s.length && (s[i] === "a" || s[i] === "b")) {
      if (s[i] === "a") {
        cntA++; // 遇到 'a'，计数加1
      } else {
        // 遇到 'b'
        if (cntA > 0) {
          // 如果前面有 'a'，立即配对删除 "ab"，得到 x 分
          cntA--;
          res += x;
        } else {
          // 如果前面没有 'a'，记录这个 'b'
          cntB++;
        }
      }
      i++;
    }

    // 处理完连续片段后，剩余的 'a' 和 'b' 配对删除 "ba"
    // 能配对的数量是 min(cntA, cntB)
    res += Math.min(cntA, cntB) * y;

    // 跳过非 'a' 非 'b' 的字符
    i++;
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 在字符串中删除 "ab" 和 "ba" 子串获得分数，求最大总分
   - 核心是确定删除顺序以获得最大收益

2. 算法分析：
   - 时间复杂度：O(n) - 只需要遍历字符串一次
   - 空间复杂度：O(1) - 只使用常量额外空间
   - 算法类型：贪心算法

3. 实现要点：

   a) 贪心策略：
   - 优先删除得分更高的子字符串
   - 通过确保 x >= y 来统一处理逻辑

   b) 字符串转换技巧：
   - 当 y > x 时，交换 x, y 的值
   - 同时将字符串中 'a' 和 'b' 互换
   - 这样原来的 "ba"(y分) 变成 "ab"(x分)，统一优先删除 "ab"

   c) 核心处理逻辑：
   - 对每个连续的 'a','b' 片段分别处理
   - 遇到 'b' 时，如果前面有 'a' 就立即配对删除获得 x 分
   - 片段结束后，剩余的 'a' 和 'b' 配对删除获得 y 分

   d) 边界情况处理：
   - 非 'a','b' 字符自然分割片段
   - 片段内优先处理高分删除，剩余部分处理低分删除

4. 优化要点：

   a) 一次遍历：
   - 不需要真正删除字符串，只需要计数
   - 边遍历边处理，避免多次扫描

   b) 贪心选择：
   - 总是优先删除得分更高的组合
   - 通过字符转换简化逻辑分支

   c) 状态维护：
   - 用计数器代替实际字符操作
   - 实时更新得分，避免重复计算

5. 核心技巧：

   a) 问题转换：
   - 将两种情况统一为一种情况处理
   - 通过交换参数和字符简化算法逻辑

   b) 贪心证明：
   - 对于任意 'a' 和 'b' 的组合，优先删除高分的总是最优
   - 剩余字符的配对不会影响已删除部分的最优性

   c) 片段处理：
   - 非 'a','b' 字符天然分割独立处理区域
   - 每个区域内的处理互不影响

6. 类似问题：
   - 括号匹配问题（优先级不同的匹配）
   - 股票买卖问题（不同交易费用）
   - 字符串删除获得最大价值问题

7. 常见错误：
   - 忽略贪心策略，尝试动态规划（过度复杂化）
   - 没有统一处理逻辑，分情况讨论导致代码冗余
   - 实际删除字符串导致时间复杂度过高
*/
