/*
 * @lc app=leetcode.cn id=3397 lang=typescript
 *
 * [3397] 执行操作后不同元素的最大数量
 *
 * https://leetcode.cn/problems/maximum-number-of-distinct-elements-after-operations/description/
 *
 * algorithms
 * Medium (38.65%)
 * Likes:    31
 * Dislikes: 0
 * Total Accepted:    13.1K
 * Total Submissions: 24.9K
 * Testcase Example:  '[1,2,2,3,3,4]\n2'
 *
 * 给你一个整数数组 nums 和一个整数 k。
 *
 * 你可以对数组中的每个元素 最多 执行 一次 以下操作：
 *
 *
 * 将一个在范围 [-k, k] 内的整数加到该元素上。
 *
 *
 * 返回执行这些操作后，nums 中可能拥有的不同元素的 最大 数量。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入： nums = [1,2,2,3,3,4], k = 2
 *
 * 输出： 6
 *
 * 解释：
 *
 * 对前四个元素执行操作，nums 变为 [-1, 0, 1, 2, 3, 4]，可以获得 6 个不同的元素。
 *
 *
 * 示例 2：
 *
 *
 * 输入： nums = [4,4,4,4], k = 1
 *
 * 输出： 3
 *
 * 解释：
 *
 * 对 nums[0] 加 -1，以及对 nums[1] 加 1，nums 变为 [3, 5, 4, 4]，可以获得 3 个不同的元素。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 10^5
 * 1 <= nums[i] <= 10^9
 * 0 <= k <= 10^9
 *
 *
 */

// @lc code=start
function maxDistinctElements(nums: number[], k: number): number {
  // 核心思路：贪心策略 + 排序
  // 为了最大化不同元素的数量，我们希望调整后的值尽可能分散且不重复

  // 第一步：对数组排序
  // 排序的目的：从小到大处理元素，便于贪心地选择最小可用值
  nums.sort((a, b) => a - b);

  // cnt: 统计不同元素的数量
  let cnt = 0;

  // prev: 记录上一个已经使用的调整后的值
  // 初始化为负无穷，确保第一个元素一定能被选择
  let prev = -Infinity;

  // 遍历排序后的数组
  for (const num of nums) {
    // 对于当前元素 num，它可以调整到 [num-k, num+k] 范围内的任意整数
    // 贪心策略：为了给后续元素留下更大的选择空间，
    // 我们希望选择当前可用范围内的最小值

    // adjusted 是我们为当前元素选择的调整后的值
    // 计算方式：取 (num-k) 和 (prev+1) 中的较大值
    // - num-k: 当前元素可调整到的最小值
    // - prev+1: 为了不与前一个元素重复，至少要是 prev+1
    const adjusted = Math.max(num - k, prev + 1);

    // 检查 adjusted 是否在当前元素的合法调整范围内
    // 合法范围：[num-k, num+k]
    if (adjusted <= num + k) {
      // 如果在范围内，说明当前元素可以被调整为一个新的不同值
      cnt++;

      // 更新 prev 为当前选择的值，供下一个元素参考
      prev = adjusted;
    }
    // 如果 adjusted > num+k，说明即使调整到最大值 num+k，
    // 也无法避免与前面的元素重复，所以跳过当前元素
  }

  return cnt;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 每个元素可以调整为 [num-k, num+k] 范围内的任意整数
   - 目标：通过调整使得数组中不同元素的数量最大化
   - 关键约束：每个元素只能操作一次
   - 核心挑战：如何分配调整后的值，使得重复最少

2. 算法分析：
   - 时间复杂度：O(n log n) - 主要是排序的开销
   - 空间复杂度：O(1) - 只使用常数额外空间（原地排序）
   - 算法类型：贪心算法 + 排序

3. 核心思路：

   问题转化：
   - 原问题：如何调整每个元素使不同元素数量最大？
   - 转化后：如何为每个元素分配一个调整后的值，使得冲突最小？
   
   关键洞察：
   ① 排序的必要性：
      - 先排序可以让我们从小到大处理元素
      - 对于较小的元素，我们优先分配较小的调整值
      - 这样可以为后续的大元素留下更大的选择空间
   
   ② 贪心策略：
      - 对于每个元素，选择其合法范围内的"最小可用值"
      - "最小可用值"定义：不与前面已选择的值冲突的最小整数
      - 公式：max(num-k, prev+1)
        * num-k: 当前元素的最小调整值
        * prev+1: 不与前一个值冲突的最小值
   
   ③ 为什么贪心是最优的？
      - 选择更小的值不会影响当前元素的可选性
      - 但会给后续元素留下更多选择空间
      - 因为后续元素本身就更大，需要更大的调整值

4. 算法步骤：

   步骤 1：排序
   - 将 nums 从小到大排序
   - 时间：O(n log n)
   
   步骤 2：初始化
   - cnt = 0（不同元素计数）
   - prev = -∞（上一个使用的值）
   
   步骤 3：贪心遍历
   对于每个元素 num：
   ① 计算理想调整值：adjusted = max(num-k, prev+1)
   ② 检查是否在合法范围内：adjusted ≤ num+k？
   ③ 如果合法：
      - cnt++（找到一个新的不同元素）
      - prev = adjusted（更新用于下一轮）
   ④ 如果不合法：
      - 跳过该元素（无法避免重复）
   
   步骤 4：返回 cnt

5. 示例分析1：nums = [1,2,2,3,3,4], k = 2

   初始化：
   - 排序后：[1, 2, 2, 3, 3, 4]
   - cnt = 0, prev = -∞
   
   逐步处理：
   
   ① num = 1，范围 [1-2, 1+2] = [-1, 3]
      adjusted = max(-1, -∞+1) = -1
      -1 ≤ 3 ✓ 合法
      cnt = 1, prev = -1
      选择：1 → -1
   
   ② num = 2，范围 [0, 4]
      adjusted = max(0, -1+1) = 0
      0 ≤ 4 ✓ 合法
      cnt = 2, prev = 0
      选择：2 → 0
   
   ③ num = 2，范围 [0, 4]
      adjusted = max(0, 0+1) = 1
      1 ≤ 4 ✓ 合法
      cnt = 3, prev = 1
      选择：2 → 1
   
   ④ num = 3，范围 [1, 5]
      adjusted = max(1, 1+1) = 2
      2 ≤ 5 ✓ 合法
      cnt = 4, prev = 2
      选择：3 → 2
   
   ⑤ num = 3，范围 [1, 5]
      adjusted = max(1, 2+1) = 3
      3 ≤ 5 ✓ 合法
      cnt = 5, prev = 3
      选择：3 → 3
   
   ⑥ num = 4，范围 [2, 6]
      adjusted = max(2, 3+1) = 4
      4 ≤ 6 ✓ 合法
      cnt = 6, prev = 4
      选择：4 → 4
   
   最终结果：
   - 原数组：[1, 2, 2, 3, 3, 4]
   - 调整后：[-1, 0, 1, 2, 3, 4]
   - 不同元素数量：6 ✓

6. 示例分析2：nums = [4,4,4,4], k = 1

   初始化：
   - 排序后：[4, 4, 4, 4]
   - cnt = 0, prev = -∞
   
   逐步处理：
   
   ① num = 4，范围 [3, 5]
      adjusted = max(3, -∞+1) = 3
      3 ≤ 5 ✓ 合法
      cnt = 1, prev = 3
      选择：4 → 3
   
   ② num = 4，范围 [3, 5]
      adjusted = max(3, 3+1) = 4
      4 ≤ 5 ✓ 合法
      cnt = 2, prev = 4
      选择：4 → 4
   
   ③ num = 4，范围 [3, 5]
      adjusted = max(3, 4+1) = 5
      5 ≤ 5 ✓ 合法
      cnt = 3, prev = 5
      选择：4 → 5
   
   ④ num = 4，范围 [3, 5]
      adjusted = max(3, 5+1) = 6
      6 ≤ 5 ✗ 不合法
      跳过此元素
   
   最终结果：
   - 原数组：[4, 4, 4, 4]
   - 调整后：[3, 4, 5, (无法调整)]
   - 不同元素数量：3 ✓

7. 贪心正确性证明：

   命题：选择最小可用值的贪心策略能得到最优解。
   
   证明（反证法）：
   - 假设存在更优解，其中某个元素 num_i 没有选择最小可用值
   - 设最小可用值为 v_min，而最优解选择了 v_opt > v_min
   - 因为 v_min 和 v_opt 都在 [num_i-k, num_i+k] 范围内
   - 将 v_opt 替换为 v_min 不会影响前面的元素（它们都 < v_min）
   - 但会给后续元素更多空间（因为 v_min < v_opt）
   - 因此至少能得到相同或更好的结果
   - 矛盾！所以贪心策略是最优的

8. 关键观察：

   ① 排序的作用：
      - 确保我们按递增顺序处理元素
      - 避免大元素"抢占"小的调整值
   
   ② 为什么是 prev + 1？
      - 整数集合中，避免重复的最小间隔是 1
      - prev + 1 是不与 prev 冲突的最小整数
   
   ③ 为什么有些元素会被跳过？
      - 当 adjusted > num + k 时，无论如何调整都会与前面重复
      - 说明前面的元素已经"占满"了当前元素的所有可能值
   
   ④ 调整范围的意义：
      - [num-k, num+k] 定义了每个元素的"灵活空间"
      - k 越大，灵活性越高，能避免重复的可能性越大

9. 边界情况：

   ① k = 0（无法调整）：
      - 每个元素只能保持原值
      - 答案 = 原数组中不同元素的个数
      - 算法依然正确（adjusted = num）
   
   ② 所有元素相同：
      - 例如 nums = [5,5,5,5], k = 2
      - 可以调整为 [3,4,5,6,7] 中的不同值
      - 答案 = min(n, 2k+1)
   
   ③ 元素间隔很大：
      - 例如 nums = [1, 100], k = 2
      - 每个元素的调整范围不重叠
      - 答案 = n（所有元素都能保持不同）
   
   ④ 单元素数组：
      - 答案永远是 1

10. 复杂度优化思考：

    当前实现已经是最优的：
    - 排序：O(n log n) - 无法避免（贪心需要有序）
    - 遍历：O(n) - 已经是线性
    - 空间：O(1) - 已经是常数
    
    可能的优化方向：
    - 如果 k 非常大，可以提前判断答案 = n
    - 条件：k ≥ (max(nums) - min(nums)) / 2
    - 此时所有元素都能调整为不同值

11. 常见错误：

    ① 不排序直接贪心：
       - 错误原因：无法保证全局最优
       - 反例：[3,1,2], k=0 → 应该都不同，但不排序会出错
    
    ② 使用 Set 去重后处理：
       - 错误原因：丢失了重复元素的信息
       - 重复元素也可以通过调整变得不同
    
    ③ adjusted 计算错误：
       - 忘记 +1：会导致与 prev 重复
       - 使用 min 而非 max：逻辑完全反了
    
    ④ 边界检查遗漏：
       - 忘记检查 adjusted ≤ num+k
       - 会导致选择了超出合法范围的值

12. 扩展思考：

    ① 如果要求输出具体的调整方案：
       - 需要记录每个元素对应的 adjusted 值
       - 返回 (调整后的数组, 不同元素数量)
    
    ② 如果操作次数有限制：
       - 例如最多只能调整 m 个元素
       - 需要选择哪些元素调整以最大化不同元素数
       - 这会变成更复杂的优化问题
    
    ③ 如果每个元素的 k 值不同：
       - nums[i] 可以调整到 [nums[i]-k[i], nums[i]+k[i]]
       - 算法框架不变，但需要单独处理每个元素的范围
    
    ④ 二维扩展：
       - 如果是二维平面上的点，要最大化不同点的数量
       - 会涉及更复杂的几何和贪心策略

13. 类似问题：
    - LeetCode 2598: 执行操作后的最大 MEX（模运算 + 贪心）
    - LeetCode 1647: 字符频次唯一的最小删除次数（贪心）
    - LeetCode 870: 优势洗牌（排序 + 贪心匹配）
*/
