/*
 * @lc app=leetcode.cn id=3228 lang=typescript
 *
 * [3228] 将 1 移动到末尾的最大操作次数
 *
 * https://leetcode.cn/problems/maximum-number-of-operations-to-move-ones-to-the-end/description/
 *
 * algorithms
 * Medium (47.89%)
 * Likes:    16
 * Dislikes: 0
 * Total Accepted:    12.8K
 * Total Submissions: 21.8K
 * Testcase Example:  '"1001101"'
 *
 * 给你一个 二进制字符串 s。
 *
 * 你可以对这个字符串执行 任意次 下述操作：
 *
 *
 * 选择字符串中的任一下标 i（ i + 1 < s.length ），该下标满足 s[i] == '1' 且 s[i + 1] == '0'。
 * 将字符 s[i] 向 右移 直到它到达字符串的末端或另一个 '1'。例如，对于 s = "010010"，如果我们选择 i = 1，结果字符串将会是 s
 * = "000110"。
 *
 *
 * 返回你能执行的 最大 操作次数。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入： s = "1001101"
 *
 * 输出： 4
 *
 * 解释：
 *
 * 可以执行以下操作：
 *
 *
 * 选择下标 i = 0。结果字符串为 s = "0011101"。
 * 选择下标 i = 4。结果字符串为 s = "0011011"。
 * 选择下标 i = 3。结果字符串为 s = "0010111"。
 * 选择下标 i = 2。结果字符串为 s = "0001111"。
 *
 *
 *
 * 示例 2：
 *
 *
 * 输入： s = "00111"
 *
 * 输出： 0
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= s.length <= 10^5
 * s[i] 为 '0' 或 '1'。
 *
 *
 */

// @lc code=start
/**
 * 将 1 移动到末尾的最大操作次数
 *
 * 核心思路：
 * 每个 1 需要跨越其右侧的每个 0 块才能到达末尾
 * 从左到右遍历，遇到 0 块时，累加左侧所有 1 的数量
 * 这样就能统计出所有 1 移动到末尾所需的总操作次数
 */
function maxOperations(s: string): number {
  let res = 0; // 总操作次数
  let countOne = 0; // 当前位置左侧 1 的数量
  let i = 0; // 当前遍历位置
  const n = s.length;

  while (i < n) {
    if (s[i] === "0") {
      // 遇到 0，跳过所有连续的 0（将连续的 0 看作一个整体块）
      while (i + 1 < n && s[i + 1] === "0") {
        i++;
      }
      // 左侧的每个 1 都需要跨越这个 0 块，所以操作次数增加 countOne
      res += countOne;
    } else {
      // 遇到 1，累加计数
      countOne++;
    }
    i++;
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 将二进制字符串中的所有 1 移动到末尾
   - 每次操作：将一个 1 向右移动，直到遇到另一个 1 或到达末尾
   - 求最大操作次数（实际上就是将所有 1 移到末尾所需的操作次数）

2. 算法分析：
   - 时间复杂度：O(n) - 遍历字符串一次
   - 空间复杂度：O(1) - 只使用常数额外空间
   - 算法类型：贪心 + 数学规律

3. 解题思路：

   【核心观察】
   - 每个 1 要移动到末尾，必须跨越其右侧的所有 0
   - 连续的 0 可以看作一个整体「0 块」
   - 每个 1 跨越一个 0 块，需要的操作次数 = 0 块中 0 的数量
   
   【关键洞察】
   - 对于每个 0 块，左侧的每个 1 都需要跨越它
   - 因此，遇到 0 块时，操作次数增加「左侧 1 的数量」
   - 这样就能统计出所有 1 移动到末尾的总操作次数

   【算法步骤】
   1. 从左到右遍历字符串
   2. 遇到 1：累加 1 的计数
   3. 遇到 0：
      - 跳过所有连续的 0（合并为一个 0 块）
      - 将左侧所有 1 的数量加到结果中
   4. 返回总操作次数

   【为什么这样是对的】
   - 每个 1 最终都要到达末尾
   - 1 向右移动时，会跨越每个 0 块恰好一次
   - 因此，总操作次数 = ∑(每个 0 块左侧的 1 的数量)

4. 实现要点：

   【数据结构选择】
   - 只需要两个计数器：res（结果）和 countOne（左侧 1 的数量）
   - 不需要额外的数据结构

   【边界条件处理】
   - 字符串末尾是 1：不需要特殊处理，因为末尾的 1 不需要移动
   - 字符串末尾是 0：会正确累加左侧所有 1 的贡献
   - 全是 1 或全是 0：都会返回 0（正确）

   【优化技巧】
   - 将连续的 0 合并为一个块处理，避免重复计算
   - 每个 0 块只贡献一次左侧 1 的数量

5. 示例分析：

   【示例 1】s = "1001101"
   
   逐步分析：
   
   i=0: s[0]='1' → countOne=1
   i=1: s[1]='0' → 发现 0 块
        - 跳过连续的 0：s[1]='0', s[2]='0' → i 移动到 2
        - res += countOne = 0 + 1 = 1
        - （意义：左侧的 1 个 1 要跨越这个 0 块）
   
   i=3: s[3]='1' → countOne=2
   i=4: s[4]='1' → countOne=3
   i=5: s[5]='0' → 发现 0 块
        - 只有一个 0
        - res += countOne = 1 + 3 = 4
        - （意义：左侧的 3 个 1 都要跨越这个 0 块）
   
   i=6: s[6]='1' → countOne=4
   
   最终结果：res = 4
   
   验证过程：
   - "1001101" → "0011101" (1次：第1个1跨越00)
   - "0011101" → "0011011" (1次：第3个1跨越0)
   - "0011011" → "0010111" (1次：第2个1跨越0)
   - "0010111" → "0001111" (1次：第1个1跨越0)
   总共 4 次操作 ✓

   【示例 2】s = "00111"
   
   逐步分析：
   
   i=0: s[0]='0' → 发现 0 块
        - 跳过连续的 0：s[0]='0', s[1]='0' → i 移动到 1
        - res += countOne = 0 + 0 = 0
        - （意义：左侧没有 1，无需操作）
   
   i=2: s[2]='1' → countOne=1
   i=3: s[3]='1' → countOne=2
   i=4: s[4]='1' → countOne=3
   
   最终结果：res = 0
   
   解释：所有的 1 都已经在右侧，无需移动

6. 算法优势：
   - 一次遍历解决问题，效率高
   - 不需要实际模拟移动过程，直接计算结果
   - 代码简洁，易于理解和实现

7. 核心算法步骤：
   1. 初始化：结果 res = 0，左侧 1 的计数 countOne = 0
   2. 遍历字符串：
      - 遇到 '1'：countOne++
      - 遇到 '0'：跳过连续 0，res += countOne
   3. 返回 res

8. 常见错误：
   
   - ❌ 忘记合并连续的 0：
     * 如果每个 0 都单独处理，会导致重复计算
     * 正确做法：将连续的 0 看作一个块
   
   - ❌ 尝试模拟实际的移动过程：
     * 模拟会导致 O(n²) 甚至更高的复杂度
     * 正确做法：直接计算每个 1 需要跨越的 0 块数量
   
   - ❌ 误解操作次数的含义：
     * 不是移动的步数，而是操作的次数
     * 每次操作可以将 1 移动多个位置（直到遇到另一个 1）
   
   - ❌ 边界情况处理：
     * 全是 1：应该返回 0
     * 全是 0：应该返回 0
     * 末尾是 0：需要正确累加

9. 扩展思考：

   【类似问题】
   - LeetCode 283. 移动零（将 0 移到末尾）
   - LeetCode 75. 颜色分类（荷兰国旗问题）
   - 涉及元素移动和计数的问题

   【变种问题】
   - 如果要求最少操作次数？
     * 本题的答案就是最少操作次数（贪心策略）
   
   - 如果允许向左移动？
     * 可以选择向左或向右，策略会更复杂
     * 需要考虑最优的移动方向
   
   - 如果要将 1 移到开头？
     * 从右到左遍历，逻辑类似但方向相反

   【优化方向】
   - 当前算法已经是 O(n) 时间和 O(1) 空间，无法进一步优化时间复杂度
   - 可以考虑并行处理（但对单次调用意义不大）

   【数学规律】
   - 总操作次数 = ∑(每个 0 块左侧的 1 的数量)
   - 等价于：每个 1 需要跨越的 0 块数量之和
   - 这个规律可以推广到其他类似的移动问题

   【实际应用】
   - 数据排序和重组
   - 内存碎片整理
   - 任务调度优化
*/
