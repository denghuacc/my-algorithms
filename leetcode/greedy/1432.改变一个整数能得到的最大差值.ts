/*
 * @lc app=leetcode.cn id=1432 lang=typescript
 *
 * [1432] 改变一个整数能得到的最大差值
 *
 * https://leetcode.cn/problems/max-difference-you-can-get-from-changing-an-integer/description/
 *
 * algorithms
 * Medium (40.38%)
 * Likes:    37
 * Dislikes: 0
 * Total Accepted:    13.3K
 * Total Submissions: 30.7K
 * Testcase Example:  '555'
 *
 * 给你一个整数 num 。你可以对它进行以下步骤共计 两次：
 *
 *
 * 选择一个数字 x (0 <= x <= 9).
 * 选择另一个数字 y (0 <= y <= 9) 。数字 y 可以等于 x 。
 * 将 num 中所有出现 x 的数位都用 y 替换。
 *
 *
 * 令两次对 num 的操作得到的结果分别为 a 和 b 。
 *
 * 请你返回 a 和 b 的 最大差值 。
 *
 * 注意，新的整数（a 或 b）必须不能 含有前导 0，并且 非 0。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：num = 555
 * 输出：888
 * 解释：第一次选择 x = 5 且 y = 9 ，并把得到的新数字保存在 a 中。
 * 第二次选择 x = 5 且 y = 1 ，并把得到的新数字保存在 b 中。
 * 现在，我们有 a = 999 和 b = 111 ，最大差值为 888
 *
 *
 * 示例 2：
 *
 *
 * 输入：num = 9
 * 输出：8
 * 解释：第一次选择 x = 9 且 y = 9 ，并把得到的新数字保存在 a 中。
 * 第二次选择 x = 9 且 y = 1 ，并把得到的新数字保存在 b 中。
 * 现在，我们有 a = 9 和 b = 1 ，最大差值为 8
 *
 *
 * 示例 3：
 *
 *
 * 输入：num = 123456
 * 输出：820000
 *
 *
 * 示例 4：
 *
 *
 * 输入：num = 10000
 * 输出：80000
 *
 *
 * 示例 5：
 *
 *
 * 输入：num = 9288
 * 输出：8700
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= num <= 10^8
 *
 *
 */

// @lc code=start
function maxDiff(num: number): number {
  // 将数字转换为字符串便于操作
  let s = String(num); // s用于构造最大数
  let t = s; // t用于构造最小数
  const n = s.length;

  // 构造最大数：找到第一个不是9的数字，全部替换为9
  let p1 = 0;
  while (p1 < n && s[p1] === "9") {
    p1++;
  }
  // 如果存在不是9的数字，将其全部替换为9
  if (p1 < n) {
    s = s.replaceAll(s[p1], "9");
  }

  // 构造最小数：需要考虑不能有前导0的限制
  let p2 = 0;
  while (p2 < n) {
    if (p2 === 0) {
      // 第一位：如果不是1，就替换为1（不能替换为0避免前导0）
      if (t[p2] !== "1") {
        t = t.replaceAll(t[p2], "1");
        break;
      }
    } else {
      // 其他位：找到第一个不是0且不等于第一位的数字，替换为0
      // 不能替换首位相同的数字，否则会产生前导0
      if (t[p2] !== "0" && t[p2] !== t[0]) {
        t = t.replaceAll(t[p2], "0");
        break;
      }
    }
    p2++;
  }

  // 返回最大数与最小数的差值
  return Number(s) - Number(t);
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 通过两次替换操作，构造一个最大数和一个最小数
   - 每次操作可以选择一个数字x，将所有x替换为另一个数字y
   - 目标是最大化两个结果数的差值

2. 算法分析：
   - 时间复杂度：O(n)，其中n是数字的位数
   - 空间复杂度：O(n)，用于字符串操作
   - 算法类型：贪心算法

3. 实现要点：
   
   **构造最大数的策略：**
   - 从左到右找到第一个不是9的数字
   - 将该数字的所有出现替换为9
   - 这样能最大化高位的值，从而得到最大的数
   
   **构造最小数的策略：**
   - 需要避免前导0的问题
   - 第一位：如果不是1，替换为1（不能替换为0）
   - 其他位：找到第一个不是0且不等于首位的数字，替换为0
   - 不能替换首位相同的数字，否则首位变0会产生前导0
   
   **边界情况处理：**
   - 所有位都是9的情况：最大数保持不变
   - 首位是1且其他位都是0或1的情况：最小数可能无法进一步减小

4. 优化思路：
   - 使用字符串的replaceAll方法一次性替换所有目标字符
   - 通过两个指针分别处理最大数和最小数的构造
   - 提前break避免不必要的遍历

5. 关键示例分析：
   - num = 555: 最大数999(5→9)，最小数111(5→1)，差值888
   - num = 9288: 最大数9988(2→9)，最小数1288(9→1)，差值8700
   - num = 10000: 最大数90000(1→9)，最小数10000(无法减小)，差值80000
*/
