/*
 * @lc app=leetcode.cn id=2616 lang=typescript
 *
 * [2616] 最小化数对的最大差值
 *
 * https://leetcode.cn/problems/minimize-the-maximum-difference-of-pairs/description/
 *
 * algorithms
 * Medium (44.34%)
 * Likes:    65
 * Dislikes: 0
 * Total Accepted:    10.1K
 * Total Submissions: 20.7K
 * Testcase Example:  '[10,1,2,7,1,3]\n2'
 *
 * 给你一个下标从 0 开始的整数数组 nums 和一个整数 p 。请你从 nums 中找到 p 个下标对，每个下标对对应数值取差值，你需要使得这 p
 * 个差值的 最大值 最小。同时，你需要确保每个下标在这 p 个下标对中最多出现一次。
 *
 * 对于一个下标对 i 和 j ，这一对的差值为 |nums[i] - nums[j]| ，其中 |x| 表示 x 的 绝对值 。
 *
 * 请你返回 p 个下标对对应数值 最大差值 的 最小值 。
 *
 * 示例 1：
 * 输入：nums = [10,1,2,7,1,3], p = 2
 * 输出：1
 * 解释：第一个下标对选择 1 和 4 ，第二个下标对选择 2 和 5 。
 * 最大差值为 max(|nums[1] - nums[4]|, |nums[2] - nums[5]|) = max(0, 1) = 1 。所以我们返回 1 。
 *
 * 示例 2：
 * 输入：nums = [4,2,1,2], p = 1
 * 输出：0
 * 解释：选择下标 1 和 3 构成下标对。差值为 |2 - 2| = 0 ，这是最大差值的最小值。
 *
 * 提示：
 * 1 <= nums.length <= 10^5
 * 0 <= nums[i] <= 10^9
 * 0 <= p <= (nums.length)/2
 */

// @lc code=start
function minimizeMax(nums: number[], p: number): number {
  // 对数组进行排序，使得相邻元素的差值最小
  nums.sort((a, b) => a - b);

  // 二分查找的左右边界
  // 最小可能的差值是0，最大可能的差值是数组最大值和最小值的差
  let left = 0;
  let right = nums[nums.length - 1] - nums[0];

  // 二分查找
  while (left < right) {
    const mid = left + Math.floor((right - left) / 2);
    if (check(mid)) {
      // 如果当前差值可行，尝试更小的差值
      right = mid;
    } else {
      // 如果当前差值不可行，尝试更大的差值
      left = mid + 1;
    }
  }
  return left;

  /**
   * 检查是否能在最大差值为mid的情况下找到p对满足条件的数对
   * @param mid 当前尝试的最大差值
   * @returns 是否能够找到p对满足条件的数对
   */
  function check(mid: number): boolean {
    let cnt = 0; // 记录找到的满足条件的数对数量
    for (let i = 0; i < nums.length - 1; ) {
      // 如果相邻两个数的差值小于等于mid，就选择这对数
      if (nums[i + 1] - nums[i] <= mid) {
        cnt++;
        i += 2; // 跳过已使用的数
      } else {
        i++; // 当前数无法配对，尝试下一个数
      }
    }
    return cnt >= p; // 判断是否找到了足够的数对
  }
}

// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 核心问题：从数组中选择p个不重叠的数对，使得这p个数对中最大差值最小化
   - 关键特点：每个元素最多只能在一个数对中出现，需要最小化最大差值
   - 目标：优化最大差值这个指标，使其达到最小值

2. 算法分析：
   - 时间复杂度：O(n log n + n log(max-min))，排序O(n log n)，二分查找O(log(max-min))，每次检查O(n)
   - 空间复杂度：O(1)，只使用常数额外空间
   - 算法类型：二分查找 + 贪心算法

3. 实现要点：

   3.1 数据预处理：
   - 对数组进行排序，确保相邻元素的差值是可能的最小差值
   - 排序后，如果两个元素能够配对，优先选择相邻的元素可以得到更小的差值

   3.2 二分查找边界设置：
   - 左边界(left = 0)：理论上最小的差值是0（相同元素配对）
   - 右边界(right = max - min)：理论上最大的差值是数组最大值和最小值的差

   3.3 二分查找核心逻辑：
   - 对于每个中间值mid，检查是否能够找到p个数对，使得每个数对的差值都不超过mid
   - 如果可以找到，说明答案可能更小，在左半部分继续搜索
   - 如果不能找到，说明mid太小，在右半部分继续搜索

   3.4 贪心检查策略：
   - 从左到右遍历排序后的数组
   - 如果当前元素和下一个元素的差值 ≤ mid，就选择这一对
   - 选择后跳过这两个元素（避免重复使用）
   - 如果差值 > mid，则跳过当前元素，尝试下一个元素

   3.5 边界情况处理：
   - p = 0：直接返回0
   - 数组长度 < 2p：无法找到p个不重叠的数对
   - 所有元素相同：差值为0

4. 算法正确性证明：

   4.1 贪心策略的正确性：
   - 在给定的最大差值限制下，优先选择相邻且满足条件的元素对是最优的
   - 因为数组已排序，跳过一个较小的满足条件的差值去选择更大的差值没有意义
   - 这种贪心策略能够找到最多的满足条件的数对

   4.2 二分查找的正确性：
   - 单调性：如果差值x可行，那么所有大于x的差值都可行
   - 二分查找能够找到最小的可行差值

5. 示例分析：

   示例1：nums = [10,1,2,7,1,3], p = 2
   
   步骤1：排序后 nums = [1,1,2,3,7,10]
   步骤2：二分查找范围 [0, 9]
   
   检查mid = 4：
   - i=0: nums[1]-nums[0] = 0 ≤ 4，选择(1,1)，cnt=1，i=2
   - i=2: nums[3]-nums[2] = 1 ≤ 4，选择(2,3)，cnt=2，i=4
   - cnt=2 ≥ p=2，返回true
   
   检查mid = 1：
   - i=0: nums[1]-nums[0] = 0 ≤ 1，选择(1,1)，cnt=1，i=2  
   - i=2: nums[3]-nums[2] = 1 ≤ 1，选择(2,3)，cnt=2，i=4
   - cnt=2 ≥ p=2，返回true
   
   最终答案：1

6. 优化思路：

   6.1 性能优化：
   - 排序是必需的，无法避免O(n log n)的时间复杂度
   - 二分查找的次数取决于数值范围，对于大数值可以考虑离散化
   - 检查函数已经是O(n)的最优实现

   6.2 代码优化：
   - 可以提前处理p=0的特殊情况
   - 可以在排序后检查是否有足够的元素对

   6.3 空间优化：
   - 当前实现已经是O(1)空间复杂度，无需进一步优化

7. 类似问题：
   - LeetCode 875. 爱吃香蕉的珂珂（二分查找最小值）
   - LeetCode 1011. 在D天内送达包裹的能力（二分查找最小值）
   - LeetCode 410. 分割数组的最大值（二分查找 + 贪心）

8. 常见错误：
   - 忘记排序：直接在原数组上进行贪心选择会得到错误结果
   - 贪心策略错误：选择了满足条件的数对后忘记跳过已使用的元素
   - 二分查找边界错误：右边界设置不当可能导致答案遗漏
   - 检查函数逻辑错误：没有正确实现贪心策略来计算最多可选择的数对数量
*/

export {};
