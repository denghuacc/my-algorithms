/*
 * @lc app=leetcode.com id=2141 lang=typescript
 *
 * [2141] 同时运行 N 台电脑的最长时间
 *
 * https://leetcode.cn/problems/maximum-running-time-of-n-computers/description/
 *
 * algorithms
 * Hard (51.87%)
 * Likes:    2139
 * Dislikes: 61
 * Total Accepted:    78.6K
 * Total Submissions: 151.7K
 * Testcase Example:  '2\n[3,3,3]'
 *
 * 你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组
 * batteries，其中第 i 块电池可以让一台电脑运行 batteries[i] 分钟。
 * 你希望使用这些电池让所有电脑同时运行。
 *
 * 最初，每台电脑最多安装一块电池。之后任意整数时刻，你可以从某台
 * 电脑取下电池，再装上另一块。更换的电池可以是新电池，也可以来自
 * 其他电脑。假设更换过程不耗时。
 *
 * 注意：电池不能充电。
 *
 * 返回让 n 台电脑同时运行的 最长 分钟数。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：n = 2, batteries = [3,3,3]
 * 输出：4
 * 解释：
 * - 将电池 0 装入第一台电脑、电池 1 装入第二台电脑。
 * - 2 分钟后，从第二台电脑取下电池 1，装上电池 2。
 *   此时电池 1 还能用 1 分钟。
 * - 第 3 分钟末，电池 0 用尽，从第一台电脑取下，装上电池 1。
 * - 第 4 分钟末，电池 1 也用尽，第一台电脑停止运行。
 * 所以最多能同时运行 4 分钟。
 *
 *
 * 示例 2：
 *
 *
 * 输入：n = 2, batteries = [1,1,1,1]
 * 输出：2
 * 解释：
 * - 初始将电池 0 装入第一台电脑、电池 2 装入第二台电脑。
 * - 1 分钟后电池 0 和电池 2 用尽，取下并分别装上电池 1 与电池 3。
 * - 又过 1 分钟电池 1 和电池 3 用尽，两台电脑都停止运行。
 * 最多同时运行 2 分钟。
 *
 *
 * 提示：
 *
 *
 * 1 <= n <= batteries.length <= 10^5
 * 1 <= batteries[i] <= 10^9
 *
 *
 */

// @lc code=start
/**
 * 二分答案求所有电脑能同时运行的最长分钟数。
 *
 * @param n - 电脑数量
 * @param batteries - 各电池可供的分钟数
 * @returns 能让所有电脑同时运行的最大分钟数
 */
function maxRunTime(n: number, batteries: number[]): number {
  const sum = batteries.reduce((acc, cur) => acc + cur, 0); // 总能量作为上界
  let left = 0; // 最短可行时间
  let right = Math.floor(sum / n); // 均分能量后的理论上限
  let result = 0;
  while (left <= right) {
    const mid = Math.floor((left + right) / 2); // 当前尝试的运行时间
    // 统计每块电池可为 mid 分钟贡献的有效时长（最多只能贡献 mid）
    let total = 0;
    for (const battery of batteries) {
      total += Math.min(battery, mid);
    }
    // 如果总贡献能覆盖 n 台电脑各 mid 分钟，则 mid 可行，尝试更长时间
    if (total >= mid * n) {
      result = mid;
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return result;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 在可任意调度电池的前提下，求 n 台电脑能同时运行的最长时间。
   - 关键约束：电池不能充电，总能量守恒，但可随时更换电池。

2. 算法分析：
   - 时间复杂度：O(m log T)，m 为电池数，T 为答案上界，因二分次数为 log T。
   - 空间复杂度：O(1)，只用常数额外变量。
   - 算法类型：二分答案 + 可行性检查。

3. 解题思路：
   - 核心思想：答案满足单调性——若能运行 t 分钟，则一定能运行不超过 t
     分钟的时间，故可二分最长可行时间。
   - 推导过程：总可用能量为 sum，若均匀分配，每台电脑最多运行 sum / n
     分钟，作为二分上界。
   - 主要步骤概述：
     1) 计算总能量并设置二分范围 [0, sum / n]。
     2) 对中值 mid，统计所有电池能为 mid 分钟贡献的时间（每块最多 mid）。
     3) 若总贡献不少于 mid * n，mid 可行，左移下界；否则缩小上界。

4. 实现要点：
   - 关键数据结构选择：仅需遍历电池求和，不需额外结构。
   - 核心算法步骤：二分 + 可行性判断，判断公式为
     ∑min(battery[i], mid) >= mid * n。
   - 边界情况处理：当 n == batteries.length 或存在超大电池时，二分依然通过
     上界 sum / n 保证安全，不会溢出。

5. 算法优势（可选）
   - 二分利用单调性，避免复杂调度；实现简单且复杂度可控。

6. 核心算法步骤（可选）
   - 设置上下界 -> 取 mid -> 计算贡献 -> 根据可行性调整边界。

7. 示例分析
   - 示例 1：n=2，batteries=[3,3,3]，sum=9，上界 4。二分验证 4 可行，
     5 不可行，答案为 4。
   - 示例 2：n=2，batteries=[1,1,1,1]，sum=4，上界 2。检查 2 可行，答案 2。
   - 边界：单台电脑时答案为所有电池总和；超大电池贡献由 min 限制，
     真实贡献最多为 mid，判定依旧正确。

8. 常见错误
   - 忽略上界应为 sum / n 而非最大电池容量，可能导致不必要的二分范围。
   - 可行性判断写成 ∑battery[i] >= mid * n，未截断为 min，导致误判。
   - 二分循环条件和更新不当（如遗漏 result），可能错过最终可行值。

10. 扩展思考
   - 优化思路：排序后可在可行性检查时提前剪枝，但常数收益有限。
   - 类似问题：二分答案 + 可行性验证的场景，如分配工作、切割木板。
   - 实际应用：总资源可自由调度、求最大全局均摊值的场景皆可套用。
*/
