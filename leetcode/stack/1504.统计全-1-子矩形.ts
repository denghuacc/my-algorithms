/*
 * @lc app=leetcode.cn id=1504 lang=typescript
 *
 * [1504] 统计全 1 子矩形
 *
 * https://leetcode.cn/problems/count-submatrices-with-all-ones/description/
 *
 * algorithms
 * Medium (65.03%)
 * Likes:    228
 * Dislikes: 0
 * Total Accepted:    19.3K
 * Total Submissions: 29.1K
 * Testcase Example:  '[[1,0,1],[1,1,0],[1,1,0]]'
 *
 * 给你一个 m x n 的二进制矩阵 mat ，请你返回有多少个 子矩形 的元素全部都是 1 。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 *
 * 输入：mat = [[1,0,1],[1,1,0],[1,1,0]]
 * 输出：13
 * 解释：
 * 有 6 个 1x1 的矩形。
 * 有 2 个 1x2 的矩形。
 * 有 3 个 2x1 的矩形。
 * 有 1 个 2x2 的矩形。
 * 有 1 个 3x1 的矩形。
 * 矩形数目总共 = 6 + 2 + 3 + 1 + 1 = 13 。
 *
 *
 * 示例 2：
 *
 *
 *
 *
 * 输入：mat = [[0,1,1,0],[0,1,1,1],[1,1,1,0]]
 * 输出：24
 * 解释：
 * 有 8 个 1x1 的子矩形。
 * 有 5 个 1x2 的子矩形。
 * 有 2 个 1x3 的子矩形。
 * 有 4 个 2x1 的子矩形。
 * 有 2 个 2x2 的子矩形。
 * 有 2 个 3x1 的子矩形。
 * 有 1 个 3x2 的子矩形。
 * 矩形数目总共 = 8 + 5 + 2 + 4 + 2 + 2 + 1 = 24 。
 *
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= m, n <= 150
 * mat[i][j] 仅包含 0 或 1
 *
 *
 */

// @lc code=start
/**
 * 统计矩阵中所有元素为1的子矩形数量
 * @param mat 输入的二进制矩阵
 * @returns 所有全1子矩形的数量
 */
function numSubmat(mat: number[][]): number {
  const n = mat[0].length;
  let res = 0; // 结果计数器
  // heights[i]表示第i列以当前行为底的连续1的高度
  const heights = new Array(n).fill(0);
  // 遍历每一行，动态维护每一列的高度
  for (const row of mat) {
    for (let i = 0; i < n; i++) {
      // 如果当前元素为0，高度归零，否则高度加1
      heights[i] = row[i] === 0 ? 0 : heights[i] + 1;
    }
    // 单调栈优化，统计以当前行为底的所有全1子矩形数量
    // stack元素：[index, count, height]
    const stack: number[][] = [[-1, 0, -1]];
    for (let i = 0; i < n; i++) {
      const h = heights[i];
      // 保持栈中高度递增，遇到更小高度则弹出
      while (stack.length > 1 && stack[stack.length - 1][2] >= h) {
        stack.pop();
      }
      const [j, prev] = stack[stack.length - 1];
      // 以当前列为右边界的所有子矩形数量
      const cur = prev + h * (i - j);
      stack.push([i, cur, h]);
      res += cur;
    }
  }
  return res;
}
// @lc code=end

/*
解题思路：

1. 题目理解
---------------------
- 问题本质：统计矩阵中所有元素为1的子矩形数量。
- 关键特点：子矩形必须全部为1，可以是任意大小。

2. 解题思路
---------------------
核心思想：
- 对于每一行，维护每一列的“高度”，即以当前行为底的连续1的数量。
- 对每一行的高度数组，统计以该行为底的所有全1子矩形数量。
- 用单调栈优化统计过程，避免重复枚举。

算法步骤：
1. 初始化heights数组，表示每一列的高度。
2. 遍历每一行：
   - 更新heights数组：如果当前元素为1，高度加1，否则归零。
   - 对heights数组用单调栈统计所有以当前行为底的全1子矩形数量。
   - 累加到总结果。

单调栈统计过程：
- 栈中保存递增高度的列索引和以该列为右边界的子矩形数量。
- 每遇到更小高度时弹出栈顶，保证每个子矩形都被正确计数。
- cur = prev + h * (i - j)，表示以当前列为右边界的所有子矩形数量。

3. 复杂度分析
---------------------
- 时间复杂度：O(m*n)，m为行数，n为列数。每个元素最多进出栈一次。
- 空间复杂度：O(n)，用于heights和栈。

4. 边界情况
---------------------
- 全为0：结果为0。
- 全为1：结果为所有可能的子矩形数量。
- 只有一行或一列：退化为一维情况。

5. 优化思路
---------------------
- 单调栈优化统计过程，避免暴力枚举所有子矩形。
- 空间可以原地复用输入矩阵作为heights。
- 该方法也可用于统计全1子正方形（需额外判断）。
*/
