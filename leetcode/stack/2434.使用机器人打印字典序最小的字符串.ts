/*
 * @lc app=leetcode.cn id=2434 lang=typescript
 *
 * [2434] 使用机器人打印字典序最小的字符串
 *
 * https://leetcode.cn/problems/using-a-robot-to-print-the-lexicographically-smallest-string/description/
 *
 * algorithms
 * Medium (45.64%)
 * Likes:    94
 * Dislikes: 0
 * Total Accepted:    19K
 * Total Submissions: 34.3K
 * Testcase Example:  '"zza"'
 *
 * 给你一个字符串 s 和一个机器人，机器人当前有一个空字符串 t 。执行以下操作之一，直到 s 和 t 都变成空字符串：
 *
 *
 * 删除字符串 s 的 第一个 字符，并将该字符给机器人。机器人把这个字符添加到 t 的尾部。
 * 删除字符串 t 的 最后一个 字符，并将该字符给机器人。机器人将该字符写到纸上。
 *
 *
 * 请你返回纸上能写出的字典序最小的字符串。
 *
 *
 *
 * 示例 1：
 *
 * 输入：s = "zza"
 * 输出："azz"
 * 解释：用 p 表示写出来的字符串。
 * 一开始，p="" ，s="zza" ，t="" 。
 * 执行第一个操作三次，得到 p="" ，s="" ，t="zza" 。
 * 执行第二个操作三次，得到 p="azz" ，s="" ，t="" 。
 *
 *
 * 示例 2：
 *
 * 输入：s = "bac"
 * 输出："abc"
 * 解释：用 p 表示写出来的字符串。
 * 执行第一个操作两次，得到 p="" ，s="c" ，t="ba" 。
 * 执行第二个操作两次，得到 p="ab" ，s="c" ，t="" 。
 * 执行第一个操作，得到 p="ab" ，s="" ，t="c" 。
 * 执行第二个操作，得到 p="abc" ，s="" ，t="" 。
 *
 *
 * 示例 3：
 *
 * 输入：s = "bdda"
 * 输出："addb"
 * 解释：用 p 表示写出来的字符串。
 * 一开始，p="" ，s="bdda" ，t="" 。
 * 执行第一个操作四次，得到 p="" ，s="" ，t="bdda" 。
 * 执行第二个操作四次，得到 p="addb" ，s="" ，t="" 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= s.length <= 10^5
 * s 只包含小写英文字母。
 *
 *
 */

// @lc code=start
function robotWithString(s: string): string {
  // 统计每个字符的出现次数，用于后续判断剩余字符的最小值
  const cnt = new Array(26).fill(0);
  for (const c of s) {
    cnt[getCharCode(c)]++;
  }

  const res = []; // 存储最终结果
  const stk = []; // 模拟字符串 t 的栈结构
  let minChar = "a"; // 当前剩余字符中的最小字符

  for (const c of s) {
    // 1. 将当前字符压入栈（相当于添加到 t 的尾部）
    stk.push(c);
    // 2. 减少该字符的计数
    cnt[getCharCode(c)]--;

    // 3. 更新剩余字符中的最小字符
    // 如果当前 minChar 的计数为 0，说明后面没有更小的字符了，需要向后寻找
    while (minChar < "z" && cnt[getCharCode(minChar)] === 0) {
      minChar = String.fromCharCode(minChar.charCodeAt(0) + 1);
    }

    // 4. 贪心策略：如果栈顶字符 <= 剩余字符的最小值，就可以弹出
    // 这样能保证输出的字符串字典序最小
    while (stk.length > 0 && stk[stk.length - 1] <= minChar) {
      res.push(stk.pop());
    }
  }

  return res.join("");

  // 辅助函数：获取字符对应的数组索引
  function getCharCode(c: string): number {
    return c.charCodeAt(0) - "a".charCodeAt(0);
  }
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 机器人有两种操作：从字符串 s 头部取字符放入栈 t，或从栈 t 顶部取字符写到纸上
   - 目标是通过合理安排操作顺序，使得最终写到纸上的字符串字典序最小
   - 关键在于决定何时从栈中弹出字符，何时继续压入字符

2. 算法分析：
   - 时间复杂度：O(n)，其中 n 是字符串长度，每个字符最多被处理两次（压栈和出栈）
   - 空间复杂度：O(n)，需要栈和结果数组存储字符
   - 算法类型：贪心算法 + 栈

3. 实现要点：
   
   核心思想：贪心策略
   - 我们希望尽早输出较小的字符，但不能破坏后续字符的相对顺序
   - 关键判断：当前栈顶字符是否可以安全弹出
   
   判断依据：
   - 维护一个 minChar，表示当前剩余字符（尚未处理的字符）中的最小字符
   - 如果栈顶字符 <= minChar，说明弹出栈顶字符不会错失更优解，可以安全弹出
   - 因为即使后面还有更小的字符，当前栈顶字符也不会比它更大
   
   数据结构选择：
   - cnt[26]：字符计数数组，O(1) 时间统计和更新字符频次
   - stk：模拟字符串 t 的栈结构
   - res：存储最终输出结果
   
   算法步骤：
   1. 预处理：统计所有字符的出现次数
   2. 遍历字符串 s：
      - 将当前字符压入栈
      - 更新字符计数
      - 更新剩余字符的最小值
      - 贪心弹出：当栈顶 <= 剩余最小字符时，持续弹出
   
   边界情况处理：
   - 空字符串：直接返回空字符串
   - 单字符：直接返回该字符
   - 已排序字符串：会直接全部压栈再全部弹出

4. 优化思路：
   
   时间优化：
   - 使用字符计数数组避免重复遍历
   - minChar 的更新采用惰性策略，只在需要时向前推进
   
   空间优化：
   - 可以原地修改输入字符串（如果允许），但会影响代码可读性
   - 当前实现已经是近似最优的空间使用
   
   核心技巧：
   - 贪心 + 栈的经典组合
   - 通过预处理获得全局信息（剩余字符统计）
   - 惰性更新最小字符，避免不必要的计算

5. 算法正确性证明：
   
   关键不变式：
   - 当我们弹出栈顶字符 c 时，c <= minChar
   - 这意味着在后续的所有字符中，不存在比 c 更小的字符
   - 因此，现在输出 c 是最优的选择
   
   最优性保证：
   - 我们总是尽可能早地输出较小的字符
   - 同时保证不会错过后续更优的输出机会
   - 贪心选择的局部最优性保证了全局最优性

6. 示例分析：
   
   输入 "bac"：
   - 处理 'b'：栈=[b], minChar='a'（剩余 'ac' 最小是 'a'）
   - 处理 'a'：栈=[b,a], minChar='c'（剩余 'c' 最小是 'c'）
     - 'a' <= 'c'，弹出 'a' → 输出 "a"
     - 'b' <= 'c'，弹出 'b' → 输出 "ab"  
   - 处理 'c'：栈=[c], minChar='z'（无剩余）
     - 'c' <= 'z'，弹出 'c' → 输出 "abc"
   
   输出 "abc"，符合预期

7. 类似问题：
   - LeetCode 402: 移掉K位数字
   - LeetCode 316: 去除重复字母
   - LeetCode 1081: 不同字符的最小子序列
   - 都是贪心 + 栈的经典应用
*/
