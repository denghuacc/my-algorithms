/*
 * @lc app=leetcode.cn id=3170 lang=typescript
 *
 * [3170] 删除星号以后字典序最小的字符串
 *
 * https://leetcode.cn/problems/lexicographically-minimum-string-after-removing-stars/description/
 *
 * algorithms
 * Medium (40.56%)
 * Likes:    37
 * Dislikes: 0
 * Total Accepted:    12.6K
 * Total Submissions: 25.9K
 * Testcase Example:  '"aaba*"'
 *
 * 给你一个字符串 s 。它可能包含任意数量的 '*' 字符。你的任务是删除所有的 '*' 字符。
 *
 * 当字符串还存在至少一个 '*' 字符时，你可以执行以下操作：
 *
 *
 * 删除最左边的 '*' 字符，同时删除该星号字符左边一个字典序 最小 的字符。如果有多个字典序最小的字符，你可以删除它们中的任意一个。
 *
 *
 * 请你返回删除所有 '*' 字符以后，剩余字符连接而成的 字典序最小 的字符串。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：s = "aaba*"
 *
 * 输出："aab"
 *
 * 解释：
 *
 * 删除 '*' 号和它左边的其中一个 'a' 字符。如果我们选择删除 s[3] ，s 字典序最小。
 *
 *
 * 示例 2：
 *
 *
 * 输入：s = "abc"
 *
 * 输出："abc"
 *
 * 解释：
 *
 * 字符串中没有 '*' 字符。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= s.length <= 10^5
 * s 只含有小写英文字母和 '*' 字符。
 * 输入保证操作可以删除所有的 '*' 字符。
 *
 *
 */

// @lc code=start
function clearStars(s: string): string {
  // 创建26个数组，分别存储每个字母出现的位置索引
  // cnt[0]存储'a'的位置，cnt[1]存储'b'的位置，以此类推
  const cnt: number[][] = Array.from({ length: 26 }, () => []);

  // 将字符串转换为数组，便于修改字符
  const arr = s.split("");
  const n = arr.length;

  // 遍历每个字符
  for (let i = 0; i < n; i++) {
    if (arr[i] !== "*") {
      // 如果不是星号，将当前位置记录到对应字母的数组中
      cnt[getCharCode(arr[i])].push(i);
    } else {
      // 如果是星号，需要删除左边字典序最小的字符
      // 从'a'开始遍历，找到第一个存在的字母
      for (let j = 0; j < 26; j++) {
        if (cnt[j].length > 0) {
          // 删除该字母最右边的位置（最近的位置）
          // 将对应位置标记为"*"表示删除
          arr[cnt[j].pop()!] = "*";
          break;
        }
      }
    }
  }

  // 过滤掉所有"*"字符，返回剩余字符组成的字符串
  return arr.filter((c) => c !== "*").join("");

  // 辅助函数：将字符转换为对应的数组索引
  function getCharCode(c: string): number {
    return c.charCodeAt(0) - "a".charCodeAt(0);
  }
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 需要删除所有星号，每个星号删除时要带走左边字典序最小的字符
   - 最终目标是使剩余字符串的字典序最小
   - 贪心策略：每次都删除当前可删除字符中字典序最小的

2. 算法分析：
   - 时间复杂度：O(n)，每个字符最多被处理两次（一次添加，一次删除）
   - 空间复杂度：O(n)，需要额外数组存储字符位置和字符数组
   - 算法类型：贪心算法 + 数据结构优化

3. 实现要点：
   - 核心数据结构：26个数组分别存储每个字母的位置
   - 关键策略：遇到星号时，从'a'开始查找第一个可删除的字符
   - 删除策略：删除同一字母的最右位置（栈的特性，后进先出）
   - 标记删除：将要删除的字符位置标记为"*"，最后统一过滤

4. 算法步骤：
   - 第一步：遍历字符串，将非星号字符的位置记录到对应的字母数组中
   - 第二步：遇到星号时，从字典序最小的字母开始查找，删除最近的位置
   - 第三步：将所有标记为删除的位置过滤掉，返回最终结果

5. 优化思路：
   - 使用数组索引代替字符比较，提高查找效率
   - 利用栈的后进先出特性，确保删除最近的字符
   - 一次遍历完成所有操作，避免多次扫描

6. 边界情况：
   - 字符串中没有星号：直接返回原字符串
   - 所有字符都被删除：返回空字符串
   - 星号在字符串开头：按规则正常处理，不会出错

7. 关键洞察：
   - 贪心选择：总是删除字典序最小的可用字符
   - 位置选择：在同样字典序的字符中，选择最右边的（最近的）
   - 这样的选择保证了最终结果的字典序最小
*/

export {};
