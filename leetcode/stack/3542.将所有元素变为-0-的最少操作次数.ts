/*
 * @lc app=leetcode.cn id=3542 lang=typescript
 *
 * [3542] 将所有元素变为 0 的最少操作次数
 *
 * https://leetcode.cn/problems/minimum-operations-to-convert-all-elements-to-zero/description/
 *
 * algorithms
 * Medium (40.89%)
 * Likes:    41
 * Dislikes: 0
 * Total Accepted:    6.2K
 * Total Submissions: 11.5K
 * Testcase Example:  '[0,2]'
 *
 * 给你一个大小为 n 的 非负 整数数组 nums 。你的任务是对该数组执行若干次（可能为 0 次）操作，使得 所有 元素都变为 0。
 *
 * 在一次操作中，你可以选择一个子数组 [i, j]（其中 0 <= i <= j < n），将该子数组中所有 最小的非负整数 的设为 0。
 *
 * 返回使整个数组变为 0 所需的最少操作次数。
 * 一个 子数组 是数组中的一段连续元素。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入: nums = [0,2]
 *
 * 输出: 1
 *
 * 解释:
 *
 *
 * 选择子数组 [1,1]（即 [2]），其中最小的非负整数是 2。将所有 2 设为 0，结果为 [0,0]。
 * 因此，所需的最少操作次数为 1。
 *
 *
 *
 * 示例 2：
 *
 *
 * 输入: nums = [3,1,2,1]
 *
 * 输出: 3
 *
 * 解释:
 *
 *
 * 选择子数组 [1,3]（即 [1,2,1]），最小非负整数是 1。将所有 1 设为 0，结果为 [3,0,2,0]。
 * 选择子数组 [2,2]（即 [2]），将 2 设为 0，结果为 [3,0,0,0]。
 * 选择子数组 [0,0]（即 [3]），将 3 设为 0，结果为 [0,0,0,0]。
 * 因此，最少操作次数为 3。
 *
 *
 *
 * 示例 3：
 *
 *
 * 输入: nums = [1,2,1,2,1,2]
 *
 * 输出: 4
 *
 * 解释:
 *
 *
 * 选择子数组 [0,5]（即 [1,2,1,2,1,2]），最小非负整数是 1。将所有 1 设为 0，结果为 [0,2,0,2,0,2]。
 * 选择子数组 [1,1]（即 [2]），将 2 设为 0，结果为 [0,0,0,2,0,2]。
 * 选择子数组 [3,3]（即 [2]），将 2 设为 0，结果为 [0,0,0,0,0,2]。
 * 选择子数组 [5,5]（即 [2]），将 2 设为 0，结果为 [0,0,0,0,0,0]。
 * 因此，最少操作次数为 4。
 *
 *
 *
 *
 *
 * 提示:
 *
 *
 * 1 <= n == nums.length <= 10^5
 * 0 <= nums[i] <= 10^5
 *
 *
 */

// @lc code=start
/**
 * 计算将数组所有元素变为0所需的最少操作次数
 *
 * @param nums - 非负整数数组
 * @returns 最少操作次数
 *
 * 核心思路：
 * 使用单调栈维护当前未消除的不同数值
 * 每次遇到新数值时，判断是否需要新的操作
 */
function minOperations(nums: number[]): number {
  // cnt 记录总操作次数
  let cnt = 0;

  // stk 维护一个单调递增栈，保存当前还未完全消除的数值
  // 栈中的元素表示不同的"层级"，每层需要一次操作来消除
  const stk: number[] = [];

  for (const num of nums) {
    // 当栈顶元素大于当前数值时，说明之前的高层级已经被处理完
    // 需要弹出这些已经不再需要的层级
    while (stk.length && stk[stk.length - 1] > num) {
      stk.pop();
    }

    // 如果当前元素已经是0，无需处理，直接跳过
    if (num === 0) continue;

    // 如果栈为空 或者 当前数值大于栈顶，说明遇到了新的层级
    // 需要一次新的操作来处理这个层级
    if (stk.length === 0 || stk[stk.length - 1] < num) {
      stk.push(num);
      cnt++;
    }
    // 如果当前数值等于栈顶，说明可以在同一次操作中处理，无需额外操作
  }

  return cnt;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 每次操作可以选择一个子数组，将其中所有最小的非负整数变为0
   - 目标是用最少次数将整个数组全部变为0
   - 关键观察：我们需要找到最少需要多少"层级"的操作

2. 算法分析：
   - 时间复杂度：O(n) - 遍历数组一次，每个元素最多入栈出栈各一次
   - 空间复杂度：O(n) - 栈最多存储n个不同的数值
   - 算法类型：单调栈 + 贪心

3. 核心思路：

   a) 贪心策略：
      - 对于连续的相同数值，只需要一次操作就能全部消除
      - 对于递增序列，每个新高度都需要额外的操作
      - 对于递减序列，可以复用之前的操作

   b) 单调栈的作用：
      - 维护当前"活跃"的数值层级
      - 栈中保持递增顺序，表示从小到大的不同层级
      - 每个层级代表一次独立的操作

   c) 关键观察：
      - 当遇到比栈顶小的数时，说明高层级已结束，需要弹出
      - 当遇到比栈顶大的数时，说明需要新增一个层级（新操作）
      - 当遇到和栈顶相同的数时，可以合并到同一次操作中

4. 算法步骤：

   步骤1：初始化计数器cnt和单调栈stk
   步骤2：遍历数组中的每个元素
   步骤3：清理栈中大于当前元素的值（这些层级已结束）
   步骤4：如果当前元素为0，跳过（已经是目标值）
   步骤5：如果当前元素是新层级（栈空或大于栈顶），压栈并增加计数
   步骤6：返回总操作次数

5. 示例分析：

   示例1: nums = [0,2]
   - i=0, num=0: 跳过
   - i=1, num=2: 栈空，压入2，cnt=1
   - 结果：1次操作
   
   示例2: nums = [3,1,2,1]
   - i=0, num=3: 栈空，压入3，cnt=1，stk=[3]
   - i=1, num=1: 3>1弹出，栈空，压入1，cnt=2，stk=[1]
   - i=2, num=2: 2>1，压入2，cnt=3，stk=[1,2]
   - i=3, num=1: 2>1弹出，1==1不变，stk=[1]
   - 结果：3次操作
   
   示例3: nums = [1,2,1,2,1,2]
   - i=0, num=1: 栈空，压入1，cnt=1，stk=[1]
   - i=1, num=2: 2>1，压入2，cnt=2，stk=[1,2]
   - i=2, num=1: 2>1弹出，1==1不变，stk=[1]
   - i=3, num=2: 2>1，压入2，cnt=3，stk=[1,2]
   - i=4, num=1: 2>1弹出，1==1不变，stk=[1]
   - i=5, num=2: 2>1，压入2，cnt=4，stk=[1,2]
   - 结果：4次操作

6. 图解过程（以示例2为例）：

   初始: [3,1,2,1]
   
   第1次操作(消除最小值1): [3,0,2,0]
   第2次操作(消除最小值2): [3,0,0,0]
   第3次操作(消除最小值3): [0,0,0,0]
   
   栈的变化过程：
   遇到3: [] -> [3], cnt=1
   遇到1: [3] -> [] -> [1], cnt=2 (3被弹出，1是新层级)
   遇到2: [1] -> [1,2], cnt=3 (2比1大，新层级)
   遇到1: [1,2] -> [1], cnt=3 (2被弹出，1已存在)

7. 算法要点总结：

   核心技巧：
   - 使用单调栈维护递增的"层级"结构
   - 贪心思想：相邻相同值可以合并到一次操作
   - 栈的弹出操作表示层级的结束

   优化要点：
   - 跳过值为0的元素，减少不必要的判断
   - 使用单调栈避免重复计算，每个元素最多处理两次

   类似问题：
   - LeetCode 84. 柱状图中最大的矩形（单调栈）
   - LeetCode 739. 每日温度（单调栈）
   - LeetCode 42. 接雨水（单调栈变种）

8. 常见错误：

   错误1：每个非零元素都计数
   - 原因：没有理解相同值可以在同一次操作中处理
   - 避免：使用栈来去重

   错误2：没有处理递减序列
   - 原因：忽略了高层级结束后需要弹出栈
   - 避免：在压栈前先清理大于当前值的元素

   错误3：忘记跳过0元素
   - 原因：0本身就是目标值，不需要操作
   - 避免：在处理前先判断num === 0

9. 扩展思考：

   变种问题：
   - 如果每次操作可以选择任意值变为0，而不是最小值？
     答：仍然是统计不同的非零值个数
   
   - 如果要求返回具体的操作序列？
     答：需要记录每次操作时选择的子数组范围
   
   实际应用：
   - 资源分配问题（按层级分配）
   - 工序优化问题（不同工序的合并）
   - 数据压缩问题（相同值的合并）
*/
