/*
 * @lc app=leetcode.cn id=440 lang=typescript
 *
 * [440] 字典序的第K小数字
 *
 * https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order/description/
 *
 * algorithms
 * Hard (39.82%)
 * Likes:    317
 * Dislikes: 0
 * Total Accepted:    22.1K
 * Total Submissions: 55.6K
 * Testcase Example:  '13\n2'
 *
 * 给定整数 n 和 k，返回  [1, n] 中字典序第 k 小的数字。
 *
 *
 *
 * 示例 1:
 *
 *
 * 输入: n = 13, k = 2
 * 输出: 10
 * 解释: 字典序的排列是 [1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]，所以第二小的数字是 10。
 *
 *
 * 示例 2:
 *
 *
 * 输入: n = 1, k = 1
 * 输出: 1
 *
 *
 *
 *
 * 提示:
 *
 *
 * 1 <= k <= n <= 10^9
 *
 *
 */

// @lc code=start
function findKthNumber(n: number, k: number): number {
  let cur = 1; // 当前遍历到的数字，从1开始
  k--; // 减1是因为要找第k小，而我们从第1小开始计数

  while (k > 0) {
    // 计算以cur为根的子树中有多少个数字（在[1,n]范围内）
    const steps = getSteps(cur, n);

    if (steps <= k) {
      // 如果子树的节点数 <= k，说明第k小的数不在这个子树中
      // 跳过整个子树，移动到下一个兄弟节点
      k -= steps; // 减去跳过的节点数
      cur++; // 移动到下一个兄弟节点
    } else {
      // 如果子树的节点数 > k，说明第k小的数在这个子树中
      // 进入子树的下一层（添加一位数字）
      cur *= 10; // 相当于在字典序树中向下一层
      k--; // 已经确定了一位数字，k减1
    }
  }

  return cur;

  /**
   * 计算以cur为根的子树中有多少个数字在[1,n]范围内
   * 这是算法的核心函数，用于确定子树的大小
   */
  function getSteps(cur: number, n: number): number {
    let steps = 0;
    let first = cur; // 当前层的第一个数字
    let last = cur; // 当前层的最后一个数字

    // 逐层计算子树中的节点数
    while (first <= n) {
      // 当前层在[first, last]范围内且不超过n的数字个数
      steps += Math.min(last, n) - first + 1;

      // 移动到下一层
      first *= 10; // 下一层的第一个数字：cur0, cur00, cur000...
      last = last * 10 + 9; // 下一层的最后一个数字：cur9, cur99, cur999...
    }

    return steps;
  }
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 给定范围[1, n]内的所有数字，按字典序排列，求第k小的数字
   - 字典序：按照字符串比较的方式排序，如 "10" < "2"（因为 '1' < '2'）
   - 关键挑战：n可达10^9，无法直接枚举所有数字

2. 算法分析：
   - 时间复杂度：O(log²n)，每次循环要么k减小，要么cur增大，最多循环O(logn)次，getSteps函数也是O(logn)
   - 空间复杂度：O(1)，只使用常数额外空间
   - 算法类型：字典序树遍历 + 数学计算

3. 核心洞察：十进制字典序树

   数字的字典序实际上形成了一个十进制树结构：
   ```
                    1
          /   /   /   \   \   \
         10  11  12  ... 19
        /|\  /|\  /|\     /|\
      100 101 102 ... 190 191 192 ...
   ```
   
   树的特点：
   - 根节点：1, 2, 3, ..., 9
   - 每个节点的子节点：在末尾添加数字0-9
   - 字典序遍历：深度优先，先访问子树再访问兄弟节点
   
   示例 n=13 的字典序树：
   ```
   1 -> 10 -> 100(超出) 回溯 -> 11 -> 110(超出) 回溯 -> 12 -> 120(超出) 回溯 -> 13 -> 130(超出) 回溯
   回到根层 -> 2 -> 20(超出) -> 3 -> 30(超出) -> ... -> 9 -> 90(超出)
   ```
   
   字典序：[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]

4. 实现要点：

   关键思想：避免完整遍历
   - 不需要真正构建树，只需要计算每个子树的大小
   - 通过子树大小判断目标数字是否在当前子树中
   - 如果不在，跳过整个子树；如果在，进入子树继续寻找
   
   核心函数getSteps：
   - 计算以cur为根的子树中有多少个数字 <= n
   - 逐层计算：第0层[cur, cur]，第1层[cur0, cur9]，第2层[cur00, cur99]...
   - 每层的贡献：min(last, n) - first + 1
   
   遍历策略：
   - 如果子树大小 <= k：跳过子树，移动到兄弟节点
   - 如果子树大小 > k：进入子树，深度增加一层
   
   边界处理：
   - k--：转换为基于0的索引
   - Math.min(last, n)：确保不超出范围n

5. 算法步骤详解：

   以 n=13, k=2 为例：
   
   初始：cur=1, k=1（k--后）
   
   第1轮：
   - 计算以1为根的子树大小：getSteps(1, 13)
     - 第0层：[1,1] → 1个数字
     - 第1层：[10,19] ∩ [1,13] = [10,13] → 4个数字
     - 总共5个数字
   - 5 > 1，进入子树：cur=10, k=0
   
   第2轮：
   - k=0，退出循环
   - 返回10
   
   验证：字典序为[1, 10, 11, 12, 13, 2, 3, 4, 5, 6, 7, 8, 9]
   第2小确实是10 ✓

6. 优化技巧：

   时间优化：
   - 避免完整遍历，通过数学计算快速跳过
   - getSteps函数的层数最多为logn，高效计算子树大小
   
   空间优化：
   - 不需要真正构建树结构，只需要两个变量cur和k
   - 常数空间复杂度
   
   数学技巧：
   - 十进制树的规律性：每层的节点数可以直接计算
   - 利用Math.min避免越界，处理边界情况

7. 关键难点：

   理解字典序树：
   - 字典序≠数值序，需要按字符串比较规则理解
   - 树的结构反映了字典序的层次关系
   
   getSteps函数：
   - 正确计算每层的节点数
   - 处理超出n的情况
   - 理解first和last的更新规律
   
   遍历策略：
   - 何时跳过子树（水平移动）
   - 何时进入子树（垂直移动）
   - k的维护和更新

8. 类似问题：
   - LeetCode 386: 字典序排数
   - 字典序相关的树遍历问题
   - 第k小元素问题（二分搜索变体）

9. 常见错误：
   - 忘记k--的初始化
   - getSteps函数的边界处理错误
   - 混淆字典序和数值序的概念
   - 子树大小计算错误
*/
