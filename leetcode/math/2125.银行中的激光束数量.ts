/*
 * @lc app=leetcode.cn id=2125 lang=typescript
 *
 * [2125] 银行中的激光束数量
 *
 * https://leetcode.cn/problems/number-of-laser-beams-in-a-bank/description/
 *
 * algorithms
 * Medium (82.42%)
 * Likes:    40
 * Dislikes: 0
 * Total Accepted:    27.1K
 * Total Submissions: 31.7K
 * Testcase Example:  '["011001","000000","010100","001000"]'
 *
 * 银行内部的防盗安全装置已经激活。给你一个下标从 0 开始的二进制字符串数组 bank ，表示银行的平面图，这是一个大小为 m x n 的二维矩阵。
 * bank[i] 表示第 i 行的设备分布，由若干 '0' 和若干 '1' 组成。'0' 表示单元格是空的，而 '1' 表示单元格有一个安全设备。
 *
 * 对任意两个安全设备而言，如果同时 满足下面两个条件，则二者之间存在 一个 激光束：
 *
 *
 * 两个设备位于两个 不同行 ：r1 和 r2 ，其中 r1 < r2 。
 * 满足 r1 < i < r2 的 所有 行 i ，都 没有安全设备 。
 *
 *
 * 激光束是独立的，也就是说，一个激光束既不会干扰另一个激光束，也不会与另一个激光束合并成一束。
 *
 * 返回银行中激光束的总数量。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 *
 * 输入：bank = ["011001","000000","010100","001000"]
 * 输出：8
 * 解释：在下面每组设备对之间，存在一条激光束。总共是 8 条激光束：
 * ⁠* bank[0][1] -- bank[2][1]
 * ⁠* bank[0][1] -- bank[2][3]
 * ⁠* bank[0][2] -- bank[2][1]
 * ⁠* bank[0][2] -- bank[2][3]
 * ⁠* bank[0][5] -- bank[2][1]
 * ⁠* bank[0][5] -- bank[2][3]
 * ⁠* bank[2][1] -- bank[3][2]
 * ⁠* bank[2][3] -- bank[3][2]
 * 注意，第 0 行和第 3 行上的设备之间不存在激光束。
 * 这是因为第 2 行存在安全设备，这不满足第 2 个条件。
 *
 *
 * 示例 2：
 *
 *
 *
 *
 * 输入：bank = ["000","111","000"]
 * 输出：0
 * 解释：不存在两个位于不同行的设备
 *
 *
 *
 *
 * 提示：
 *
 *
 * m == bank.length
 * n == bank[i].length
 * 1 <= m, n <= 500
 * bank[i][j] 为 '0' 或 '1'
 *
 *
 */

// @lc code=start
function numberOfBeams(bank: string[]): number {
  let res = 0; // 激光束的总数量
  let last = 0; // 上一个有设备的行中设备的数量

  // 遍历每一行
  for (const row of bank) {
    let cnt = 0; // 当前行的设备数量

    // 统计当前行有多少个安全设备（'1'的个数）
    for (const ch of row) {
      if (ch === "1") {
        cnt++;
      }
    }

    // 如果当前行有设备
    if (cnt > 0) {
      // 计算激光束数量：当前行的设备数 × 上一个有设备行的设备数
      // 因为每个设备会和另一行的每个设备之间产生一条激光束
      res += last * cnt;

      // 更新 last 为当前行的设备数，作为下一行计算的基准
      last = cnt;
    }
    // 如果当前行没有设备（cnt = 0），跳过，不更新 last
    // 因为激光束要求中间的行都没有设备
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 激光束只能在不同行的设备之间形成
   - 两个设备之间要形成激光束，中间的所有行都不能有设备
   - 每对符合条件的设备之间有一条激光束
   - 目标：计算所有激光束的总数量

2. 算法分析：
   - 时间复杂度：O(m × n)
     * m 是行数，n 是每行的列数
     * 需要遍历每一行的每个字符来统计设备数量
   - 空间复杂度：O(1)
     * 只使用了常数个额外变量
   - 算法类型：贪心 + 模拟

3. 解题思路：

   核心观察：
   - 如果相邻的两个有设备的行分别有 a 和 b 个设备
   - 那么这两行之间的激光束数量是 a × b
   - 因为第一行的每个设备都会和第二行的每个设备产生一条激光束
   
   关键洞察：
   - 只需要关注有设备的行，忽略没有设备的空行
   - 维护"上一个有设备的行"的设备数量
   - 每遇到一个新的有设备的行，就计算它与上一行之间的激光束数量

   算法步骤：
   
   步骤1：初始化
   - res = 0：记录激光束总数
   - last = 0：记录上一个有设备的行的设备数量
   
   步骤2：遍历每一行
   - 统计当前行的设备数量 cnt
   
   步骤3：如果当前行有设备（cnt > 0）
   - 计算激光束数量：res += last × cnt
   - 更新 last = cnt，作为下一个有设备行的参照
   
   步骤4：如果当前行没有设备
   - 跳过，不更新 last
   - 因为激光束要求中间行都没有设备
   
   步骤5：返回总激光束数量

4. 实现要点：

   关键技巧：
   - 只关注有设备的行：忽略空行，它们不影响计算
   - 相邻有设备行的乘法：a 行 × b 行 = a×b 条激光束
   - 动态更新基准：每次遇到有设备的行就更新 last
   
   边界条件处理：
   - 第一个有设备的行：last = 0，所以 res += 0 × cnt = 0（不增加）
   - 全是空行：last 始终为 0，res 也始终为 0
   - 只有一行有设备：只更新一次 last，res 始终为 0
   
   为什么这个算法正确：
   - 激光束只在相邻的有设备行之间形成
   - 中间的空行不影响激光束的形成
   - 通过维护 last，我们总是在计算相邻有设备行之间的激光束

5. 示例分析：

   示例1：bank = ["011001","000000","010100","001000"]
   
   可视化：
   行0: 0 1 1 0 0 1  (3个设备，位置1, 2, 5)
   行1: 0 0 0 0 0 0  (0个设备，空行)
   行2: 0 1 0 1 0 0  (2个设备，位置1, 3)
   行3: 0 0 1 0 0 0  (1个设备，位置2)
   
   执行过程：
   - 初始：res = 0, last = 0
   
   - 行0：cnt = 3（有设备）
     * res += 0 × 3 = 0（第一个有设备的行，没有前置行）
     * last = 3
     * 状态：res = 0, last = 3
   
   - 行1：cnt = 0（空行）
     * 跳过，不更新
     * 状态：res = 0, last = 3
   
   - 行2：cnt = 2（有设备）
     * res += 3 × 2 = 6（行0和行2之间有6条激光束）
     * 详细：行0的3个设备 × 行2的2个设备 = 6条激光束
     * last = 2
     * 状态：res = 6, last = 2
   
   - 行3：cnt = 1（有设备）
     * res += 2 × 1 = 2（行2和行3之间有2条激光束）
     * 详细：行2的2个设备 × 行3的1个设备 = 2条激光束
     * last = 1
     * 状态：res = 8, last = 1
   
   返回 8 ✓
   
   激光束详解：
   行0→行2：6条
   - 设备[0,1] → 设备[2,1]
   - 设备[0,1] → 设备[2,3]
   - 设备[0,2] → 设备[2,1]
   - 设备[0,2] → 设备[2,3]
   - 设备[0,5] → 设备[2,1]
   - 设备[0,5] → 设备[2,3]
   
   行2→行3：2条
   - 设备[2,1] → 设备[3,2]
   - 设备[2,3] → 设备[3,2]

   示例2：bank = ["000","111","000"]
   
   执行过程：
   - 初始：res = 0, last = 0
   
   - 行0：cnt = 0（空行）
     * 跳过
     * 状态：res = 0, last = 0
   
   - 行1：cnt = 3（有设备）
     * res += 0 × 3 = 0（只有一个有设备的行）
     * last = 3
     * 状态：res = 0, last = 3
   
   - 行2：cnt = 0（空行）
     * 跳过
     * 状态：res = 0, last = 3
   
   返回 0 ✓（只有一个有设备的行，无法形成激光束）

6. 算法要点总结：

   核心技巧：
   - 乘法原理：两组之间的连接数 = 第一组大小 × 第二组大小
   - 忽略空行：只关注有设备的行
   - 动态维护：用 last 记录上一个有设备行的状态
   
   优化要点：
   - 一次遍历：O(m×n) 时间复杂度已经是最优
   - 常数空间：只使用三个变量，空间最优
   - 提前跳过：遇到空行立即跳过，不做多余计算
   
   类似问题：
   - LeetCode 1534: 统计好三元组（组合计数）
   - LeetCode 1748: 唯一元素的和（数组统计）
   - 各类涉及乘法原理的组合计数问题

7. 常见错误：

   错误1：每次都重置 last
   - 错误：每次循环都将 last 设为 cnt
   - 正确：只有当 cnt > 0 时才更新 last
   - 原因：空行不应该打断"相邻有设备行"的关系
   
   错误2：计算所有设备对
   - 错误：尝试记录所有设备的位置，然后两两配对
   - 正确：只需要统计每行的设备数量
   - 原因：激光束数量只与设备数量有关，与具体位置无关
   
   错误3：考虑设备的列位置
   - 错误：认为激光束与设备的列位置有关
   - 正确：激光束数量只与不同行的设备数量有关
   - 原因：题目说明激光束独立，不会相互干扰
   
   错误4：累加所有行的设备数
   - 错误：先统计总设备数，然后计算组合数
   - 正确：只计算相邻有设备行之间的乘积
   - 原因：激光束要求中间行没有设备

8. 扩展思考：

   数学原理 - 乘法原理：
   - 如果完成一件事需要两个步骤
   - 第一步有 m 种方法，第二步有 n 种方法
   - 那么完成这件事共有 m × n 种方法
   
   应用到本题：
   - 选择第一行的一个设备：a 种方法
   - 选择第二行的一个设备：b 种方法
   - 形成激光束：a × b 种方法

   为什么不考虑设备的列位置：
   - 题目明确说明"激光束是独立的"
   - 意味着所有可能的设备对都能形成激光束
   - 不存在因为列位置冲突而无法形成激光束的情况

   优化空间（实际上已经最优）：
   ```typescript
   // 可以使用字符串的 split 和 filter 方法
   function numberOfBeams(bank: string[]): number {
     let res = 0;
     let last = 0;
     
     for (const row of bank) {
       const cnt = row.split('1').length - 1; // 统计'1'的个数
       if (cnt > 0) {
         res += last * cnt;
         last = cnt;
       }
     }
     
     return res;
   }
   
   // 或者使用正则表达式
   function numberOfBeams(bank: string[]): number {
     let res = 0;
     let last = 0;
     
     for (const row of bank) {
       const matches = row.match(/1/g);
       const cnt = matches ? matches.length : 0;
       if (cnt > 0) {
         res += last * cnt;
         last = cnt;
       }
     }
     
     return res;
   }
   ```

9. 可视化理解：

   问题模型：
   ```
   行0: • • •    (3个设备)
        ╲│╱╲│╱    (交叉连接)
   行1: (空行)    (不影响)
        ╲│╱╲│╱    (跨过空行)
   行2:  • •      (2个设备)
         ╲│╱      (继续连接)
   行3:   •       (1个设备)
   ```
   
   激光束计数：
   - 行0→行2：3 × 2 = 6 条
   - 行2→行3：2 × 1 = 2 条
   - 总计：6 + 2 = 8 条

   关键理解：
   - 激光束在相邻的"有设备行"之间形成
   - "相邻"是指跳过所有空行后的相邻
   - 数量是两行设备数的乘积

10. 总结：

    这道题考察：
    
    ✓ 数学思维
      - 乘法原理的应用
      - 组合计数的理解
    
    ✓ 算法优化
      - 避免不必要的状态存储
      - 一次遍历解决问题
    
    ✓ 问题简化
      - 将复杂的二维问题简化为一维
      - 忽略不重要的信息（列位置）
    
    ✓ 边界处理
      - 第一个有设备的行
      - 全空行的情况
      - 只有一行有设备的情况
    
    关键要点：
    1. 激光束数量 = 相邻有设备行的设备数乘积之和
    2. 空行不影响激光束的形成（跳过即可）
    3. 不需要记录设备的具体位置
    4. 使用乘法原理快速计算
    
    这道题虽然看起来复杂，但核心思想很简单：
    - 找到相邻的有设备行
    - 用乘法计算它们之间的激光束数量
    - 累加所有结果
    
    体现了算法设计的重要原则：
    - 问题简化（从2D到1D）
    - 贪心策略（只关注有设备的行）
    - 数学优化（用乘法代替枚举）
*/
