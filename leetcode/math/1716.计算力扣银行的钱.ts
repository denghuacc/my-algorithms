/*
 * @lc app=leetcode.cn id=1716 lang=typescript
 *
 * [1716] 计算力扣银行的钱
 *
 * https://leetcode-cn.com/problems/calculate-money-in-leetcode-bank/description/
 *
 * algorithms
 * Easy (66.92%)
 * Likes:    30
 * Dislikes: 0
 * Total Accepted:    15.6K
 * Total Submissions: 22.2K
 * Testcase Example:  '4'
 *
 * Hercy 想要为购买第一辆车存钱。他 每天 都往力扣银行里存钱。
 *
 * 最开始，他在周一的时候存入 1 块钱。从周二到周日，他每天都比前一天多存入 1 块钱。在接下来每一个周一，他都会比 前一个周一 多存入 1 块钱。
 *
 * 给你 n ，请你返回在第 n 天结束的时候他在力扣银行总共存了多少块钱。
 *
 *
 *
 * 示例 1：
 *
 * 输入：n = 4
 * 输出：10
 * 解释：第 4 天后，总额为 1 + 2 + 3 + 4 = 10 。
 *
 *
 * 示例 2：
 *
 * 输入：n = 10
 * 输出：37
 * 解释：第 10 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4) = 37
 * 。注意到第二个星期一，Hercy 存入 2 块钱。
 *
 *
 * 示例 3：
 *
 * 输入：n = 20
 * 输出：96
 * 解释：第 20 天后，总额为 (1 + 2 + 3 + 4 + 5 + 6 + 7) + (2 + 3 + 4 + 5 + 6 + 7 + 8) +
 * (3 + 4 + 5 + 6 + 7 + 8) = 96 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= n <= 1000
 *
 *
 */

// @lc code=start
// 解法1: 数学公式法 - 等差数列求和
var totalMoney = function (n: number): number {
  // 如果天数不超过 7 天（一周内），直接计算等差数列和
  if (n <= 7) {
    return getSomeMoney(1, n);
  } else {
    // 计算完整周的存款
    const firstWeekMoney = getSomeMoney(1, 7); // 第一周的总金额: 1+2+3+4+5+6+7 = 28
    const loop = Math.floor(n / 7); // 完整的周数

    // 完整周的总金额计算：
    // 第1周: 1+2+3+4+5+6+7 = 28
    // 第2周: 2+3+4+5+6+7+8 = 35 = 28 + 7
    // 第3周: 3+4+5+6+7+8+9 = 42 = 28 + 14
    // ...
    // 第k周: 28 + (k-1)*7
    // 总和 = 28*k + 7*(0+1+2+...+(k-1)) = 28*k + 7*k*(k-1)/2
    const sum = firstWeekMoney * loop + ((loop * (loop - 1)) / 2) * 7;

    // 计算剩余不足一周的天数
    const remain = n % 7;
    const remainFirst = 1 + loop; // 剩余天数的起始金额（第 loop+1 周的周一）
    const remainSum = getSomeMoney(remainFirst, remain);

    return sum + remainSum;
  }

  /**
   * 计算等差数列的和
   * @param first - 首项
   * @param n - 项数
   * @returns 等差数列和: first + (first+1) + ... + (first+n-1)
   *
   * 公式推导：
   * sum = first + (first+1) + (first+2) + ... + (first+n-1)
   *     = first*n + (0+1+2+...+(n-1))
   *     = first*n + n*(n-1)/2
   */
  function getSomeMoney(first: number, n: number) {
    return first * n + ((n - 1) * n) / 2;
  }
};

// 解法2: 模拟法 - 逐天计算
var totalMoney = function (n: number): number {
  let sum = 0; // 总金额
  let t = 0; // 当前周的周一存入的金额（基础金额）

  for (let i = 0; i < n; i++) {
    // 每周的第一天（周一），基础金额加 1
    if (i % 7 === 0) {
      t++;
    }

    // 当天存入的金额 = 基础金额 + 当前是周几（0-6）
    // 例如：第2周的周三 = 2（第2周周一的金额）+ 2（周三是第3天，索引2）= 4
    sum += t + (i % 7);
  }

  return sum;
};
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 每周从周一到周日依次存入递增的金额
   - 第 1 周：1, 2, 3, 4, 5, 6, 7
   - 第 2 周：2, 3, 4, 5, 6, 7, 8
   - 第 3 周：3, 4, 5, 6, 7, 8, 9
   - 每周的周一比前一周的周一多存 1 块钱
   - 目标：计算 n 天后的总存款

2. 算法分析：

   解法1 - 数学公式法：
   - 时间复杂度：O(1) - 只需要常数次计算
   - 空间复杂度：O(1) - 只使用常数个变量
   - 算法类型：数学 + 等差数列求和
   
   解法2 - 模拟法：
   - 时间复杂度：O(n) - 需要遍历 n 天
   - 空间复杂度：O(1) - 只使用常数个变量
   - 算法类型：模拟

3. 解题思路：

   思路1：数学公式法（推荐）
   
   核心观察：
   - 每周的存款构成一个等差数列
   - 第 k 周的周一存入 k 块钱
   - 第 k 周的存款序列：k, k+1, k+2, k+3, k+4, k+5, k+6
   - 第 k 周的总金额：7k + (0+1+2+3+4+5+6) = 7k + 21
   
   步骤分解：
   
   步骤1：计算完整周数和剩余天数
   - 完整周数：loop = floor(n / 7)
   - 剩余天数：remain = n % 7
   
   步骤2：计算完整周的总金额
   - 第 1 周：28 (= 1+2+3+4+5+6+7)
   - 第 2 周：35 (= 2+3+4+5+6+7+8 = 28+7)
   - 第 3 周：42 (= 3+4+5+6+7+8+9 = 28+14)
   - ...
   - 第 k 周：28 + (k-1)*7
   - 总和：28*k + 7*(0+1+2+...+(k-1)) = 28k + 7*k*(k-1)/2
   
   步骤3：计算剩余天数的金额
   - 起始金额：loop + 1（第 loop+1 周的周一）
   - 使用等差数列求和公式
   
   等差数列求和公式：
   - 已知首项 a1、项数 n
   - 数列：a1, a1+1, a1+2, ..., a1+(n-1)
   - 求和：S = a1*n + (0+1+2+...+(n-1)) = a1*n + n*(n-1)/2

   思路2：模拟法（直观易懂）
   
   核心思想：
   - 逐天模拟存款过程
   - 使用变量 t 记录当前周的周一基础金额
   - 每天的存款 = 基础金额 + 当周的第几天
   
   算法步骤：
   
   步骤1：初始化
   - sum = 0（总金额）
   - t = 0（周一基础金额，每周一会加 1）
   
   步骤2：遍历每一天
   - 如果是周一（i % 7 == 0），t 加 1
   - 当天存款 = t + (i % 7)
   - 累加到总金额
   
   步骤3：返回总金额

4. 实现要点：

   数学公式法的关键：
   - 等差数列求和公式的正确应用
   - 完整周和剩余天数的分别计算
   - 第 k 周的周一金额是 k
   
   模拟法的关键：
   - 正确处理周一的基础金额递增
   - i % 7 表示当周的第几天（0-6）
   - 当天金额 = 基础金额 + 周内偏移量
   
   边界条件处理：
   - n = 1：只存第一天，返回 1
   - n = 7：正好一周，返回 28
   - n <= 7：不超过一周，直接计算等差数列和

5. 示例分析：

   示例1：n = 4
   
   存款序列：1, 2, 3, 4
   总和：1 + 2 + 3 + 4 = 10 ✓
   
   使用公式：
   - 完整周数：0
   - 剩余天数：4
   - 起始金额：1
   - 总和：1*4 + 3*4/2 = 4 + 6 = 10 ✓

   示例2：n = 10
   
   存款序列：
   - 第 1 周（7天）：1, 2, 3, 4, 5, 6, 7 → 和 = 28
   - 第 2 周（3天）：2, 3, 4 → 和 = 9
   总和：28 + 9 = 37 ✓
   
   使用公式：
   - 完整周数：1
   - 第 1 周总金额：28
   - 剩余天数：3
   - 剩余起始金额：2
   - 剩余总和：2*3 + 2*3/2 = 6 + 3 = 9
   - 总和：28 + 9 = 37 ✓

   示例3：n = 20
   
   存款序列：
   - 第 1 周：1, 2, 3, 4, 5, 6, 7 → 和 = 28
   - 第 2 周：2, 3, 4, 5, 6, 7, 8 → 和 = 35
   - 第 3 周：3, 4, 5, 6 → 和 = 18 + 15 = 18
   
   使用公式验证：
   - 完整周数：2
   - 完整周总金额：28*2 + 7*2*1/2 = 56 + 7 = 63
   - 剩余天数：6
   - 剩余起始金额：3
   - 剩余总和：3*6 + 5*6/2 = 18 + 15 = 33
   - 总和：63 + 33 = 96 ✓

6. 算法要点总结：

   核心技巧：
   - 等差数列求和公式的应用
   - 将问题分解为完整周 + 剩余天数
   - 识别每周的规律（基础金额递增）
   
   优化要点：
   - 数学公式法将 O(n) 优化到 O(1)
   - 避免逐天计算，直接计算周的总和
   
   类似问题：
   - LeetCode 258: 各位相加（数学规律）
   - LeetCode 1237: 找出给定方程的正整数解（等差数列）
   - 各类等差数列求和问题

7. 常见错误：

   错误1：等差数列求和公式错误
   - 错误：first*n + n*n/2
   - 正确：first*n + n*(n-1)/2
   - 原因：要加的是 0+1+2+...+(n-1)，共 n 项
   
   错误2：完整周总金额计算错误
   - 容易忽略每周的递增量
   - 每周比前一周多 7 块钱（因为每天多 1 块）
   
   错误3：剩余天数的起始金额错误
   - 应该是 loop + 1（第 loop+1 周的周一）
   - 而不是 loop
   
   错误4：模拟法中周一判断错误
   - 应该在处理当前天之前判断是否是周一
   - i % 7 === 0 表示新的一周开始

8. 扩展思考：

   通用等差数列求和公式：
   
   已知：首项 a1，末项 an，项数 n
   - 求和公式：S = n * (a1 + an) / 2
   
   已知：首项 a1，公差 d，项数 n
   - 末项：an = a1 + (n-1) * d
   - 求和：S = n * a1 + n * (n-1) * d / 2
   
   本题中：
   - 第 k 周：首项 = k，公差 = 1，项数 = 7
   - 第 k 周总和：7k + 7*6/2 = 7k + 21

   更简洁的数学推导：
   
   设完整周数为 w，剩余天数为 r
   - 完整周总和：Σ(7k + 21) for k=1 to w
     = 7*(1+2+...+w) + 21*w
     = 7*w*(w+1)/2 + 21*w
     = 7w(w+1)/2 + 21w
   
   - 剩余天数总和：(w+1)*r + r*(r-1)/2
   
   - 总和：7w(w+1)/2 + 21w + (w+1)*r + r*(r-1)/2

9. 两种解法对比：

   数学公式法：
   优点：
   - 时间复杂度 O(1)，效率最高
   - 适合大规模数据
   - 展示数学思维
   
   缺点：
   - 代码稍复杂，需要理解等差数列
   - 容易出错（公式推导）
   
   模拟法：
   优点：
   - 代码简洁直观
   - 易于理解和实现
   - 不容易出错
   
   缺点：
   - 时间复杂度 O(n)
   - 对于大 n 效率较低

   选择建议：
   - 题目数据范围 n <= 1000，两种方法都可以
   - 追求性能：使用数学公式法
   - 追求简洁：使用模拟法
   - 面试场景：可以先用模拟法实现，再优化到公式法

10. 数学美感：

    这道题体现了数学在编程中的应用：
    
    - 规律识别：发现每周的存款构成等差数列
    - 公式推导：将复杂的累加转化为简单的公式计算
    - 时间优化：从线性时间优化到常数时间
    
    等差数列在实际中的应用：
    - 财务计算：贷款、存款利息
    - 工程计算：梯形面积、台阶问题
    - 算法优化：时间复杂度分析
    
    记住这个万能公式：
    - 1 + 2 + 3 + ... + n = n * (n+1) / 2
    - a + (a+1) + (a+2) + ... + (a+n-1) = a*n + n*(n-1)/2
*/
