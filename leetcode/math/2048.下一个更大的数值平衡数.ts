/*
 * @lc app=leetcode.cn id=2048 lang=typescript
 *
 * [2048] 下一个更大的数值平衡数
 *
 * https://leetcode.cn/problems/next-greater-numerically-balanced-number/description/
 *
 * algorithms
 * Medium (46.28%)
 * Likes:    59
 * Dislikes: 0
 * Total Accepted:    14.5K
 * Total Submissions: 25.9K
 * Testcase Example:  '1'
 *
 * 如果整数  x 满足：对于每个数位 d ，这个数位 恰好 在 x 中出现 d 次。那么整数 x 就是一个 数值平衡数 。
 *
 * 给你一个整数 n ，请你返回 严格大于 n 的 最小数值平衡数 。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：n = 1
 * 输出：22
 * 解释：
 * 22 是一个数值平衡数，因为：
 * - 数字 2 出现 2 次
 * 这也是严格大于 1 的最小数值平衡数。
 *
 *
 * 示例 2：
 *
 *
 * 输入：n = 1000
 * 输出：1333
 * 解释：
 * 1333 是一个数值平衡数，因为：
 * - 数字 1 出现 1 次。
 * - 数字 3 出现 3 次。
 * 这也是严格大于 1000 的最小数值平衡数。
 * 注意，1022 不能作为本输入的答案，因为数字 0 的出现次数超过了 0 。
 *
 * 示例 3：
 *
 *
 * 输入：n = 3000
 * 输出：3133
 * 解释：
 * 3133 是一个数值平衡数，因为：
 * - 数字 1 出现 1 次。
 * - 数字 3 出现 3 次。
 * 这也是严格大于 3000 的最小数值平衡数。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 0 <= n <= 10^6
 *
 *
 */

// @lc code=start
function nextBeautifulNumber(n: number): number {
  // 从 n+1 开始枚举，寻找第一个数值平衡数
  // 上界 1224444 是题目范围内最大的数值平衡数
  // (由数字 1 出现 1 次，2 出现 2 次，4 出现 4 次组成)
  for (let i = n + 1; i <= 1224444; i++) {
    if (isBalance(i)) {
      return i;
    }
  }
  // 如果在范围内没找到，返回 -1（理论上不会发生）
  return -1;

  /**
   * 判断一个数是否为数值平衡数
   * @param x - 待判断的数字
   * @returns 如果是数值平衡数返回 true，否则返回 false
   *
   * 数值平衡数的定义：
   * 对于每个在 x 中出现的数位 d，该数位恰好出现 d 次
   * 例如：22（数字2出现2次），1333（数字1出现1次，数字3出现3次）
   */
  function isBalance(x: number): boolean {
    // 创建计数数组，cnt[i] 表示数字 i 在 x 中出现的次数
    const cnt = new Array(10).fill(0);

    // 统计每个数位的出现次数
    while (x > 0) {
      cnt[x % 10]++; // 获取当前个位数字并计数
      x = Math.floor(x / 10); // 去掉个位，继续处理下一位
    }

    // 验证是否满足数值平衡条件
    for (let i = 0; i < 10; i++) {
      // 如果数字 i 出现了，但出现次数不等于 i，则不是数值平衡数
      // 例如：数字 2 出现了 3 次（cnt[2]=3），不满足条件
      if (cnt[i] > 0 && cnt[i] !== i) {
        return false;
      }
    }

    // 所有出现的数字都满足条件，是数值平衡数
    return true;
  }
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 数值平衡数的定义：对于数字中每个出现的数位 d，该数位恰好出现 d 次
   - 例如：22（2出现2次）、1333（1出现1次，3出现3次）
   - 目标：找到严格大于 n 的最小数值平衡数
   - 关键约束：0 <= n <= 10^6

2. 算法分析：
   - 时间复杂度：O(m * log m)
     * m 是枚举的数字个数，最坏情况从 n+1 到 1224444
     * 对于每个数字，需要 O(log x) 时间统计各位数字（x 最多 7 位）
     * 实际运行中，数值平衡数密度较低，平均枚举次数不多
   - 空间复杂度：O(1)
     * 只使用了固定大小的计数数组（长度为 10）
   - 算法类型：枚举 + 模拟

3. 解题思路：

   核心思想：
   - 暴力枚举从 n+1 开始的每个数字
   - 对每个数字判断是否为数值平衡数
   - 返回第一个满足条件的数字

   关键观察：
   - 题目范围内（≤ 10^6）的数值平衡数数量有限
   - 最大的数值平衡数是 1224444（在题目范围内）
   - 可以通过枚举来解决，不需要复杂的数学推导

   算法步骤：
   
   步骤1：从 n+1 开始枚举
   - 我们要找严格大于 n 的数，所以从 n+1 开始
   
   步骤2：判断数值平衡性
   - 统计每个数位的出现次数
   - 验证每个出现的数位 d 的出现次数是否恰好为 d
   
   步骤3：返回第一个满足条件的数
   - 由于从小到大枚举，第一个找到的就是最小的

4. 实现要点：

   数据结构选择：
   - 计数数组 cnt：长度为 10，cnt[i] 表示数字 i 的出现次数
   - 数组索引天然对应数字 0-9，便于统计和验证
   
   边界条件处理：
   - n = 0：下一个数值平衡数是 1（不满足条件）或 22
   - 枚举上界 1224444：题目范围内最大的数值平衡数
   - 数字 0 的特殊性：0 不能出现（因为 0 出现 0 次本身就是矛盾）
   
   优化技巧：
   - 设置明确的上界避免无限循环
   - 提前终止：一旦发现某个数位不满足条件，立即返回 false

5. 示例分析：

   示例1：n = 1
   
   枚举过程：
   - i = 2: cnt = [0,0,1,0,0,0,0,0,0,0]
     数字 2 出现 1 次，但需要出现 2 次，不满足 ✗
   
   - i = 3 到 21: 都不满足条件
   
   - i = 22: cnt = [0,0,2,0,0,0,0,0,0,0]
     数字 2 出现 2 次，满足条件 ✓
   
   返回 22

   示例2：n = 1000
   
   枚举过程（跳过中间不满足的）：
   - i = 1333: cnt = [0,1,0,3,0,0,0,0,0,0]
     * 数字 1 出现 1 次 ✓
     * 数字 3 出现 3 次 ✓
     * 所有出现的数字都满足条件 ✓
   
   返回 1333

   示例3：n = 3000
   
   枚举过程：
   - i = 3133: cnt = [0,1,0,3,0,0,0,0,0,0]
     * 数字 1 出现 1 次 ✓
     * 数字 3 出现 3 次 ✓
   
   返回 3133

6. 数值平衡数的特性：

   在 10^6 范围内的所有数值平衡数：
   
   1 位数：无（0 不能出现）
   2 位数：22
   3 位数：122
   4 位数：1333
   5 位数：
   - 由 1 个 1 和 4 个 4 组成：14444, 41444, 44144, 44414, 44441
   6 位数：
   - 由 2 个 2 和 4 个 4 组成：224444, 242444, 244244, 244424, 244442,
     422444, 424244, 424424, 424442, 442244, 442424, 442442, 444224, 444242, 444422
   7 位数：
   - 由 1 个 1, 2 个 2, 4 个 4 组成：1224444 及其排列（但超过 10^6）
   
   最大的不超过 10^6 的数值平衡数：444422

7. 算法要点总结：

   核心技巧：
   - 暴力枚举：在数据范围允许的情况下，直接枚举是最简单可靠的方法
   - 计数验证：使用数组统计每个数位的出现次数
   - 设置上界：避免无效的枚举
   
   优化要点：
   - 可以预先生成所有数值平衡数，然后二分查找（但代码复杂度增加）
   - 当前解法已经足够高效，因为数值平衡数密度很低
   
   类似问题：
   - LeetCode 738: 单调递增的数字（数字性质判断）
   - LeetCode 902: 最大为 N 的数字组合（数位DP）
   - 各类"特殊数字"判断问题

8. 常见错误：

   错误1：忘记处理数字 0
   - 数字 0 不能出现在数值平衡数中
   - 如果 0 出现了任意次（>0），都不满足条件（0 应该出现 0 次）
   - 代码中通过 cnt[i] > 0 && cnt[i] !== i 自动处理了这个情况
   
   错误2：枚举范围错误
   - 应该从 n+1 开始（严格大于 n）
   - 上界应该是题目范围内最大的数值平衡数
   
   错误3：计数逻辑错误
   - 使用 x % 10 获取个位数字
   - 使用 Math.floor(x / 10) 去掉个位
   - 注意 TypeScript 中除法默认返回浮点数，需要 Math.floor
   
   错误4：验证条件错误
   - 只有出现的数字（cnt[i] > 0）才需要验证
   - 未出现的数字（cnt[i] = 0）自动满足条件

9. 扩展思考：

   优化方案1：预计算 + 二分查找
   ```typescript
   // 预先生成所有数值平衡数
   const balancedNumbers = [22, 122, 1333, 14444, ...];
   
   function nextBeautifulNumber(n: number): number {
     // 二分查找第一个大于 n 的数值平衡数
     let left = 0, right = balancedNumbers.length - 1;
     while (left <= right) {
       const mid = Math.floor((left + right) / 2);
       if (balancedNumbers[mid] <= n) {
         left = mid + 1;
       } else {
         right = mid - 1;
       }
     }
     return balancedNumbers[left];
   }
   ```
   - 时间复杂度：O(log k)，k 是数值平衡数的个数（约30个）
   - 空间复杂度：O(k)
   - 优点：查询极快
   - 缺点：需要预计算，代码较长

   优化方案2：数位 DP
   - 使用数位动态规划直接构造下一个数值平衡数
   - 复杂度更优，但实现复杂度极高
   - 对于这道题的数据范围，收益不明显

   数学性质：
   - 数值平衡数的密度随着数值增大而降低
   - 构成数值平衡数的数字集合有限（只能用 1,2,3,4,5,6,7）
   - 数字 8,9 理论上可以用，但在合理范围内构不成数值平衡数
   - 例如：最小包含 8 的数值平衡数需要 8 个 8，至少是 88888888（8位数）

10. 为什么上界是 1224444？

    分析：
    - 题目范围 n <= 10^6，所以答案最多是 7 位数
    - 7 位数能构成的数值平衡数：由 1 个 1、2 个 2、4 个 4 组成
    - 1 + 2 + 4 = 7，正好 7 位
    - 按从小到大排列：1224444
    - 这是在合理范围内最大的数值平衡数
    - 实际上对于 n <= 10^6，答案最大是 444422（6位数）
*/
