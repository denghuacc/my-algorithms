/*
 * @lc app=leetcode.cn id=1513 lang=typescript
 *
 * [1513] 仅含 1 的子串数
 *
 * https://leetcode.cn/problems/number-of-substrings-with-only-1s/description/
 *
 * algorithms
 * Medium (41.46%)
 * Likes:    40
 * Dislikes: 0
 * Total Accepted:    23.3K
 * Total Submissions: 51.5K
 * Testcase Example:  '"0110111"'
 *
 * 给你一个二进制字符串 s（仅由 '0' 和 '1' 组成的字符串）。
 *
 * 返回所有字符都为 1 的子字符串的数目。
 *
 * 由于答案可能很大，请你将它对 10^9 + 7 取模后返回。
 *
 *
 *
 * 示例 1：
 *
 * 输入：s = "0110111"
 * 输出：9
 * 解释：共有 9 个子字符串仅由 '1' 组成
 * "1" -> 5 次
 * "11" -> 3 次
 * "111" -> 1 次
 *
 * 示例 2：
 *
 * 输入：s = "101"
 * 输出：2
 * 解释：子字符串 "1" 在 s 中共出现 2 次
 *
 *
 * 示例 3：
 *
 * 输入：s = "111111"
 * 输出：21
 * 解释：每个子字符串都仅由 '1' 组成
 *
 *
 * 示例 4：
 *
 * 输入：s = "000"
 * 输出：0
 *
 *
 *
 *
 * 提示：
 *
 *
 * s[i] == '0' 或 s[i] == '1'
 * 1 <= s.length <= 10^5
 *
 *
 */

// @lc code=start
/**
 * 仅含 1 的子串数
 *
 * 核心思路：
 * 找出所有连续的 1 段，对于长度为 n 的连续 1 段，
 * 其包含的全 1 子串数量为 n*(n+1)/2（组合数学公式）
 *
 * 时间复杂度：O(n)
 * 空间复杂度：O(1)
 */
function numSub(s: string): number {
  const MOD = 1e9 + 7; // 取模常量
  let cnt = 0; // 当前连续 1 的长度
  let res = 0; // 结果总数

  // 遍历字符串的每个字符
  for (const ch of s) {
    if (ch === "1") {
      // 遇到 1，连续长度加 1
      cnt++;
    } else {
      // 遇到 0，说明一段连续的 1 结束了
      // 计算这段连续 1 能组成的子串数量：cnt * (cnt + 1) / 2
      // 这是组合数学中的求和公式：1 + 2 + 3 + ... + n = n(n+1)/2
      res = (res + (((cnt * (cnt + 1)) / 2) % MOD)) % MOD;
      cnt = 0; // 重置计数器
    }
  }

  // 处理最后一段连续的 1（如果字符串以 1 结尾）
  res = (res + (((cnt * (cnt + 1)) / 2) % MOD)) % MOD;

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 统计二进制字符串中所有仅包含 '1' 的子串数量
   - 子串必须是连续的
   - 结果需要对 10^9 + 7 取模

2. 算法分析：
   - 时间复杂度：O(n) - 只需遍历字符串一次
   - 空间复杂度：O(1) - 只使用常数额外空间
   - 算法类型：数学 + 贪心

3. 解题思路：

   【核心观察】
   - 字符串可以被 '0' 分割成多个连续的 '1' 段
   - 每段独立计算，互不影响
   - 对于长度为 n 的连续 '1' 段，能组成的全 '1' 子串数量是固定的

   【数学推导】
   
   对于连续的 n 个 '1'，例如 "111"：
   - 长度为 1 的子串：n 个（每个 '1' 单独成串）
   - 长度为 2 的子串：n-1 个（"11" 可以在 n-1 个位置开始）
   - 长度为 3 的子串：n-2 个
   - ...
   - 长度为 n 的子串：1 个
   
   总数 = n + (n-1) + (n-2) + ... + 1 = n(n+1)/2
   
   这是经典的等差数列求和公式！

   【算法步骤】
   1. 遍历字符串，统计每段连续 '1' 的长度
   2. 遇到 '0' 或字符串结束时，计算当前段的贡献：cnt*(cnt+1)/2
   3. 累加所有段的贡献，最后取模返回

   【为什么要取模】
   - 答案可能很大，超出整数范围
   - 每次计算都需要取模，避免溢出
   - 注意：先计算 cnt*(cnt+1)/2，再取模

4. 实现要点：

   【数据结构选择】
   - 只需要两个变量：cnt（当前段长度）和 res（结果）
   - 不需要额外的数组或哈希表

   【边界条件处理】
   - 字符串末尾如果是 '1'：需要在循环后额外处理最后一段
   - 字符串全是 '0'：cnt 始终为 0，结果为 0（正确）
   - 字符串全是 '1'：最后统一处理

   【取模技巧】
   - 每次加法后取模：(res + value) % MOD
   - 乘法可能溢出：先除以 2，再取模
   - 多次取模不影响结果：(a % MOD + b % MOD) % MOD = (a + b) % MOD

5. 示例分析：

   【示例 1】s = "0110111"
   
   分段分析：
   - "0" → cnt = 0
   - "11" → cnt = 2, 贡献 = 2*3/2 = 3
     * 子串："1"(位置1), "1"(位置2), "11"
   - "0" → cnt = 0
   - "111" → cnt = 3, 贡献 = 3*4/2 = 6
     * 子串："1"(位置4), "1"(位置5), "1"(位置6), "11"(4-5), "11"(5-6), "111"
   
   总计：3 + 6 = 9 ✓

   【示例 2】s = "101"
   
   分段分析：
   - "1" → cnt = 1, 贡献 = 1*2/2 = 1
   - "0" → cnt = 0
   - "1" → cnt = 1, 贡献 = 1*2/2 = 1
   
   总计：1 + 1 = 2 ✓

   【示例 3】s = "111111"
   
   分段分析：
   - "111111" → cnt = 6, 贡献 = 6*7/2 = 21
     * 长度1：6个, 长度2：5个, 长度3：4个, 长度4：3个, 长度5：2个, 长度6：1个
     * 总计：6+5+4+3+2+1 = 21 ✓

   【示例 4】s = "000"
   
   分段分析：
   - 没有连续的 '1'
   - cnt 始终为 0
   
   总计：0 ✓

6. 算法优势：
   - 一次遍历即可完成，效率最优
   - 不需要额外空间，内存占用小
   - 利用数学公式，避免嵌套循环
   - 代码简洁，易于理解

7. 核心算法步骤：
   1. 初始化：cnt = 0, res = 0
   2. 遍历字符串：
      - 遇到 '1'：cnt++
      - 遇到 '0'：res += cnt*(cnt+1)/2, cnt = 0
   3. 处理最后一段：res += cnt*(cnt+1)/2
   4. 返回 res % MOD

8. 常见错误：

   - ❌ 忘记处理最后一段：
     * 如果字符串以 '1' 结尾，循环结束后 cnt > 0
     * 必须在循环外再计算一次
   
   - ❌ 取模位置错误：
     * 不能只在最后取模，中间计算可能溢出
     * 每次加法后都要取模
   
   - ❌ 使用暴力枚举：
     * 枚举所有子串判断是否全为 '1'：O(n²) 或 O(n³)
     * 应该用数学公式直接计算
   
   - ❌ 整数除法问题：
     * cnt*(cnt+1) 是偶数，除以 2 不会有小数
     * TypeScript/JavaScript 中整数除法会自动处理
   
   - ❌ 边界情况：
     * 空字符串：题目保证 length >= 1
     * 全 '0'：结果为 0
     * 全 '1'：需要正确处理最后一段

9. 扩展思考：

   【类似问题】
   - LeetCode 696. 计数二进制子串
   - LeetCode 467. 环绕字符串中唯一的子字符串
   - LeetCode 795. 区间子数组个数
   - 涉及连续段统计的问题

   【数学公式推广】
   
   等差数列求和：
   - 1 + 2 + 3 + ... + n = n(n+1)/2
   - 这个公式在很多问题中都会用到
   
   组合数：
   - 从 n 个元素中选择连续子数组的方法数
   - C(n+1, 2) = (n+1)*n/2 = n(n+1)/2

   【变种问题】
   
   - 如果要求仅含 '0' 的子串数量？
     * 将判断条件 ch === '1' 改为 ch === '0'
   
   - 如果要求至少包含一个 '1' 的子串数量？
     * 总子串数 - 仅含 '0' 的子串数
     * 总子串数 = n(n+1)/2
   
   - 如果字符串包含更多字符（不只是 '0' 和 '1'）？
     * 统计特定字符的连续段，逻辑相同
   
   - 如果要求恰好包含 k 个 '1' 的子串？
     * 需要滑动窗口或前缀和

   【优化方向】
   
   - 当前算法已经是 O(n) 时间，O(1) 空间，无法进一步优化
   - 如果需要多次查询不同子串的统计，可以预处理

   【实际应用】
   
   - 数据压缩：统计连续相同字符
   - 图像处理：统计连续像素块
   - 日志分析：统计连续事件
   - 基因序列分析：统计特定碱基序列

   【数学思维】
   
   本题的关键是将问题转化为数学公式：
   - 识别出连续段的独立性
   - 应用等差数列求和公式
   - 避免暴力枚举，提高效率
   
   这种数学思维在算法题中非常重要，能够将复杂问题简化。
*/
