/*
 * @lc app=leetcode.cn id=1304 lang=typescript
 *
 * [1304] 和为零的 N 个不同整数
 *
 * https://leetcode.cn/problems/find-n-unique-integers-sum-up-to-zero/description/
 *
 * algorithms
 * Easy (70.56%)
 * Likes:    97
 * Dislikes: 0
 * Total Accepted:    38.7K
 * Total Submissions: 54K
 * Testcase Example:  '5'
 *
 * 给你一个整数 n，请你返回 任意 一个由 n 个 各不相同 的整数组成的数组，并且这 n 个数相加和为 0 。
 *
 *
 *
 * 示例 1：
 *
 * 输入：n = 5
 * 输出：[-7,-1,1,3,4]
 * 解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。
 *
 *
 * 示例 2：
 *
 * 输入：n = 3
 * 输出：[-1,0,1]
 *
 *
 * 示例 3：
 *
 * 输入：n = 1
 * 输出：[0]
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= n <= 1000
 *
 *
 */

export {};

// @lc code=start
function sumZero(n: number): number[] {
  const result: number[] = [];

  // 生成 Math.floor(n/2) 对相反数，每对和为0
  for (let i = 1; i <= Math.floor(n / 2); i++) {
    result.push(i, -i); // 添加 i 和 -i，保证和为0且数字不同
  }

  // 如果 n 是奇数，还需要一个数，添加 0 不影响总和
  if (n % 2 === 1) {
    result.push(0);
  }

  return result;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 构造n个各不相同的整数，使得它们的和为0
   - 核心约束：数字必须不同 + 总和必须为0
   - 关键洞察：利用正负数相消的数学性质

2. 算法分析：
   - 时间复杂度：O(n) - 需要遍历⌊n/2⌋次构造相反数对
   - 空间复杂度：O(1) - 除结果数组外，只使用常数额外空间
   - 算法类型：数学构造 + 贪心策略

3. 实现要点：
   - 关键数据结构：简单数组直接构造结果
   - 核心算法步骤：
     a) 预处理：计算需要的相反数对数量⌊n/2⌋
     b) 构造配对：生成(1,-1), (2,-2), (3,-3)...等相反数对
     c) 奇数补偿：若n为奇数，添加0来凑够n个数
     d) 返回结果：保证总和为0且所有数字不同
   - 边界情况处理：
     * n=1：直接返回[0]
     * n为偶数：正好配对，无需额外处理
     * n为奇数：需要补充一个0

4. 核心算法原理：
   a) 相反数性质：任意数x与-x的和为0
   b) 配对策略：⌊n/2⌋对相反数的总和必为0
   c) 奇数处理：0不影响总和，且与其他数不重复
   d) 唯一性保证：使用不同的绝对值确保所有数字不同

5. 数学证明：
   - 偶数情况：∑(i + (-i)) = ∑0 = 0，其中i∈[1, n/2]
   - 奇数情况：∑(i + (-i)) + 0 = 0 + 0 = 0，其中i∈[1, (n-1)/2]
   - 唯一性：{1, -1, 2, -2, ..., k, -k, [0]} 中所有元素互不相同

6. 优化思路：
   - 构造效率：一次遍历完成，无需额外计算或验证
   - 内存优化：直接构造结果数组，避免临时存储
   - 算法简化：利用Math.floor(n/2)统一处理奇偶情况
   - 代码清晰：逻辑简单直观，易于理解和维护

7. 示例分析：
   - n=5 (奇数)：生成2对相反数[1,-1,2,-2]，加0 → [1,-1,2,-2,0]，和=0
   - n=4 (偶数)：生成2对相反数[1,-1,2,-2] → [1,-1,2,-2]，和=0
   - n=1 (边界)：直接返回[0] → [0]，和=0
   - n=6 (偶数)：生成3对相反数[1,-1,2,-2,3,-3] → [1,-1,2,-2,3,-3]，和=0

8. 算法优势：
   - 时间最优：O(n)线性时间，无法再优化
   - 空间最优：O(1)额外空间，仅使用结果数组
   - 逻辑简单：基于基础数学原理，易于理解
   - 结果规律：生成的数组具有良好的数学结构

9. 类似问题：
   - 构造特定和的数组
   - 正负数配对问题
   - 数学构造类问题
   - 贪心构造策略

10. 常见错误：
    - 忘记处理奇数情况（不添加0）
    - 重复使用相同的数字（破坏唯一性）
    - 复杂化问题（使用不必要的算法）
    - 边界处理错误（n=1的特殊情况）

11. 扩展思考：
    - 其他构造方案：可以使用其他数字组合，如[-n+1, -n+2, ..., -1, 0, 1, ..., n-2, n-1]
    - 优化目标：最小化数组中的最大绝对值
    - 变种问题：构造和为k的n个不同整数
*/
