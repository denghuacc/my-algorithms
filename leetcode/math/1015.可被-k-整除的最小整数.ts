/*
 * @lc app=leetcode.cn id=1015 lang=typescript
 *
 * [1015] 可被 K 整除的最小整数
 *
 * https://leetcode.cn/problems/smallest-integer-divisible-by-k/description/
 *
 * algorithms
 * Medium (37.29%)
 * Likes:    98
 * Dislikes: 0
 * Total Accepted:    12.2K
 * Total Submissions: 28.4K
 * Testcase Example:  '1'
 *
 * 给定正整数 k ，你需要找出可以被 k 整除的、仅包含数字 1 的最 小 正整数 n 的长度。
 *
 * 返回 n 的长度。如果不存在这样的 n ，就返回-1。
 *
 * 注意： n 不符合 64 位带符号整数。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：k = 1
 * 输出：1
 * 解释：最小的答案是 n = 1，其长度为 1。
 *
 * 示例 2：
 *
 *
 * 输入：k = 2
 * 输出：-1
 * 解释：不存在可被 2 整除的正整数 n 。
 *
 * 示例 3：
 *
 *
 * 输入：k = 3
 * 输出：3
 * 解释：最小的答案是 n = 111，其长度为 3。
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= k <= 10^5
 *
 *
 */

// @lc code=start
/**
 * 可被 K 整除的最小整数 - 找出最短的全 1 数字长度
 *
 * @description 通过迭代余数 r' = (r * 10 + 1) % k，寻找余数为 0 的最短长度。
 *               当 k 含有 2 或 5 因子时，与 10 不互质，全 1 数无法整除，直接返回 -1。
 * @timeComplexity O(k) - 不同余数最多 k 个，重复即进入循环。
 * @spaceComplexity O(1) - 仅使用常数个变量保存长度与余数。
 * @category 数论
 *
 * @param k - 正整数范围在 [1, 1e5]，代表除数
 * @returns 可以被 k 整除的最短全 1 数字长度，若不存在则返回 -1
 */
function smallestRepunitDivByK(k: number): number {
  // 若 k 含有 2 或 5 因子，则与 10 不互质，任何全 1 数都无法整除 k。
  if (k % 2 === 0 || k % 5 === 0) {
    return -1;
  }

  let length = 1; // 当前全 1 数的长度
  let remainder = 1 % k; // 当前长度对应的余数

  while (remainder !== 0) {
    // 最多出现 k 个不同余数，超过说明出现循环且无法整除。
    if (length > k) {
      return -1;
    }

    // 根据 r' = (r * 10 + 1) % k 递推下一个长度的余数。
    remainder = (remainder * 10 + 1) % k;
    length++;
  }

  return length;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 找出仅包含数字 1 的最短正整数，使其能够被 k 整除。
   - 实际上是寻找余数为 0 的最短「全 1」数在 k 下的同余长度。

2. 算法分析：
   - 时间复杂度：O(k) - 不同余数最多 k 个，重复出现即进入循环。
   - 空间复杂度：O(1) - 只维护当前余数与长度两个变量。
   - 算法类型：数论与同余性质。

3. 解题思路：
   - 核心思想：利用同余递推，避免真实构造大整数。
   - 推导过程：若 r 为长度为 n 的全 1 数对 k 的余数，则
     r' = (r * 10 + 1) % k 为长度 n+1 的余数。
   - 主要步骤概述：
     1. 若 k 含 2 或 5 因子，与 10 不互质，全 1 数不可能整除，直接返回 -1。
     2. 从长度 1 开始，按 r' 公式递推余数，逐步增加长度。
     3. 余数为 0 时立即返回当前长度；理论上不会超过 k 步。

4. 实现要点：
   - 关键数据结构选择：只需 length 与 remainder 两个变量。
   - 核心算法步骤：每次按 r' 更新，无需存储历史余数或真实数值。
   - 边界情况处理：k 为 1 时初始余数即为 0；含 2 或 5 因子直接返回 -1。

5. 算法优势：
   - 不构造大整数，完全基于余数更新，避免溢出风险。
   - 常数空间、线性时间，代码实现简洁易懂。

6. 核心算法步骤：
   - 步骤 1：判断 k 是否与 10 互质（排除 2、5 因子）。
   - 步骤 2：初始化余数 remainder = 1 % k，长度为 1。
   - 步骤 3：迭代 remainder = (remainder * 10 + 1) % k，长度自增。
   - 步骤 4：余数为 0 时返回长度，否则超过 k 步返回 -1。

7. 示例分析：
   - 示例 1：k = 1
     * 初始余数 1 % 1 = 0，长度 1 直接返回。
   - 示例 2：k = 3
     * 余数序列：1 → 2 → 0，对应长度 1、2、3，答案为 3。
   - 示例 3：k = 7
     * 余数序列：1 → 4 → 6 → 5 → 2 → 0，长度 6 返回。
   - 边界：k = 2 或 5 时与 10 不互质，全 1 数必不被整除，返回 -1。

8. 常见错误：
   - 忽略 2、5 因子直接进入循环，导致无法终止。
   - 真实拼接数字或字符串，造成溢出或性能问题，应只维护余数。
   - 未设置最大迭代上限，理论上 k 步后若未归零即可判断不存在。

10. 扩展思考：
   - 优化思路：迭代超过 k 步时立即返回 -1，防止异常循环。
   - 类似问题：寻找最短「全 9」或其他重复数字整除某数，公式同理。
   - 变种应用：可据此统计固定长度全 1 数对 k 的余数分布，用于密码或哈希分析。
*/
