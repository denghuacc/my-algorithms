/*
 * @lc app=leetcode.cn id=3370 lang=typescript
 *
 * [3370] 仅含置位位的最小整数
 *
 * https://leetcode.cn/problems/smallest-number-with-all-set-bits/description/
 *
 * algorithms
 * Easy (83.09%)
 * Likes:    20
 * Dislikes: 0
 * Total Accepted:    22.6K
 * Total Submissions: 27.3K
 * Testcase Example:  '5'
 *
 * 给你一个正整数 n。
 *
 * 返回 大于等于 n 且二进制表示仅包含 置位 位的 最小 整数 x 。
 *
 * 置位 位指的是二进制表示中值为 1 的位。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入： n = 5
 *
 * 输出： 7
 *
 * 解释：
 *
 * 7 的二进制表示是 "111"。
 *
 *
 * 示例 2：
 *
 *
 * 输入： n = 10
 *
 * 输出： 15
 *
 * 解释：
 *
 * 15 的二进制表示是 "1111"。
 *
 *
 * 示例 3：
 *
 *
 * 输入： n = 3
 *
 * 输出： 3
 *
 * 解释：
 *
 * 3 的二进制表示是 "11"。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= n <= 1000
 *
 *
 */

// @lc code=start
var smallestNumber = function (n: number): number {
  // 初始化结果为1，表示第一个全1二进制数（二进制：1）
  let x = 1;

  // 循环构造全1的二进制数，直到大于等于n
  // 每次循环：x = x * 2 + 1
  // 相当于在二进制表示中左移一位并在最低位添加1
  // 例如：1(1) -> 3(11) -> 7(111) -> 15(1111) -> 31(11111) -> ...
  while (x < n) {
    x = x * 2 + 1;
  }

  // 返回找到的第一个大于等于n的全1二进制数
  return x;
};
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 找到大于等于 n 的最小的"全1二进制数"
   - 全1二进制数是指二进制表示中所有位都是1的数，例如：1(1), 11(3), 111(7), 1111(15), 11111(31)...
   - 这些数的规律是：2^k - 1，其中 k 是二进制位数

2. 算法分析：
   - 时间复杂度：O(log n) - 循环次数等于 n 的二进制位数
   - 空间复杂度：O(1) - 只使用常量额外空间
   - 算法类型：位运算、数学规律

3. 解题思路：

   核心思想：
   - 全1二进制数序列：1, 3, 7, 15, 31, 63, 127, 255...
   - 每个数都可以表示为 2^k - 1
   - 通过迭代生成这个序列，直到找到第一个大于等于 n 的数

   算法步骤：
   1. 初始化 x = 1（也可以用 x = 0，因为 0 * 2 + 1 = 1）
   2. 循环执行 x = x * 2 + 1，生成全1二进制数序列
   3. 当 x >= n 时停止循环
   4. 返回 x

   关键观察：
   - x * 2 + 1 的位运算含义：
     * x * 2 相当于左移一位（二进制）
     * +1 相当于在最低位添加一个1
     * 从 x = 1 开始：1 -> 3(11) -> 7(111) -> 15(1111)
     * 从 x = 0 开始：0 -> 1(1) -> 3(11) -> 7(111) -> 15(1111)
   
   为什么两种初始化都可以？
   - x = 0 时：第一次循环会得到 0 * 2 + 1 = 1，然后正常迭代
   - x = 1 时：直接从第一个全1二进制数开始，少一次循环（当 n = 1 时）
   - 两者结果相同，但 x = 1 更直观且效率略高（省略一次无意义的循环）

4. 实现要点：

   数据结构选择：
   - 只需要一个整数变量 x 来存储当前生成的全1二进制数
   - 不需要额外的数据结构

   迭代公式：
   - x = x * 2 + 1
   - 这个公式巧妙地生成了全1二进制数序列
   - 避免了使用位运算符和复杂的数学计算

   边界条件：
   - 当 n 本身就是全1二进制数时，直接返回 n
   - 题目保证 1 <= n <= 1000，不需要处理负数或0

5. 示例分析：

   示例1：n = 5
   方式1（x = 1）：
   - 初始：x = 1，1 < 5，继续
   - 第1轮：x = 1 * 2 + 1 = 3，3 < 5，继续
   - 第2轮：x = 3 * 2 + 1 = 7，7 >= 5，停止
   - 返回：7 (二进制：111)
   
   方式2（x = 0）：
   - 初始：x = 0，0 < 5，继续
   - 第1轮：x = 0 * 2 + 1 = 1，1 < 5，继续
   - 第2轮：x = 1 * 2 + 1 = 3，3 < 5，继续
   - 第3轮：x = 3 * 2 + 1 = 7，7 >= 5，停止
   - 返回：7 (二进制：111)
   
   可以看到，x = 0 只是多了一轮循环将 0 变成 1，结果完全相同

   示例2：n = 10
   - 初始：x = 1，1 < 10，继续
   - 第1轮：x = 3，3 < 10，继续
   - 第2轮：x = 7，7 < 10，继续
   - 第3轮：x = 15，15 >= 10，停止
   - 返回：15 (二进制：1111)

   示例3：n = 3
   - 初始：x = 1，1 < 3，继续
   - 第1轮：x = 3，3 >= 3，停止
   - 返回：3 (二进制：11)
   
   特殊情况：n = 1
   - 若 x = 1：1 >= 1，直接返回 1（无需循环）
   - 若 x = 0：0 < 1，执行一轮 x = 0 * 2 + 1 = 1，返回 1
   - 这就是为什么 x = 1 更高效的原因

6. 算法要点总结：

   核心技巧：
   - 利用数学规律生成全1二进制数序列
   - 使用迭代而非复杂的位运算
   - 公式 x = x * 2 + 1 简洁高效

   优化要点：
   - 避免了计算 n 的二进制位数
   - 避免了使用位运算符（如 << 和 |）
   - 代码简洁易懂，性能优秀
   - 初始化为 x = 1 比 x = 0 略优（少一次循环）

   初始值的选择：
   - x = 1：语义清晰，表示从第一个全1二进制数开始
   - x = 0：数学上通用，因为公式会自动生成正确序列
   - 推荐使用 x = 1，更直观且效率更高

   类似问题：
   - 找到小于等于 n 的最大全1二进制数
   - 判断一个数是否是全1二进制数
   - 计算需要多少位才能表示 n

7. 常见错误：

   错误1：使用位运算直接计算
   ```typescript
   // 可能会想到这样做，但实际上更复杂
   const bits = Math.floor(Math.log2(n)) + 1;
   return (1 << bits) - 1;
   ```
   - 需要处理 n 恰好是 2^k - 1 的情况
   - 使用对数计算可能有精度问题

   错误2：忘记处理 n 本身就是全1二进制数的情况
   - 当前算法自然处理了这种情况，因为循环条件是 x < n

8. 扩展思考：

   方法二：使用位运算
   ```typescript
   function smallestNumber(n: number): number {
     // 计算 n 的二进制位数
     let bits = 0;
     let temp = n;
     while (temp > 0) {
       bits++;
       temp >>= 1;
     }
     
     // 生成 bits 位的全1二进制数
     let result = (1 << bits) - 1;
     
     // 如果结果小于 n，需要再增加一位
     if (result < n) {
       result = (1 << (bits + 1)) - 1;
     }
     
     return result;
   }
   ```
   - 这种方法需要先计算位数，相对复杂
   - 当前的迭代方法更简洁直观

   变种问题：
   - 如果要求小于等于 n 的最大全1二进制数，只需修改循环条件为 x * 2 + 1 <= n
   - 如果要求恰好大于 n 的最小全1二进制数，循环条件改为 x <= n
*/
