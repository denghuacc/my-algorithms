/*
 * @lc app=leetcode.cn id=2169 lang=typescript
 *
 * [2169] 得到 0 的操作数
 *
 * https://leetcode.cn/problems/count-operations-to-obtain-zero/description/
 *
 * algorithms
 * Easy (73.51%)
 * Likes:    36
 * Dislikes: 0
 * Total Accepted:    28.8K
 * Total Submissions: 38.4K
 * Testcase Example:  '2\n3'
 *
 * 给你两个 非负 整数 num1 和 num2 。
 *
 * 每一步 操作 中，如果 num1 >= num2 ，你必须用 num1 减 num2 ；否则，你必须用 num2 减 num1 。
 *
 *
 * 例如，num1 = 5 且 num2 = 4 ，应该用 num1 减 num2 ，因此，得到 num1 = 1 和 num2 = 4 。然而，如果
 * num1 = 4且 num2 = 5 ，一步操作后，得到 num1 = 4 和 num2 = 1 。
 *
 *
 * 返回使 num1 = 0 或 num2 = 0 的 操作数 。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：num1 = 2, num2 = 3
 * 输出：3
 * 解释：
 * - 操作 1 ：num1 = 2 ，num2 = 3 。由于 num1 < num2 ，num2 减 num1 得到 num1 = 2 ，num2 =
 * 3 - 2 = 1 。
 * - 操作 2 ：num1 = 2 ，num2 = 1 。由于 num1 > num2 ，num1 减 num2 。
 * - 操作 3 ：num1 = 1 ，num2 = 1 。由于 num1 == num2 ，num1 减 num2 。
 * 此时 num1 = 0 ，num2 = 1 。由于 num1 == 0 ，不需要再执行任何操作。
 * 所以总操作数是 3 。
 *
 *
 * 示例 2：
 *
 *
 * 输入：num1 = 10, num2 = 10
 * 输出：1
 * 解释：
 * - 操作 1 ：num1 = 10 ，num2 = 10 。由于 num1 == num2 ，num1 减 num2 得到 num1 = 10 - 10
 * = 0 。
 * 此时 num1 = 0 ，num2 = 10 。由于 num1 == 0 ，不需要再执行任何操作。
 * 所以总操作数是 1 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 0 <= num1, num2 <= 10^5
 *
 *
 */

// @lc code=start
/**
 * 解法1: 模拟法
 * 按照题目要求，直接模拟每一步操作，每次用较大的数减去较小的数
 *
 * @timeComplexity O(max(num1, num2)) - 最坏情况下需要进行max(num1, num2)次操作
 * @spaceComplexity O(1) - 只使用常数级别的额外空间
 */
var countOperations = function (num1: number, num2: number): number {
  // 初始化操作计数器
  let cnt = 0;

  // 当两个数都不为0时，继续执行操作
  while (num1 !== 0 && num2 !== 0) {
    // 如果num1较大或相等，用num1减去num2
    if (num1 >= num2) {
      num1 -= num2;
    } else if (num2 >= num1) {
      // 如果num2较大，用num2减去num1
      num2 -= num1;
    }
    // 每次操作后计数器加1
    cnt++;
  }

  // 返回总操作数
  return cnt;
};

/**
 * 解法2: 优化的辗转相除法（类似欧几里得算法）
 * 使用除法和取模运算优化，一次性计算多次减法操作
 *
 * @timeComplexity O(log(min(num1, num2))) - 类似欧几里得算法的时间复杂度
 * @spaceComplexity O(1) - 只使用常数级别的额外空间
 */
var countOperations = function (num1: number, num2: number): number {
  // 初始化操作计数器
  let cnt = 0;

  // 当两个数都不为0时，继续执行操作
  while (num1 && num2) {
    // 用除法计算可以减多少次，相当于一次性执行多次减法操作
    // 例如：num1=10, num2=3，可以减3次，相当于执行了3次操作
    cnt += Math.floor(num1 / num2);

    // 计算余数，相当于执行完所有减法后num1的值
    num1 %= num2;

    // 交换num1和num2，确保下一轮num1是较大的数
    // 这样可以继续用除法优化
    [num1, num2] = [num2, num1];
  }

  // 返回总操作数
  return cnt;
};
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 这是一个模拟辗转相减的过程，类似于求最大公约数的辗转相减法
   - 每次操作都用较大的数减去较小的数，直到其中一个数变为0
   - 需要统计总共进行了多少次操作

2. 算法分析：
   - 时间复杂度：
     * 解法1（模拟法）：O(max(num1, num2)) - 最坏情况下每次只减1
     * 解法2（优化法）：O(log(min(num1, num2))) - 类似欧几里得算法
   - 空间复杂度：O(1) - 两种解法都只使用常数级别的额外空间
   - 算法类型：数学问题、模拟

3. 解题思路：

   【解法1：直接模拟】
   - 核心思想：按照题目要求，逐步模拟每一次操作
   - 实现步骤：
     1. 初始化操作计数器cnt为0
     2. 当两个数都不为0时，执行循环
     3. 比较num1和num2的大小，用较大的数减去较小的数
     4. 每次操作后计数器加1
     5. 当其中一个数变为0时，返回总操作数
   
   【解法2：优化的辗转相除法】
   - 核心思想：使用除法一次性计算多次减法操作，显著提高效率
   - 关键观察：如果num1=10, num2=3，连续减3次相当于10÷3=3次操作，余数为1
   - 实现步骤：
     1. 初始化操作计数器cnt为0
     2. 当两个数都不为0时，执行循环
     3. 用num1÷num2计算可以减多少次，加到cnt中
     4. 用num1%num2计算余数，更新num1
     5. 交换num1和num2，确保下一轮num1是较大的数
     6. 重复步骤3-5，直到其中一个数为0

4. 实现要点：

   【解法1的关键】：
   - 使用while循环模拟操作过程
   - 条件判断：num1 !== 0 && num2 !== 0
   - 每次操作只减一次，直观但效率较低

   【解法2的关键】：
   - 使用除法和取模优化：cnt += Math.floor(num1 / num2)
   - 交换num1和num2：[num1, num2] = [num2, num1]
   - 这个过程类似于欧几里得算法求最大公约数

5. 示例分析：

   【示例1：num1 = 2, num2 = 3】
   
   解法1的执行过程：
   - 初始：num1=2, num2=3, cnt=0
   - 操作1：2 < 3，num2减num1 → num1=2, num2=1, cnt=1
   - 操作2：2 > 1，num1减num2 → num1=1, num2=1, cnt=2
   - 操作3：1 == 1，num1减num2 → num1=0, num2=1, cnt=3
   - 结束：返回3
   
   解法2的执行过程：
   - 初始：num1=2, num2=3, cnt=0
   - 第1轮：2÷3=0次，余数2，交换 → num1=3, num2=2, cnt=0
   - 第2轮：3÷2=1次，余数1，交换 → num1=2, num2=1, cnt=1
   - 第3轮：2÷1=2次，余数0，交换 → num1=1, num2=0, cnt=3
   - 结束：返回3

   【示例2：num1 = 10, num2 = 10】
   
   解法1的执行过程：
   - 初始：num1=10, num2=10, cnt=0
   - 操作1：10 == 10，num1减num2 → num1=0, num2=10, cnt=1
   - 结束：返回1
   
   解法2的执行过程：
   - 初始：num1=10, num2=10, cnt=0
   - 第1轮：10÷10=1次，余数0 → cnt=1
   - 结束：返回1

6. 算法要点总结：

   【核心技巧】：
   - 解法1是最直观的模拟方法，易于理解但效率较低
   - 解法2利用除法和取模运算，将多次减法操作合并为一次计算
   - 交换操作确保每次都是用较大的数除以较小的数
   
   【优化要点】：
   - 解法2的优化思路：如果num1=100, num2=3，与其减33次，不如直接用除法计算
   - 时间复杂度从O(n)降低到O(log n)，提升显著
   - 这种优化思想在辗转相减法转换为辗转相除法时也常用

   【类似问题】：
   - LeetCode 1979: 找出数组的最大公约数（使用欧几里得算法）
   - 辗转相减法和辗转相除法的应用
   - 数学模拟类问题

7. 常见错误：

   - 错误1：忘记处理num1==num2的情况
     * 解决：使用>=比较，或者在num1==num2时减法也能正确处理
   
   - 错误2：解法2中忘记交换num1和num2
     * 解决：每次取模后必须交换，确保下一轮除法能正常进行
   
   - 错误3：解法2中使用了错误的除法（未取整）
     * 解决：必须使用Math.floor()或者整数除法

8. 扩展思考：

   - 这道题的本质是辗转相减法，操作次数等于在求最大公约数过程中的减法次数
   - 解法2实际上是将辗转相减法优化为辗转相除法（欧几里得算法）
   - 当num1和num2互质时，操作次数最多；当num1==num2时，操作次数为1
   - 可以进一步思考：如果允许其他操作（如乘法、加法），如何优化？
*/
