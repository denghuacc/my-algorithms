/*
 * @lc app=leetcode.cn id=3190 lang=typescript
 *
 * [3190] 使所有元素都可以被 3 整除的最少操作数
 *
 * https://leetcode.cn/problems/find-minimum-operations-to-make-all-elements-divisible-by-three/description/
 *
 * algorithms
 * Easy (82.64%)
 * Likes:    7
 * Dislikes: 0
 * Total Accepted:    13.6K
 * Total Submissions: 15.9K
 * Testcase Example:  '[1,2,3,4]'
 *
 * 给你一个整数数组 nums 。一次操作中，你可以将 nums 中的 任意 一个元素增加或者减少 1 。
 *
 * 请你返回将 nums 中所有元素都可以被 3 整除的 最少 操作次数。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：nums = [1,2,3,4]
 *
 * 输出：3
 *
 * 解释：
 *
 * 通过以下 3 个操作，数组中的所有元素都可以被 3 整除：
 *
 *
 * 将 1 减少 1 。
 * 将 2 增加 1 。
 * 将 4 减少 1 。
 *
 *
 *
 * 示例 2：
 *
 *
 * 输入：nums = [3,6,9]
 *
 * 输出：0
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 50
 * 1 <= nums[i] <= 50
 *
 *
 */

// @lc code=start
/**
 * 统计需要调整的元素个数即可。
 *
 * @param nums - 原始数组，元素范围为 [1, 50]
 * @returns 使所有元素能被 3 整除的最少操作数
 */
function minimumOperations(nums: number[]): number {
  let res = 0;
  for (const num of nums) {
    // 余数为 1 或 2 的数字到最近的 3 的倍数距离都为 1
    if (num % 3 !== 0) res++;
  }
  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 将每个元素改成 3 的倍数，代价是对单个元素加 1 或减 1。
   - 任意整数除以 3 的余数为 0、1 或 2，与最近倍数的距离最多为 1。

2. 算法分析：
   - 时间复杂度：O(n)，只需线性遍历数组一次。
   - 空间复杂度：O(1)，使用常数额外变量。
   - 算法类型：计数 / 贪心，每个元素独立处理。

3. 解题思路：
   - 核心思想：余数为 0 的元素无需操作，余数为 1 或 2 的元素各需一次操作。
   - 推导过程：距离最近 3 的倍数的差值必为 0 或 1，因此最优策略是逐个就地调整。
   - 主要步骤概述：统计余数不为 0 的元素数量即可得到答案。

4. 实现要点：
   - 不必真的修改数组，计数即可。
   - 加 1 与减 1 都可行，保证余数为 1、2 的元素只需一次操作。
   - 输入范围小，但线性扫描已经最优。

5. 算法优势：
   - 常数空间、单次遍历，代码直接、易于验证。
   - 利用模 3 的性质，无需额外数据结构。

6. 核心算法步骤：
   - 步骤一：初始化计数器 res 为 0。
   - 步骤二：遍历数组，若 num % 3 !== 0，则 res++。
   - 步骤三：返回 res。

7. 示例分析：
   - 示例一 [1,2,3,4]：余数为 [1,2,0,1]，非 0 余数有 3 个，答案 3。
   - 示例二 [3,6,9]：余数全为 0，无需操作，答案 0。
   - 示例三 [2,5,11]：余数为 [2,2,2]，都需一次调整，答案 3。

8. 常见错误：
   - 误认为余数为 2 需要两次操作，忽略了可以直接 +1。
   - 只考虑向上取整，忽略可以减 1，导致多算操作数。
   - 把多个元素的调整绑定在一起，实际上每个元素独立处理最优。

10. 扩展思考：
   - 类似问题：统一到任意模数的倍数时，可直接看各余数到最近倍数的最短距离。
   - 变种：若操作只能单向或次数有限，需要再结合贪心或动态规划分配操作。
*/
