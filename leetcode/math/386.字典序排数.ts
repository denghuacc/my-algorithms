/*
 * @lc app=leetcode.cn id=386 lang=typescript
 *
 * [386] 字典序排数
 *
 * https://leetcode-cn.com/problems/lexicographical-numbers/description/
 *
 * algorithms
 * Medium (76.08%)
 * Likes:    280
 * Dislikes: 0
 * Total Accepted:    36.1K
 * Total Submissions: 47.4K
 * Testcase Example:  '13'
 *
 * 给你一个整数 n ，按字典序返回范围 [1, n] 内所有整数。
 *
 * 你必须设计一个时间复杂度为 O(n) 且使用 O(1) 额外空间的算法。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：n = 13
 * 输出：[1,10,11,12,13,2,3,4,5,6,7,8,9]
 *
 *
 * 示例 2：
 *
 *
 * 输入：n = 2
 * 输出：[1,2]
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= n <= 5 * 10^4
 *
 *
 */

// @lc code=start
// math
function lexicalOrder(n: number): number[] {
  // 初始化结果数组，长度为 n
  const res: number[] = new Array(n).fill(0);

  // 从 1 开始，按字典序遍历
  let cur = 1;

  for (let i = 0; i < n; i++) {
    // 将当前数字加入结果
    res[i] = cur;

    // 优先选择在当前数字后面添加 0（即乘以 10）
    // 这相当于在字典树中深度优先遍历，优先往下走
    if (cur * 10 <= n) {
      cur *= 10;
    } else {
      // 如果不能再往下走，需要找到下一个字典序数字

      // 处理两种情况：
      // 1. 当前数字末位是 9，需要回退到上一层
      // 2. 当前数字已经达到 n，也需要回退
      while (cur % 10 === 9 || cur >= n) {
        cur = Math.floor(cur / 10); // 回退到上一层（除以 10）
      }

      // 移动到同层的下一个数字（加 1）
      cur += 1;
    }
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 需要按字典序（而非数字大小顺序）输出 [1, n] 范围内的所有整数
   - 字典序：按字符串比较规则排序，如 "10" < "2"，所以 10 排在 2 前面
   - 要求 O(n) 时间复杂度和 O(1) 额外空间复杂度

2. 算法分析：
   - 时间复杂度：O(n) - 每个数字只访问一次
   - 空间复杂度：O(1) - 除了结果数组，只使用常量额外空间
   - 算法类型：数学规律 + 深度优先搜索思想

3. 核心思想：
   将问题转化为在一个字典树（Trie）上的深度优先遍历：
   ```
       1    2    3  ...  9
      /|\  /|\  /|\ 
    10 11 12 20 21 22 30 31 32
   /|\ 
  100 101 102
   ```
   
   按照 DFS 的顺序遍历这棵树，就能得到字典序排列

4. 实现要点：
   - **优先向下**：如果 cur * 10 <= n，就乘以 10（往更深层走）
   - **无法向下时向右**：在同一层找下一个节点（cur + 1）
   - **向右前的回退**：如果末位是 9 或达到边界，需要先回到上层
   
   核心逻辑的两个分支：
   ```
   if (cur * 10 <= n):
       cur *= 10          # 深度优先，往下走
   else:
       while (cur % 10 == 9 or cur >= n):
           cur //= 10     # 回退到上层
       cur += 1           # 移动到兄弟节点
   ```

5. 示例分析（n = 13）：
   ```
   初始: cur = 1
   步骤1: res[0] = 1, cur = 1*10 = 10
   步骤2: res[1] = 10, cur = 10+1 = 11  
   步骤3: res[2] = 11, cur = 11+1 = 12
   步骤4: res[3] = 12, cur = 12+1 = 13
   步骤5: res[4] = 13, cur >= 13 && cur%10!=9, cur = 13//10 = 1, cur = 1+1 = 2
   步骤6: res[5] = 2, cur = 2*10 = 20 > 13, cur%10!=9, cur = 2+1 = 3
   ...以此类推
   ```
   最终结果：[1,10,11,12,13,2,3,4,5,6,7,8,9]

6. 关键观察：
   - 字典序本质上是字符串的字典序，而不是数值大小顺序
   - 可以将问题映射到树的 DFS 遍历
   - 通过数学运算（*10, /10, +1）模拟树的遍历过程
   - 边界条件处理：末位为 9 的数字和达到上限 n 的数字

7. 优化要点：
   - 避免真正构建字典树，用数学运算模拟遍历过程
   - 一次遍历完成，无需递归调用
   - 原地生成下一个字典序数字，实现 O(1) 空间复杂度
*/
