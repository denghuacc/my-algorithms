/*
 * @lc app=leetcode.cn id=342 lang=typescript
 *
 * [342] 4的幂
 *
 * https://leetcode-cn.com/problems/power-of-four/description/
 *
 * algorithms
 * Easy (51.53%)
 * Likes:    205
 * Dislikes: 0
 * Total Accepted:    54.5K
 * Total Submissions: 105.8K
 * Testcase Example:  '16'
 *
 * 给定一个整数，写一个函数来判断它是否是 4 的幂次方。如果是，返回 true ；否则，返回 false 。
 *
 * 整数 n 是 4 的幂次方需满足：存在整数 x 使得 n == 4^x
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：n = 16
 * 输出：true
 *
 *
 * 示例 2：
 *
 *
 * 输入：n = 5
 * 输出：false
 *
 *
 * 示例 3：
 *
 *
 * 输入：n = 1
 * 输出：true
 *
 *
 *
 *
 * 提示：
 *
 *
 * -2^31
 *
 *
 *
 *
 * 进阶：
 *
 *
 * 你能不使用循环或者递归来完成本题吗？
 *
 *
 */

// @lc code=start
/**
 * 方法一：数学方法 - 循环除法
 * 时间复杂度：O(log n)
 * 空间复杂度：O(1)
 */
function isPowerOfFourMath(n: number): boolean {
  // 排除非正数
  if (n <= 0) return false;

  // 持续除以4，直到无法整除
  while (n % 4 === 0) {
    n /= 4;
  }

  // 如果最终结果为1，说明原数是4的幂
  return n === 1;
}

/**
 * 方法二：位运算优化
 * 时间复杂度：O(1)
 * 空间复杂度：O(1)
 *
 * 核心思想：
 * 1. 4的幂必须是2的幂：n & (n-1) === 0
 * 2. 4的幂在二进制中1的位置必须在奇数位上(从右往左第1,3,5...位)
 * 3. 利用数学性质：4^k % 3 === 1 来区分4的幂和其他2的幂
 */
function isPowerOfFour(n: number): boolean {
  return (
    n > 0 && // 必须是正数
    (n & (n - 1)) === 0 && // 必须是2的幂
    n % 3 === 1
  ); // 4的幂对3取模必为1
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 判断一个整数是否为4的幂次方
   - 需要满足：存在整数x使得n = 4^x
   - 要求进阶：不使用循环或递归

2. 算法分析：

   方法一：数学方法（循环除法）
   - 时间复杂度：O(log n) - 需要log₄(n)次除法操作
   - 空间复杂度：O(1) - 只使用常数额外空间
   - 算法类型：迭代法

   方法二：位运算优化
   - 时间复杂度：O(1) - 常数时间内完成判断
   - 空间复杂度：O(1) - 只使用常数额外空间
   - 算法类型：位运算 + 数学性质

3. 实现要点：

   方法一核心步骤：
   - 首先排除非正数（4的幂必须为正数）
   - 持续除以4，直到不能整除为止
   - 检查最终结果是否为1

   方法二关键观察：
   - 4的幂必须首先是2的幂：用 n & (n-1) === 0 判断
   - 4的幂在二进制表示中，1只能出现在奇数位置（从右往左数第1,3,5...位）
   - 数学性质：4^k ≡ 1 (mod 3)，即4的任何次幂除以3的余数都是1
   
   为什么4^k % 3 === 1？
   - 4 ≡ 1 (mod 3)，因为4 = 3×1 + 1
   - 所以4^k ≡ 1^k ≡ 1 (mod 3)
   - 而2的幂（非4的幂）：2^(2k+1) ≡ 2 (mod 3)

4. 示例分析：

   n = 16 的判断过程：
   - 方法一：16 → 4 → 1 ✓
   - 方法二：16 > 0 ✓，16 & 15 = 0 ✓，16 % 3 = 1 ✓

   n = 8 的判断过程：
   - 是2的幂：8 & 7 = 0 ✓
   - 但不是4的幂：8 % 3 = 2 ≠ 1 ✗

   二进制表示分析：
   - 1 = 4^0 → 1₂ (第1位)
   - 4 = 4^1 → 100₂ (第3位)
   - 16 = 4^2 → 10000₂ (第5位)
   - 64 = 4^3 → 1000000₂ (第7位)

5. 边界情况：
   - n ≤ 0：直接返回false
   - n = 1：是4^0，返回true
   - n = 2,8,32...：是2的幂但不是4的幂，返回false

6. 优化要点：
   - 方法二避免了循环，实现O(1)时间复杂度
   - 利用位运算的高效性
   - 巧妙运用数学性质简化判断条件
   - 三个条件的短路求值提高效率

7. 类似问题：
   - 231. 2的幂
   - 326. 3的幂
   - 判断其他数的幂次方

8. 常见错误：
   - 忘记处理n ≤ 0的情况
   - 误以为所有2的幂都是4的幂
   - 不理解为什么4^k % 3 === 1这个数学性质
*/
