/*
 * @lc app=leetcode.cn id=2787 lang=typescript
 *
 * [2787] 将一个数字表示成幂的和的方案数
 *
 * https://leetcode.cn/problems/ways-to-express-an-integer-as-sum-of-powers/description/
 *
 * algorithms
 * Medium (50.34%)
 * Likes:    51
 * Dislikes: 0
 * Total Accepted:    20.4K
 * Total Submissions: 38.2K
 * Testcase Example:  '10\n2'
 *
 * 给你两个 正 整数 n 和 x 。
 *
 * 请你返回将 n 表示成一些 互不相同 正整数的 x 次幂之和的方案数。换句话说，你需要返回互不相同整数 [n1, n2, ..., nk]
 * 的集合数目，满足 n = n1^x + n2^x + ... + nk^x 。
 *
 * 由于答案可能非常大，请你将它对 10^9 + 7 取余后返回。
 *
 * 比方说，n = 160 且 x = 3 ，一个表示 n 的方法是 n = 2^3 + 3^3 + 5^3^ 。
 *
 *
 *
 * 示例 1：
 *
 * 输入：n = 10, x = 2
 * 输出：1
 * 解释：我们可以将 n 表示为：n = 3^2 + 1^2 = 10 。
 * 这是唯一将 10 表达成不同整数 2 次方之和的方案。
 *
 *
 * 示例 2：
 *
 * 输入：n = 4, x = 1
 * 输出：2
 * 解释：我们可以将 n 按以下方案表示：
 * - n = 4^1 = 4 。
 * - n = 3^1 + 1^1 = 4 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= n <= 300
 * 1 <= x <= 5
 *
 *
 */

// @lc code=start
function numberOfWays(n: number, x: number): number {
  const MOD = 1e9 + 7;

  // dp[i] 表示组成数字 i 的方案数
  const dp = new Array(n + 1).fill(0);

  // 初始化：组成 0 的方案数为 1（不选任何数字）
  dp[0] = 1;

  // 枚举每个可能的基数 i，计算 i^x
  for (let i = 1; i <= n; i++) {
    const cur = Math.pow(i, x); // 当前基数的 x 次幂

    // 如果当前幂次已经超过 n，后续更大的数字也不需要考虑
    if (cur > n) break;

    // 倒序遍历，避免重复使用同一个数字
    // 对于每个目标值 j，考虑是否选择当前的 i^x
    for (let j = n; j >= cur; j--) {
      // 状态转移：dp[j] = 不选 i^x 的方案数 + 选择 i^x 的方案数
      dp[j] = (dp[j] + dp[j - cur]) % MOD;
    }
  }

  return dp[n];
}
// @lc code=end

// 导出函数以避免未使用警告
export { numberOfWays };

/*
解题思路详解：

1. 问题本质：
   - 这是一个背包问题的变种，需要在互不相同的正整数中选择一些数字
   - 使得这些数字的 x 次幂之和等于目标值 n
   - 求满足条件的方案总数

2. 算法分析：
   - 时间复杂度：O(n * √n)，其中 √n 是因为 i^x ≤ n，所以 i ≤ n^(1/x)
   - 空间复杂度：O(n)，使用一维 dp 数组
   - 算法类型：动态规划（01背包问题变种）

3. 实现要点：
   - 使用一维 dp 数组，dp[i] 表示组成数字 i 的方案数
   - 对每个可能的基数 i，计算其 x 次幂作为"物品重量"
   - 采用倒序遍历避免重复使用同一个数字（01背包经典技巧）
   - 状态转移方程：dp[j] = dp[j] + dp[j - i^x]
   
4. 核心思想：
   - 将问题转化为：有若干个"物品"（1^x, 2^x, 3^x, ...）
   - 每个物品只能选择一次，求装满容量为 n 的背包的方案数
   - 使用动态规划逐步构建解决方案

5. 边界情况处理：
   - dp[0] = 1：不选任何数字组成 0 的方案数为 1
   - 当 i^x > n 时提前终止，因为更大的数字无法使用
   - 使用模运算避免整数溢出

6. 优化要点：
   - 倒序遍历确保每个数字最多使用一次
   - 提前终止条件减少不必要的计算
   - 使用一维数组优化空间复杂度
*/
