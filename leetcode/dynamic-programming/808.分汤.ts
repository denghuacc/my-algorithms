/*
 * @lc app=leetcode.cn id=808 lang=typescript
 *
 * [808] 分汤
 *
 * https://leetcode.cn/problems/soup-servings/description/
 *
 * algorithms
 * Medium (48.54%)
 * Likes:    113
 * Dislikes: 0
 * Total Accepted:    9K
 * Total Submissions: 16.5K
 * Testcase Example:  '50'
 *
 * 有 A 和 B 两种类型 的汤。一开始每种类型的汤有 n 毫升。有四种分配操作：
 *
 *
 * 提供 100ml 的 汤A 和 0ml 的 汤B 。
 * 提供 75ml 的 汤A 和 25ml 的 汤B 。
 * 提供 50ml 的 汤A 和 50ml 的 汤B 。
 * 提供 25ml 的 汤A 和 75ml 的 汤B 。
 *
 *
 * 当我们把汤分配给某人之后，汤就没有了。每个回合，我们将从四种概率同为 0.25
 * 的操作中进行分配选择。如果汤的剩余量不足以完成某次操作，我们将尽可能分配。当两种类型的汤都分配完时，停止操作。
 *
 * 注意 不存在先分配 100 ml 汤B 的操作。
 *
 * 需要返回的值： 汤A 先分配完的概率 +  汤A和汤B 同时分配完的概率 / 2。返回值在正确答案 10^-5 的范围内将被认为是正确的。
 *
 *
 *
 * 示例 1:
 *
 *
 * 输入: n = 50
 * 输出: 0.62500
 * 解释:如果我们选择前两个操作，A 首先将变为空。
 * 对于第三个操作，A 和 B 会同时变为空。
 * 对于第四个操作，B 首先将变为空。
 * 所以 A 变为空的总概率加上 A 和 B 同时变为空的概率的一半是 0.25 *(1 + 1 + 0.5 + 0)= 0.625。
 *
 *
 * 示例 2:
 *
 *
 * 输入: n = 100
 * 输出: 0.71875
 *
 *
 *
 *
 * 提示:
 *
 *
 * 0 <= n <= 10^9​​​​​​​
 *
 *
 */

// @lc code=start
// dp
function soupServings(n: number): number {
  // 将毫升数按 25ml 为一份进行离散化，四种操作分别对应 (4,0),(3,1),(2,2),(1,3)
  n = Math.ceil(n / 25);
  // 当 n 足够大时，A 先空的概率会非常接近 1（极限为 1），
  // 经验阈值 n >= 179 时误差已小于 1e-5，可直接返回 1.0
  if (n >= 179) {
    return 1.0;
  }
  // dp[i][j]: 汤 A 和汤 B 分别剩下 i 与 j 份（每份 25ml）时，
  //           所求概率 P(A 先空) + 0.5 * P(A、B 同时空)
  const dp: number[][] = Array.from(new Array(n + 1), () =>
    new Array(n + 1).fill(0)
  );
  // 边界初始化：
  // 1) dp[0][0] = 0.5  （A、B 同时空）
  dp[0][0] = 0.5;
  // 2) dp[0][j>0] = 1.0（A 先空）
  for (let i = 1; i <= n; i++) {
    dp[0][i] = 1.0;
  }
  // 对于 dp[i>0][0] 默认是 0.0（B 先空），已由初始化填充为 0

  // 状态转移：
  // 从 (i,j) 出发，等概率选择四种操作：
  // (i-4,j)、(i-3,j-1)、(i-2,j-2)、(i-1,j-3)，不足 0 时按 0 处理（尽可能分配）。
  // dp[i][j] = 1/4 * Σ dp[next_i][next_j]
  for (let i = 1; i <= n; i++) {
    for (let j = 1; j <= n; j++) {
      dp[i][j] =
        (dp[Math.max(0, i - 4)][j] +
          dp[Math.max(0, i - 3)][Math.max(0, j - 1)] +
          dp[Math.max(0, i - 2)][Math.max(0, j - 2)] +
          dp[Math.max(0, i - 1)][Math.max(0, j - 3)]) /
        4.0;
    }
  }
  // 目标：起点 (n,n)
  return dp[n][n];
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 模拟随机过程下的概率计算：四种等概率操作消耗 A、B 的汤量，直至至少一种为空。
   - 需要的量为 P(A 先空) + 0.5 * P(AB 同时空)。

2. 算法分析：
   - 算法类型：动态规划（自底向上）/ 概率 DP。
   - 状态定义：dp[i][j] 表示 A、B 分别剩 i、j 份（25ml 为 1 份）时的答案。
   - 转移方程：
     dp[i][j] = 1/4 * [
       dp[max(0,i-4)][j] +
       dp[max(0,i-3)][max(0,j-1)] +
       dp[max(0,i-2)][max(0,j-2)] +
       dp[max(0,i-1)][max(0,j-3)]
     ]
   - 边界条件：
     - dp[0][0] = 0.5（同时空）
     - dp[0][j>0] = 1.0（A 先空）
     - dp[i>0][0] = 0.0（B 先空）
   - 时间复杂度：O(n^2)，其中 n = ceil(N/25)。
   - 空间复杂度：O(n^2)。

3. 实现要点：
   - 将毫升数按 25ml 归一化，四种操作正好对应减少份数 (4,0)、(3,1)、(2,2)、(1,3)。
   - 处理“尽可能分配”即下界取 0：索引使用 Math.max(0, ·)。
   - 使用经验阈值 n >= 179（原始毫升约 >= 4475）直接返回 1.0，保证误差 < 1e-5。

4. 优化思路：
   - 可改为记忆化 DFS，自然地处理边界与裁剪，代码更简洁；复杂度量级相同。
   - 更激进的空间优化较难，因为转移不满足简单的滚动数组依赖。

5. 边界情况：
   - N = 0：缩放后 n = 0，答案为 dp[0][0] = 0.5。
   - 极大 N：直接命中阈值分支，返回 1.0。

6. 常见错误：
   - 忘记先将 N 按 25 归一化，导致状态空间巨大。
   - 边界条件写错：dp[0][0] 应为 0.5，dp[0][j>0] 为 1.0，dp[i>0][0] 为 0.0。
   - 未按“尽可能分配”处理负索引，需对下标取 0。
*/
