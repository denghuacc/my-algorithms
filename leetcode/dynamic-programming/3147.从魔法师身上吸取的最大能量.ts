/*
 * @lc app=leetcode.cn id=3147 lang=typescript
 *
 * [3147] 从魔法师身上吸取的最大能量
 *
 * https://leetcode.cn/problems/taking-maximum-energy-from-the-mystic-dungeon/description/
 *
 * algorithms
 * Medium (46.86%)
 * Likes:    19
 * Dislikes: 0
 * Total Accepted:    13.2K
 * Total Submissions: 23.2K
 * Testcase Example:  '[5,2,-10,-5,1]\n3'
 *
 * 在神秘的地牢中，n 个魔法师站成一排。每个魔法师都拥有一个属性，这个属性可以给你提供能量。有些魔法师可能会给你负能量，即从你身上吸取能量。
 *
 * 你被施加了一种诅咒，当你从魔法师 i 处吸收能量后，你将被立即传送到魔法师 (i + k) 处。这一过程将重复进行，直到你到达一个不存在 (i + k)
 * 的魔法师为止。
 *
 * 换句话说，你将选择一个起点，然后以 k 为间隔跳跃，直到到达魔法师序列的末端，在过程中吸收所有的能量。
 *
 * 给定一个数组 energy 和一个整数k，返回你能获得的 最大 能量。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入： energy = [5,2,-10,-5,1], k = 3
 *
 * 输出： 3
 *
 * 解释：可以从魔法师 1 开始，吸收能量 2 + 1 = 3。
 *
 *
 * 示例 2：
 *
 *
 * 输入： energy = [-2,-3,-1], k = 2
 *
 * 输出： -1
 *
 * 解释：可以从魔法师 2 开始，吸收能量 -1。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= energy.length <= 10^5
 * -1000 <= energy[i] <= 1000
 * 1 <= k <= energy.length - 1
 *
 *
 *
 *
 */

// @lc code=start

/**
 * 从魔法师身上吸取的最大能量 - 动态规划 + 贪心思想
 *
 * 核心思想：
 * 1. 从后往前遍历，对于每个可能的起点，计算能获得的最大能量
 * 2. 关键观察：只需要考虑最后k个位置作为起点（因为从这些位置开始能走完整的路径）
 * 3. 对于每个起点，按k的间隔向前跳跃，累积能量并记录最大值
 */
function maximumEnergy(energy: number[], k: number): number {
  const n = energy.length;
  let res = -Infinity;

  // 只考虑最后k个位置作为起点
  // 原因：从这些位置开始，可以按k间隔向前跳跃到数组开头
  for (let i = n - k; i < n; i++) {
    let sum = 0; // 当前路径的能量累积
    let j = i; // 当前位置

    // 从位置i开始，向前按k间隔跳跃
    while (j >= 0) {
      sum += energy[j]; // 吸收当前魔法师的能量
      j -= k; // 跳跃到前一个位置（向前k步）

      // 更新全局最大能量
      // 注意：每一步都可能是最优的终点，所以每次都要更新
      res = Math.max(res, sum);
    }
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 在数组中选择一个起点，按固定间隔k跳跃
   - 目标：最大化跳跃路径上所有元素的和
   - 约束：只能向前跳跃（i → i+k），直到超出数组边界

2. 核心观察：
   - 不同的起点会形成不同的跳跃序列
   - 由于只能向前跳，实际上存在多个独立的"链条"
   - 每个链条的起点位置满足：i % k 相同

3. 关键洞察 - 为什么从后往前？：
   - 正向思考：从位置i开始，序列为 i → i+k → i+2k → ...
   - 反向思考：从位置i结束，序列为 ... → i-2k → i-k → i
   - 反向更容易处理：从每个可能的终点向前构建路径

4. 算法分析：
   时间复杂度：O(n) - 每个元素最多被访问一次
   空间复杂度：O(1) - 只使用常数额外空间

5. 为什么只考虑最后k个位置？：
   - 数组被k分割成k个独立的子序列
   - 子序列0：0, k, 2k, 3k, ...
   - 子序列1：1, k+1, 2k+1, 3k+1, ...
   - ...
   - 子序列k-1：k-1, 2k-1, 3k-1, ...
   
   每个子序列的最后一个元素位置在[n-k, n-1]范围内

6. 示例分析 - energy = [5,2,-10,-5,1], k = 3：
   
   数组分组（按 i % k）：
   - 组0 (i%3=0): [5(0), -5(3)]    → 路径: 5 + (-5) = 0
   - 组1 (i%3=1): [2(1), 1(4)]     → 路径: 2 + 1 = 3  
   - 组2 (i%3=2): [-10(2)]         → 路径: -10
   
   从后往前遍历 i ∈ [n-k, n-1] = [2, 4]：
   
   i=2: 路径 2 → (2-3)=-1(越界) 
   - sum = -10，res = max(-∞, -10) = -10
   
   i=3: 路径 3 → 0
   - j=3: sum = -5，res = max(-10, -5) = -5
   - j=0: sum = -5 + 5 = 0，res = max(-5, 0) = 0
   
   i=4: 路径 4 → 1
   - j=4: sum = 1，res = max(0, 1) = 1
   - j=1: sum = 1 + 2 = 3，res = max(1, 3) = 3
   
   最终答案：3

7. 动态规划思想体现：
   - 每个位置的最优解依赖于前一个位置的结果
   - dp[i] 表示从位置i开始能获得的最大能量
   - 状态转移：dp[i] = energy[i] + max(0, dp[i+k])
   - 本解法是逆向的递推，避免了额外空间

8. 为什么每一步都要更新res？：
   - 允许在任意位置结束跳跃（提前终止）
   - 如果后续路径能量为负，提前结束可能更优
   - 这体现了贪心思想：在每个位置都考虑是否继续

9. 边界情况处理：
   - k = 1：相当于找数组的最大子数组和（可以在任意位置开始和结束）
   - k = n-1：只能比较第一个元素和最后一个元素
   - 全负数数组：返回单个元素的最大值

10. 算法优势：
    - 一次遍历解决问题
    - 空间复杂度优化到O(1)
    - 逻辑清晰，易于理解和实现

11. 类似问题扩展：
    - 最大子数组和（Kadane算法）
    - 跳跃游戏问题
    - 动态规划中的路径选择问题

12. 实际应用场景：
    - 游戏中的跳跃路径优化
    - 资源采集路径规划
    - 周期性数据的最优选择策略
*/
