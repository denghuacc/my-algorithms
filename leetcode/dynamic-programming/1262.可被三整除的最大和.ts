/*
 * @lc app=leetcode.cn id=1262 lang=typescript
 *
 * [1262] 可被三整除的最大和
 *
 * https://leetcode.cn/problems/greatest-sum-divisible-by-three/description/
 *
 * algorithms
 * Medium (52.69%)
 * Likes:    253
 * Dislikes: 0
 * Total Accepted:    26.1K
 * Total Submissions: 48.1K
 * Testcase Example:  '[3,6,5,1,8]'
 *
 * 给你一个整数数组 nums，请你找出并返回能被三整除的元素最大和。
 *
 *
 *
 *
 *
 *
 * 示例 1：
 *
 * 输入：nums = [3,6,5,1,8]
 * 输出：18
 * 解释：选出数字 3, 6, 1 和 8，它们的和是 18（可被 3 整除的最大和）。
 *
 * 示例 2：
 *
 * 输入：nums = [4]
 * 输出：0
 * 解释：4 不能被 3 整除，所以无法选出数字，返回 0。
 *
 *
 * 示例 3：
 *
 * 输入：nums = [1,2,3,4,4]
 * 输出：12
 * 解释：选出数字 1, 3, 4 以及 4，它们的和是 12（可被 3 整除的最大和）。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= nums.length <= 4 * 10^4
 * 1 <= nums[i] <= 10^4
 *
 *
 */

// @lc code=start
/**
 * 以模 3 的余数作为状态的动态规划，维护可达到的最大和。
 *
 * @param nums - 输入数组，每个元素在 [1, 1e4]
 * @returns 能被 3 整除的最大子序列和
 */
function maxSumDivThree(nums: number[]): number {
  let f = [0, -Infinity, -Infinity]; // f[i] 表示当前和 % 3 为 i 的最大值
  for (const num of nums) {
    const next = [...f]; // 复制一份，避免同轮次更新相互影响
    const remainder = num % 3;
    for (let i = 0; i < 3; i++) {
      // 将 num 追加到余数为 i 的和上，落入的新余数 bucket
      const idx = (i + remainder) % 3;
      next[idx] = Math.max(next[idx], f[i] + num);
    }
    f = next;
  }
  return f[0];
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 从数组中选出若干数字，使它们的和能被 3 整除且尽量大。
   - 只关心和的模 3 余数，所以可以用有限状态表达所有可能。

2. 算法分析：
   - 时间复杂度：O(n)，每个元素更新 3 个状态。
   - 空间复杂度：O(1)，常数级状态数组。
   - 算法类型：动态规划，按余数分类的状态压缩。

3. 解题思路：
   - 核心思想：维护长度为 3 的状态数组 f，f[r] 是当前和模 3 等于 r 的
     最大值。三种余数组合即可覆盖所有选择情况。
   - 推导过程：遍历每个 num，将它加到三种余数和上，得到新余数并取
     最大。
   - 主要步骤概述：初始化 f=[0,-∞,-∞]，依次更新 next，循环结束返回 f[0]。

4. 实现要点：
   - 复制出 next，防止同一轮的更新被后续使用导致重复加数。
   - 余数计算使用 (i + num % 3) % 3，映射到新 bucket。
   - 结果为 f[0]，表示和能被 3 整除的最大值。

5. 算法优势（可选）
   - 状态空间只有 3，时间与空间都很友好。
   - 直接处理子序列（可跳过元素），无需排序或回溯。

6. 核心算法步骤（可选）
   - 初始化 f。
   - 对每个 num：复制 f 到 next，枚举三种余数更新 next。
   - 覆盖 f=next，最后输出 f[0]。

7. 示例分析
   - 示例一 nums=[3,6,5,1,8]：
     - 初始 f=[0,-∞,-∞]。
     - 加 3：next=[3,-∞,-∞]；加 6：next=[9,-∞,-∞]。
     - 加 5：可以从 f[0] 得到余 2 的 14；当前最好 f=[9,-∞,14]。
     - 加 1：从 14 得到余 0 的 15，f=[15,10,14]。
     - 加 8：从 14 得到余 2 的 22，f=[18,23,22]，答案 18。
   - 边界情况：若没有任何组合能被 3 整除，f[0] 会保持初始 0，符合题意。

8. 常见错误
   - 更新时直接在 f 上改值，会导致同一元素被重复使用，需用副本。
   - 忘记初始化 f[0]=0、其他为 -∞，会错误地允许未选择元素的非零余数
     组合。
   - 余数计算遗漏第二次取模，导致下标越界或错误 bucket。

10. 扩展思考
   - 可扩展到“能被 k 整除的最大和”，状态数组长度为 k，更新逻辑类似。
   - 也可用于求最大子序列和 mod k 的指定余数，只需返回对应的 f[r]。
*/
