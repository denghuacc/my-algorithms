/*
 * @lc app=leetcode.cn id=1277 lang=typescript
 *
 * [1277] 统计全为 1 的正方形子矩阵
 *
 * https://leetcode.cn/problems/count-square-submatrices-with-all-ones/description/
 *
 * algorithms
 * Medium (74.94%)
 * Likes:    364
 * Dislikes: 0
 * Total Accepted:    46.3K
 * Total Submissions: 61K
 * Testcase Example:  '[[0,1,1,1],[1,1,1,1],[0,1,1,1]]'
 *
 * 给你一个 m * n 的矩阵，矩阵中的元素不是 0 就是 1，请你统计并返回其中完全由 1 组成的 正方形 子矩阵的个数。
 *
 *
 *
 * 示例 1：
 *
 * 输入：matrix =
 * [
 * [0,1,1,1],
 * [1,1,1,1],
 * [0,1,1,1]
 * ]
 * 输出：15
 * 解释：
 * 边长为 1 的正方形有 10 个。
 * 边长为 2 的正方形有 4 个。
 * 边长为 3 的正方形有 1 个。
 * 正方形的总数 = 10 + 4 + 1 = 15.
 *
 *
 * 示例 2：
 *
 * 输入：matrix =
 * [
 * ⁠ [1,0,1],
 * ⁠ [1,1,0],
 * ⁠ [1,1,0]
 * ]
 * 输出：7
 * 解释：
 * 边长为 1 的正方形有 6 个。
 * 边长为 2 的正方形有 1 个。
 * 正方形的总数 = 6 + 1 = 7.
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= arr.length <= 300
 * 1 <= arr[0].length <= 300
 * 0 <= arr[i][j] <= 1
 *
 *
 */

// @lc code=start
/**
 * 统计矩阵中全为1的正方形子矩阵的个数
 * @param matrix 输入矩阵，只包含0和1
 * @returns 返回所有全1正方形子矩阵的数量
 */
function countSquares(matrix: number[][]): number {
  // 获取矩阵的行数和列数
  const m = matrix.length;
  const n = matrix[0].length;

  // dp[i][j] 表示以(i,j)为右下角的最大正方形边长
  const dp: number[][] = Array.from({ length: m }, () => Array(n).fill(0));

  // 计数所有满足条件的正方形子矩阵
  let cnt = 0;

  // 遍历矩阵中的每个位置
  for (let i = 0; i < m; i++) {
    for (let j = 0; j < n; j++) {
      // 只有当前位置是1时才可能形成正方形
      if (matrix[i][j] === 1) {
        if (i === 0 || j === 0) {
          // 边界情况：第一行或第一列的位置，最大正方形边长只能是1
          dp[i][j] = 1;
        } else {
          // 状态转移：当前位置的最大正方形边长取决于左、上、左上三个位置的最小值加1
          // 这是因为要保证正方形的所有位置都是1
          dp[i][j] =
            Math.min(
              dp[i - 1][j], // 上方位置的最大正方形边长
              dp[i][j - 1], // 左方位置的最大正方形边长
              dp[i - 1][j - 1] // 左上方位置的最大正方形边长
            ) + 1;
        }
        // dp[i][j]的值代表了以(i,j)为右下角的正方形的边长
        // 同时也代表了以这个点为右下角可以形成的正方形的数量
        cnt += dp[i][j];
      }
      // 如果matrix[i][j]是0，dp[i][j]保持为0，因为不能形成正方形
    }
  }

  return cnt;
}
// @lc code=end

/*
解题思路：

1. 题目理解
---------------------
问题本质：
- 在一个二维矩阵中找出所有由1组成的正方形子矩阵
- 需要统计所有可能的大小的正方形（1x1, 2x2, 3x3等）
- 每个正方形必须完全由1组成

关键特点：
- 矩阵元素只包含0和1
- 正方形的定义：边长相等的矩形
- 需要统计所有大小的正方形
- 同一个1可能属于多个不同大小的正方形

2. 解题思路
---------------------
核心思想：
使用动态规划，对于矩阵中的每个位置(i,j)，计算以它为右下角的最大正方形边长。
这个值同时代表了以这个位置为右下角可以形成的正方形数量。

状态定义：
- dp[i][j] 表示以位置(i,j)为右下角，且只包含1的正方形的最大边长

状态转移方程：
如果 matrix[i][j] = 1：
- 当 i = 0 或 j = 0 时：dp[i][j] = 1
- 否则：dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
如果 matrix[i][j] = 0：
- dp[i][j] = 0

算法步骤：
1. 初始化dp数组，大小与输入矩阵相同
2. 遍历矩阵中的每个位置：
   - 如果当前位置是0，dp值为0
   - 如果当前位置是1：
     - 如果在第一行或第一列，dp值为1
     - 否则，取左、上、左上三个位置的最小值加1
3. 累加所有dp值得到结果

示例分析：
对于矩阵：
[
  [1,1,1],
  [1,1,1],
  [1,1,1]
]

dp数组的演变过程：
[
  [1,1,1],
  [1,2,2],
  [1,2,3]
]

以dp[2][2]=3为例：
- 表示以(2,2)为右下角可以形成1x1、2x2、3x3三个正方形
- 贡献了3个正方形到最终计数

3. 复杂度分析
---------------------
时间复杂度：O(m*n)
- 需要遍历整个矩阵一次
- 每个位置的计算是O(1)的

空间复杂度：O(m*n)
- 需要一个和输入矩阵同样大小的dp数组
- 不考虑输出占用的空间

4. 边界情况
---------------------
1. 矩阵只有一个元素：
   - 如果是1，返回1
   - 如果是0，返回0
2. 矩阵全是0：返回0
3. 矩阵全是1：返回所有可能的正方形数量
4. 矩阵只有一行或一列：最大正方形边长为1

5. 优化思路
---------------------
1. 空间优化：
   - 可以复用输入矩阵作为dp数组，将空间复杂度降为O(1)
   - 但这样会修改输入数据，需要根据具体要求决定

2. 代码优化：
   - 可以合并边界条件的处理
   - 当matrix[i][j]=0时可以跳过计算
   
3. 扩展思考：
   - 这个解法可以扩展到统计矩形子矩阵的问题
   - 可以用来解决最大正方形子矩阵的问题
*/
