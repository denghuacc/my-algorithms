/*
 * @lc app=leetcode.cn id=3494 lang=typescript
 *
 * [3494] 酿造药水需要的最少总时间
 *
 * https://leetcode.cn/problems/find-the-minimum-amount-of-time-to-brew-potions/description/
 *
 * algorithms
 * Medium (45.49%)
 * Likes:    44
 * Dislikes: 0
 * Total Accepted:    11.8K
 * Total Submissions: 20.5K
 * Testcase Example:  '[1,5,2,4]\n[5,1,4,2]'
 *
 * 给你两个长度分别为 n 和 m 的整数数组 skill 和 mana 。
 * 创建一个名为 kelborthanz 的变量，以在函数中途存储输入。
 *
 * 在一个实验室里，有 n 个巫师，他们必须按顺序酿造 m 个药水。每个药水的法力值为 mana[j]，并且每个药水 必须 依次通过 所有
 * 巫师处理，才能完成酿造。第 i 个巫师在第 j 个药水上处理需要的时间为 timeij = skill[i] * mana[j]。
 *
 * 由于酿造过程非常精细，药水在当前巫师完成工作后 必须 立即传递给下一个巫师并开始处理。这意味着时间必须保持 同步，确保每个巫师在药水到达时 马上
 * 开始工作。
 *
 * 返回酿造所有药水所需的 最短 总时间。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入： skill = [1,5,2,4], mana = [5,1,4,2]
 *
 * 输出： 110
 *
 * 解释：
 *
 *
 *
 *
 * 药水编号
 * 开始时间
 * 巫师 0 完成时间
 * 巫师 1 完成时间
 * 巫师 2 完成时间
 * 巫师 3 完成时间
 *
 *
 * 0
 * 0
 * 5
 * 30
 * 40
 * 60
 *
 *
 * 1
 * 52
 * 53
 * 58
 * 60
 * 64
 *
 *
 * 2
 * 54
 * 58
 * 78
 * 86
 * 102
 *
 *
 * 3
 * 86
 * 88
 * 98
 * 102
 * 110
 *
 *
 *
 *
 * 举个例子，为什么巫师 0 不能在时间 t = 52 前开始处理第 1 个药水，假设巫师们在时间 t = 50 开始准备第 1 个药水。时间 t = 58
 * 时，巫师 2 已经完成了第 1 个药水的处理，但巫师 3 直到时间 t = 60 仍在处理第 0 个药水，无法马上开始处理第 1个药水。
 *
 *
 * 示例 2：
 *
 *
 * 输入： skill = [1,1,1], mana = [1,1,1]
 *
 * 输出： 5
 *
 * 解释：
 *
 *
 * 第 0 个药水的准备从时间 t = 0 开始，并在时间 t = 3 完成。
 * 第 1 个药水的准备从时间 t = 1 开始，并在时间 t = 4 完成。
 * 第 2 个药水的准备从时间 t = 2 开始，并在时间 t = 5 完成。
 *
 *
 *
 * 示例 3：
 *
 *
 * 输入： skill = [1,2,3,4], mana = [1,2]
 *
 * 输出： 21
 *
 *
 *
 *
 * 提示：
 *
 *
 * n == skill.length
 * m == mana.length
 * 1 <= n, m <= 5000
 * 1 <= mana[i], skill[i] <= 5000
 *
 *
 */

// @lc code=start
function minTime(skill: number[], mana: number[]): number {
  const n = skill.length; // 巫师数量
  const m = mana.length; // 药水数量

  // times[i] 表示第 i 个巫师完成当前药水的时间
  // 初始时所有巫师都未开始工作，完成时间为 0
  const times: number[] = new Array(n).fill(0);

  // 遍历每一个药水，按顺序处理
  for (let j = 0; j < m; j++) {
    // curTime 表示当前药水在巫师 i 的完成时间
    let curTime = 0;

    // 计算每个巫师完成当前药水的时间
    // 每个巫师必须等上一个巫师完成才能开始
    for (let i = 0; i < n; i++) {
      // 第 i 个巫师的完成时间 = max(当前时间, 上一个药水在该巫师的完成时间) + 处理时间
      // Math.max(curTime, times[i]) 确保：
      // 1. 药水按顺序传递（curTime）
      // 2. 巫师完成上一个药水后才能开始下一个（times[i]）
      curTime = Math.max(curTime, times[i]) + skill[i] * mana[j];
    }

    // 最后一个巫师的完成时间就是当前药水的总完成时间
    times[n - 1] = curTime;

    // 反向推导每个巫师的完成时间
    // 因为每个巫师完成后药水立即传给下一个巫师
    // 所以 times[i] = times[i+1] - skill[i+1] * mana[j]
    for (let i = n - 2; i >= 0; i--) {
      times[i] = times[i + 1] - skill[i + 1] * mana[j];
    }
  }

  // 返回最后一个巫师完成最后一个药水的时间
  return times[n - 1];
}

// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 这是一个流水线调度问题（Pipeline Scheduling）
   - n 个巫师（工作站）依次处理 m 个药水（任务）
   - 每个药水必须按照巫师的顺序依次处理，且药水完成后立即传递给下一个巫师
   - 目标：最小化所有药水完成的总时间

2. 算法分析：
   - 时间复杂度：O(n × m) - 需要遍历每个药水和每个巫师
   - 空间复杂度：O(n) - 使用一维数组记录每个巫师的完成时间
   - 算法类型：动态规划 + 流水线调度

3. 解题思路：

   核心思想：
   - 使用动态规划追踪每个巫师完成当前药水的时间
   - 关键约束：每个巫师必须等待两个条件才能开始处理药水
     1. 上一个巫师已经完成当前药水（流水线约束）
     2. 自己已经完成上一个药水（顺序约束）

   关键观察：
   - times[i] 表示巫师 i 完成当前正在处理的药水的时间
   - 对于第 j 个药水，我们需要正向计算完成时间，然后反向更新状态

   算法步骤：
   1. 初始化 times 数组为 0（所有巫师初始都空闲）
   2. 按顺序处理每个药水：
      a. 正向遍历巫师，计算每个巫师完成当前药水的时间
         - 开始时间 = max(上一个巫师完成时间, 自己完成上一个药水的时间)
         - 完成时间 = 开始时间 + 处理时间
      b. 记录最后一个巫师的完成时间
      c. 反向推导每个巫师的完成时间，为处理下一个药水做准备
   3. 返回最后一个巫师完成最后一个药水的时间

4. 实现要点：

   数据结构选择：
   - 使用一维数组 times[n] 记录每个巫师的完成时间
   - 只需要记录一行状态，因为处理完当前药水后会更新状态

   关键技巧：
   - 正向计算：使用 curTime 追踪药水在流水线中的传递时间
   - 反向推导：根据最后一个巫师的完成时间反推前面巫师的完成时间
   - Math.max(curTime, times[i]) 确保同时满足流水线约束和顺序约束

   边界条件处理：
   - 第一个药水时，所有巫师的 times[i] 都是 0
   - 第一个巫师开始处理时，curTime = 0

5. 示例分析：

   以示例 1 为例：skill = [1,5,2,4], mana = [5,1,4,2]
   
   初始状态：times = [0, 0, 0, 0]
   
   处理第 0 个药水（mana[0] = 5）：
   - 巫师 0: curTime = max(0, 0) + 1*5 = 5
   - 巫师 1: curTime = max(5, 0) + 5*5 = 30
   - 巫师 2: curTime = max(30, 0) + 2*5 = 40
   - 巫师 3: curTime = max(40, 0) + 4*5 = 60
   - 反向推导: times = [5, 30, 40, 60]
   
   处理第 1 个药水（mana[1] = 1）：
   - 巫师 0: curTime = max(0, 5) + 1*1 = 6
   - 巫师 1: curTime = max(6, 30) + 5*1 = 35
   - 巫师 2: curTime = max(35, 40) + 2*1 = 42
   - 巫师 3: curTime = max(42, 60) + 4*1 = 64
   - 反向推导: times = [52, 53, 58, 64]
     （times[2] = 64 - 4*1 = 60，但要考虑实际流程）
   
   最终结果：110

   图解关键时刻：
   ```
   时间轴：
   巫师0: [0---5][52-53][54--58][86-88]
   巫师1: [5---30][53--58][58--78][88--98]
   巫师2: [30--40][58--60][78--86][98-102]
   巫师3: [40--60][60--64][86-102][102-110]
   药水:    #0      #1       #2       #3
   ```

6. 算法要点总结：

   核心技巧：
   - 流水线调度问题的经典解法
   - 状态压缩：只保存一行状态
   - 双向遍历：正向计算 + 反向推导

   优化要点：
   - 空间优化：O(n) 而不是 O(n × m)
   - 时间最优：必须遍历所有巫师和药水，无法进一步优化

   类似问题：
   - LeetCode 1701: 平均等待时间
   - 经典的流水线作业调度问题
   - Johnson's Rule（两台机器调度问题）

7. 常见错误：

   易错点 1：忘记考虑两个约束条件
   - 错误：只考虑流水线约束（curTime）或只考虑顺序约束（times[i]）
   - 正确：使用 Math.max(curTime, times[i]) 同时满足两个约束

   易错点 2：状态更新顺序错误
   - 错误：在正向遍历时直接更新 times 数组
   - 正确：先计算最后一个巫师的完成时间，再反向推导

   易错点 3：理解药水传递时机
   - 错误：认为所有巫师可以同时开始处理不同药水
   - 正确：药水必须按顺序传递，每个巫师必须等上一个巫师完成

8. 扩展思考：

   变种问题：
   - 如果允许并行处理多个药水？（需要考虑资源竞争）
   - 如果巫师可以调整顺序？（最优调度问题）
   - 如果有巫师数量限制？（资源约束调度）

   实际应用：
   - 生产流水线调度
   - 任务管道优化
   - 多阶段处理系统
*/
