/*
 * @lc app=leetcode.cn id=1039 lang=typescript
 *
 * [1039] 多边形三角剖分的最低得分
 *
 * https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/description/
 *
 * algorithms
 * Medium (57.68%)
 * Likes:    161
 * Dislikes: 0
 * Total Accepted:    10.5K
 * Total Submissions: 17.3K
 * Testcase Example:  '[1,2,3]'
 *
 * 你有一个凸的 n 边形，其每个顶点都有一个整数值。给定一个整数数组 values ，其中 values[i] 是第 i 个顶点的值（即 顺时针顺序
 * ）。
 *
 * 假设将多边形 剖分 为 n - 2 个三角形。对于每个三角形，该三角形的值是顶点标记的乘积，三角剖分的分数是进行三角剖分后所有 n - 2
 * 个三角形的值之和。
 *
 * 返回 多边形进行三角剖分后可以得到的最低分 。
 *
 *
 *
 *
 *
 * 示例 1：
 *
 *
 *
 *
 * 输入：values = [1,2,3]
 * 输出：6
 * 解释：多边形已经三角化，唯一三角形的分数为 6。
 *
 *
 * 示例 2：
 *
 *
 *
 *
 * 输入：values = [3,7,4,5]
 * 输出：144
 * 解释：有两种三角剖分，可能得分分别为：3*7*5 + 4*5*7 = 245，或 3*4*5 + 3*4*7 = 144。最低分数为 144。
 *
 *
 * 示例 3：
 *
 *
 *
 *
 * 输入：values = [1,3,1,4,1,5]
 * 输出：13
 * 解释：最低分数三角剖分的得分情况为 1*1*3 + 1*1*4 + 1*1*5 + 1*1*1 = 13。
 *
 *
 *
 *
 * 提示：
 *
 *
 * n == values.length
 * 3 <= n <= 50
 * 1 <= values[i] <= 100
 *
 *
 */

// @lc code=start
/**
 * 多边形三角剖分的最低得分 - 区间动态规划
 *
 * 核心思想：将大问题分解为子问题，对于区间[i,j]，枚举所有可能的分割点k
 * 将多边形分为三部分：三角形(i,k,j) + 子多边形[i,k] + 子多边形[k,j]
 */
function minScoreTriangulation(values: number[]): number {
  const n = values.length;
  // 使用Map存储已计算的子问题结果，避免重复计算
  const memo = new Map<number, number>();

  // 计算整个多边形[0, n-1]的最低得分
  return dp(0, n - 1);

  /**
   * 计算区间[i, j]内顶点形成的子多边形的最低三角剖分得分
   * @param i 起始顶点索引
   * @param j 结束顶点索引
   * @returns 该区间的最低得分
   */
  function dp(i: number, j: number): number {
    // 基础情况1：顶点数少于3个，无法形成三角形
    if (i + 2 > j) {
      return 0;
    }

    // 基础情况2：正好3个顶点，直接计算三角形得分
    if (i + 2 === j) {
      return values[i] * values[i + 1] * values[j];
    }

    // 生成唯一的键值，用于记忆化搜索
    const key = i * n + j;

    // 如果子问题已经计算过，直接返回结果
    if (!memo.has(key)) {
      let minScore = Infinity;

      // 状态转移：枚举所有可能的分割点k (i < k < j)
      // 将多边形分为：三角形(i,k,j) + 子多边形[i,k] + 子多边形[k,j]
      for (let k = i + 1; k < j; k++) {
        // 当前分割方案的总得分 = 三角形得分 + 左子问题得分 + 右子问题得分
        const currentScore =
          values[i] * values[k] * values[j] + // 三角形(i,k,j)的得分
          dp(i, k) + // 子多边形[i,k]的最低得分
          dp(k, j); // 子多边形[k,j]的最低得分

        // 取所有分割方案中的最小值
        minScore = Math.min(minScore, currentScore);
      }

      // 将计算结果存入备忘录
      memo.set(key, minScore);
    }

    return memo.get(key)!;
  }
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 将n边形剖分为n-2个三角形，使得所有三角形得分之和最小
   - 每个三角形的得分 = 三个顶点值的乘积
   - 这是一个典型的区间动态规划问题

2. 算法分析：
   - 时间复杂度：O(n³) - 三重循环：区间长度 × 起点 × 分割点
   - 空间复杂度：O(n²) - 记忆化存储O(n²)个子问题
   - 算法类型：区间动态规划 + 记忆化搜索

3. 核心思想 - 区间DP：
   - 状态定义：dp(i,j) = 顶点i到顶点j形成的子多边形的最低剖分得分
   - 状态转移：枚举所有可能的"最后一个三角形"
   - 分割策略：选择中间顶点k，形成三角形(i,k,j)，剩余两个子多边形递归处理

4. 算法步骤详解：
   
   ### 状态定义：
   ```
   dp(i,j) = 区间[i,j]内顶点组成的子多边形的最低三角剖分得分
   ```
   
   ### 状态转移方程：
   ```
   dp(i,j) = min{values[i]*values[k]*values[j] + dp(i,k) + dp(k,j)}
             k∈(i+1, j-1)
   ```
   
   ### 边界条件：
   - 顶点数 < 3：dp(i,j) = 0 （无法形成三角形）
   - 顶点数 = 3：dp(i,j) = values[i] * values[i+1] * values[j]

5. 算法执行过程示例：
   
   以 values = [3,7,4,5] 为例：
   ```
   原始多边形：
        0(3)
       /    \
      /      \
   3(5)------1(7)
      \      /
       \    /
        2(4)
   
   目标：找到最优剖分方案
   
   dp(0,3) - 计算整个四边形的最低得分：
   
   尝试k=1: 三角形(0,1,3) + dp(0,1) + dp(1,3)
   - 三角形(0,1,3): 3*7*5 = 105
   - dp(0,1): 0 (只有2个顶点)
   - dp(1,3): 7*4*5 = 140 (三角形1,2,3)
   - 总得分: 105 + 0 + 140 = 245
   
   尝试k=2: 三角形(0,2,3) + dp(0,2) + dp(2,3)  
   - 三角形(0,2,3): 3*4*5 = 60
   - dp(0,2): 3*7*4 = 84 (三角形0,1,2)
   - dp(2,3): 0 (只有2个顶点)
   - 总得分: 60 + 84 + 0 = 144
   
   最优方案：k=2，总得分144
   ```

6. 实现要点：
   
   ### 记忆化优化：
   - 使用Map存储已计算的子问题结果
   - 键值设计：key = i * n + j，确保唯一性
   - 避免重复计算，提高效率
   
   ### 递归边界处理：
   - i+2 > j：顶点数不足3个，返回0
   - i+2 = j：正好3个顶点，直接计算三角形得分
   
   ### 状态转移枚举：
   - 遍历所有可能的分割点k ∈ (i+1, j-1)
   - 每次分割产生一个三角形和两个子问题
   - 选择使总得分最小的分割方案

7. 几何直观理解：
   
   ### 三角剖分的性质：
   - n边形总是可以剖分为n-2个三角形
   - 每条对角线将多边形分为两个更小的多边形
   - 不同的剖分方案对应不同的得分
   
   ### 区间DP的几何意义：
   - 区间[i,j]对应多边形上从顶点i到顶点j的弧段
   - 选择分割点k相当于添加对角线(i,j)和选择三角形(i,k,j)
   - 子问题[i,k]和[k,j]对应分割后的两个子多边形

8. 复杂度分析：
   
   ### 时间复杂度推导：
   - 状态数量：O(n²) 个不同的区间[i,j]
   - 每个状态的计算：O(n) 次枚举分割点
   - 总时间复杂度：O(n³)
   
   ### 空间复杂度推导：
   - 记忆化存储：O(n²) 个子问题结果
   - 递归调用栈：O(n) 深度
   - 总空间复杂度：O(n²)

9. 算法优势：
   - 自顶向下的记忆化搜索，思路清晰
   - 避免了重复计算，效率较高
   - 代码实现相对简洁
   - 易于理解和调试

10. 扩展思考：
    - 可以改写为自底向上的迭代DP版本
    - 对于更大的数据规模，可以考虑优化常数因子
    - 类似问题：矩阵链乘法、最优二叉搜索树等区间DP问题
    
11. 常见错误：
    - 遗漏边界条件的处理
    - 状态转移中的索引边界错误
    - 记忆化的键值设计不当导致冲突
    - 理解错误：混淆子多边形的顶点范围
*/
