/*
 * @lc app=leetcode.cn id=3186 lang=typescript
 *
 * [3186] 施咒的最大总伤害
 *
 * https://leetcode.cn/problems/maximum-total-damage-with-spell-casting/description/
 *
 * algorithms
 * Medium (36.14%)
 * Likes:    89
 * Dislikes: 0
 * Total Accepted:    26.4K
 * Total Submissions: 63.4K
 * Testcase Example:  '[1,1,3,4]'
 *
 * 一个魔法师有许多不同的咒语。
 *
 * 给你一个数组 power ，其中每个元素表示一个咒语的伤害值，可能会有多个咒语有相同的伤害值。
 *
 * 已知魔法师使用伤害值为 power[i] 的咒语时，他们就 不能 使用伤害为 power[i] - 2 ，power[i] - 1 ，power[i]
 * + 1 或者 power[i] + 2 的咒语。
 *
 * 每个咒语最多只能被使用 一次 。
 *
 * 请你返回这个魔法师可以达到的伤害值之和的 最大值 。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：power = [1,1,3,4]
 *
 * 输出：6
 *
 * 解释：
 *
 * 可以使用咒语 0，1，3，伤害值分别为 1，1，4，总伤害值为 6 。
 *
 *
 * 示例 2：
 *
 *
 * 输入：power = [7,1,6,6]
 *
 * 输出：13
 *
 * 解释：
 *
 * 可以使用咒语 1，2，3，伤害值分别为 1，6，6，总伤害值为 13 。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= power.length <= 10^5
 * 1 <= power[i] <= 10^9
 *
 *
 */

// @lc code=start
function maximumTotalDamage(power: number[]): number {
  // 1. 统计每个伤害值出现的次数
  // 使用哈希表记录每个咒语伤害值的频次，因为相同伤害的咒语可以一起使用
  const cnt = new Map<number, number>();
  for (const p of power) {
    cnt.set(p, (cnt.get(p) ?? 0) + 1);
  }

  // 2. 构建去重后的伤害值数组，并添加一个虚拟的起始点
  // vet[i] = [伤害值, 该伤害值的出现次数]
  // 添加 [-1e10, 0] 作为虚拟起点，方便DP初始化
  const vet: [number, number][] = [[-1e10, 0]];

  // 将所有不同的伤害值排序后存入数组
  const keys = Array.from(cnt.keys()).sort((a, b) => a - b);
  for (const k of keys) {
    vet.push([k, cnt.get(k)!]);
  }

  const n = vet.length;

  // 3. dp[i] 表示考虑前 i 个不同的伤害值时，能获得的最大总伤害
  const dp = new Array(n).fill(0);

  // maxVal 维护 dp[1...j-1] 中的最大值，用于状态转移
  let maxVal = 0;

  // res 记录全局最大伤害值
  let res = 0;

  // j 指针指向最后一个满足 vet[j][0] + 2 < vet[i][0] 的位置
  // 即找到所有可以和当前咒语 i 一起使用的咒语
  let j = 1;

  // 4. 动态规划求解
  for (let i = 1; i < n; i++) {
    // 使用双指针维护合法的转移区间
    // 当 vet[j][0] + 2 < vet[i][0] 时，说明咒语 j 可以和咒语 i 一起使用
    // 因为 power[j] 和 power[i] 的差距超过2，不会相互冲突
    while (j < i && vet[j][0] + 2 < vet[i][0]) {
      // 更新前面所有合法位置的最大DP值
      maxVal = Math.max(maxVal, dp[j]);
      j++;
    }

    // 状态转移：选择当前咒语 i
    // dp[i] = 所有合法前驱状态的最大值 + 当前咒语的总伤害
    // vet[i][0] * vet[i][1] 表示使用所有伤害值为 vet[i][0] 的咒语
    dp[i] = maxVal + vet[i][0] * vet[i][1];

    // 更新全局最大值
    res = Math.max(res, dp[i]);
  }

  return res;
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 这是一个带约束的选择问题：选择咒语使总伤害最大，但不能选择伤害值相差在 [-2, 2] 范围内的咒语
   - 类似于"打家劫舍"问题的变种，但约束条件更复杂
   - 关键特点：相同伤害值的咒语可以全部使用（不冲突）

2. 算法分析：
   - 时间复杂度：O(n log n)
     * 统计频次：O(n)
     * 排序：O(k log k)，其中 k 是不同伤害值的数量，k ≤ n
     * DP遍历：O(k)，双指针技巧保证每个位置最多访问一次
     * 总体：O(n + k log k + k) = O(n log n)
   
   - 空间复杂度：O(k)
     * 哈希表存储频次：O(k)
     * vet 数组：O(k)
     * dp 数组：O(k)
     * 其中 k 是不同伤害值的数量
   
   - 算法类型：动态规划 + 双指针优化

3. 核心思路：

   (1) 问题转化：
       - 原问题：从 power 数组中选择若干个元素，使得任意两个选中元素的差值不在 [-2, 2] 范围内
       - 转化后：将相同值合并后排序，问题变为在有序数组中选择不冲突的元素组合

   (2) 状态定义：
       - dp[i]：考虑前 i 个不同的伤害值，能获得的最大总伤害
       - 注意：这里的 i 是指排序后不同伤害值的索引，不是原数组索引

   (3) 状态转移：
       - 对于位置 i，有两种选择：
         a) 不选择当前咒语：dp[i] 继承之前的最优值
         b) 选择当前咒语：dp[i] = max(dp[j]) + power[i] * count[i]
            其中 j 满足 power[j] + 2 < power[i]（不冲突的位置）
       
       - 本题使用双指针优化：
         * 维护指针 j，表示最后一个可以转移的位置
         * 维护 maxVal = max(dp[1], dp[2], ..., dp[j-1])
         * 当处理位置 i 时，移动 j 直到 power[j] + 2 >= power[i]
         * 此时 maxVal 就是所有合法前驱状态的最大值

4. 算法步骤：

   步骤1：统计每个伤害值的出现次数
   - 使用哈希表 cnt 记录每个伤害值的频次
   - 相同伤害的咒语可以全部使用，因为它们之间不冲突

   步骤2：构建排序后的伤害值数组
   - 提取所有不同的伤害值并排序
   - 构建 vet 数组，每个元素是 [伤害值, 出现次数]
   - 添加虚拟起点 [-1e10, 0] 简化边界处理

   步骤3：动态规划求解
   - 使用双指针技巧优化状态转移
   - 对每个位置 i，找到所有满足 power[j] + 2 < power[i] 的 j
   - 从这些 j 中选择 dp 值最大的进行转移

   步骤4：返回全局最大值

5. 示例分析：

   示例1：power = [1,1,3,4]
   
   初始化：
   - cnt = {1: 2, 3: 1, 4: 1}
   - vet = [[-1e10, 0], [1, 2], [3, 1], [4, 1]]
   
   DP过程：
   i=1, power=1:
     - j=1, maxVal=0
     - dp[1] = 0 + 1*2 = 2
     - res = 2
   
   i=2, power=3:
     - 3-2=1 ≤ 1，所以 j 不能移动
     - maxVal = 0（j=1之前的最大值）
     - dp[2] = 0 + 3*1 = 3
     - res = 3
   
   i=3, power=4:
     - 4-2=2 > 1，可以移动 j
     - j=1: 1+2=3 < 4，可以用，maxVal = max(0, dp[1]) = 2
     - j=2: 3+2=5 ≥ 4，停止
     - dp[3] = 2 + 4*1 = 6
     - res = 6
   
   返回：6 ✓

   示例2：power = [7,1,6,6]
   
   初始化：
   - cnt = {7: 1, 1: 1, 6: 2}
   - vet = [[-1e10, 0], [1, 1], [6, 2], [7, 1]]
   
   DP过程：
   i=1, power=1: dp[1] = 0 + 1*1 = 1
   i=2, power=6: 
     - 6-2=4 > 1，j可以移动到2
     - maxVal = dp[1] = 1
     - dp[2] = 1 + 6*2 = 13
   i=3, power=7:
     - 7-2=5 < 6，j不能移动
     - maxVal = 1（j=2之前）
     - dp[3] = 1 + 7*1 = 8
   
   返回：max(13, 8) = 13 ✓

6. 关键优化点：

   (1) 频次统计：
       - 相同伤害值的咒语不冲突，可以全部选择
       - 通过统计频次，将问题规模从 n 降低到 k（不同值的个数）

   (2) 排序处理：
       - 排序后可以使用双指针维护合法转移区间
       - 避免了每次都要遍历所有前驱状态

   (3) 双指针优化：
       - 维护指针 j 和最大值 maxVal，将状态转移从 O(k²) 优化到 O(k)
       - j 指针单调递增，每个位置最多访问一次

   (4) 虚拟起点：
       - 添加 [-1e10, 0] 简化边界处理
       - 保证第一个真实伤害值也能正常转移

7. 易错点：

   (1) 忘记统计频次：
       - 错误：只考虑每个不同伤害值出现一次
       - 正确：相同伤害的咒语可以全部使用

   (2) 约束条件理解错误：
       - 错误：认为是不能选择差值小于等于2的咒语
       - 正确：不能选择差值在 [-2, 2] 范围内的咒语（严格小于3）

   (3) 状态转移漏掉情况：
       - 需要考虑所有满足 power[j] + 2 < power[i] 的 j
       - 不是只考虑 i-1 或 i-3 的位置

   (4) 双指针使用不当：
       - j 指针应该单调递增，不应该回退
       - maxVal 需要随着 j 的移动而更新

8. 扩展思考：

   (1) 如果约束范围是 [-k, k] 怎么办？
       - 同样的思路，只需要修改判断条件为 power[j] + k < power[i]

   (2) 如果相同伤害的咒语也不能同时使用？
       - 不需要统计频次，直接对去重后的数组做DP

   (3) 如果要求最多选择 m 个咒语？
       - 需要增加一维状态：dp[i][j] 表示考虑前 i 个伤害值，选择 j 个咒语的最大伤害
       - 时间复杂度会变为 O(k * m)

   (4) 类似问题：
       - LeetCode 198. 打家劫舍（不能选相邻元素）
       - LeetCode 740. 删除并获得点数（与本题几乎相同）
       - LeetCode 213. 打家劫舍 II（环形数组）
       
9. 算法要点总结：

   核心技巧：
   - 频次统计 + 排序：将问题规模从 n 降低到 k
   - 动态规划：定义状态并找到状态转移方程
   - 双指针优化：维护合法转移区间，避免重复遍历
   - 空间换时间：使用哈希表和额外数组优化查询

   适用场景：
   - 带约束的选择问题
   - 需要在序列中选择不冲突的元素
   - 可以通过排序简化问题的场景
*/
