/*
 * @lc app=leetcode.cn id=3573 lang=typescript
 *
 * [3573] 买卖股票的最佳时机 V
 *
 * https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-v/description/
 *
 * algorithms
 * Medium (42.00%)
 * Likes:    226
 * Dislikes: 30
 * Total Accepted:    37.1K
 * Total Submissions: 70.1K
 * Testcase Example:  '[1,7,9,8,2]\n2'
 *
 * 给你一个整数数组 prices，其中 prices[i] 表示第 i 天的股价（美元），以及
 * 整数 k。
 *
 * 你最多可以进行 k 次交易，每次交易可以是以下两种之一：
 *
 *
 * 正常交易：在第 i 天买入，第 j 天卖出（i < j），利润为 prices[j] -
 * prices[i]。
 * 卖空交易：在第 i 天卖出，第 j 天回购（i < j），利润为 prices[i] -
 * prices[j]。
 *
 *
 * 注意：必须在开始下一笔交易前完成上一笔交易，且不能在同一天既作为
 * 上一笔的卖出/回购，又作为下一笔的买入/卖出。
 *
 * 返回最多进行 k 次交易能够获得的最大利润。
 *
 *
 * 示例 1：
 *
 *
 * 输入：prices = [1,7,9,8,2], k = 2
 * 输出：14
 * 解释：第 0 天买入第 2 天卖出赚 8；第 3 天卖空第 4 天回补赚 6，
 * 总利润 14。
 *
 *
 * 示例 2：
 *
 *
 * 输入：prices = [12,16,19,19,8,1,19,13,9], k = 3
 * 输出：36
 * 解释：按题述方案可在 3 笔交易内累计 36 的利润。
 *
 *
 *
 * 提示：
 *
 *
 * 2 <= prices.length <= 10^3
 * 1 <= prices[i] <= 10^9
 * 1 <= k <= prices.length / 2
 *
 *
 */

// @lc code=start
/**
 * 允许正常交易与卖空交易，至多 k 次，求可获得的最大利润。
 * 状态定义：0 空仓；1 持有多单；2 持有空单（等待回补）。
 *
 * @param prices - 每日股价，长度 n (2 <= n <= 1e3)。
 * @param k - 可交易次数上限。
 * @returns 最大可得收益。
 */
function maximumProfit(prices: number[], k: number): number {
  const n = prices.length;
  const dp = new Array(n);
  for (let i = 0; i < n; i++) {
    dp[i] = new Array(k + 1);
    for (let j = 0; j <= k; j++) {
      dp[i][j] = new Array(3).fill(0);
    }
  }

  // 初始化第 0 天：可选择开多或开空（各消耗一次交易额度）
  for (let j = 1; j <= k; j++) {
    dp[0][j][1] = -prices[0]; // 多头：成本为 -price
    dp[0][j][2] = prices[0]; // 空头：先获利 price
  }
  for (let i = 1; i < n; i++) {
    for (let j = 1; j <= k; j++) {
      // 结束在空仓：可保持、卖出多单或回补空单
      dp[i][j][0] = Math.max(
        dp[i - 1][j][0],
        Math.max(dp[i - 1][j][1] + prices[i], dp[i - 1][j][2] - prices[i])
      );
      // 持有多单：保持或从空仓买入（消耗一次交易）
      dp[i][j][1] = Math.max(
        dp[i - 1][j][1],
        dp[i - 1][j - 1][0] - prices[i]
      );
      // 持有空单：保持或从空仓开空（消耗一次交易）
      dp[i][j][2] = Math.max(
        dp[i - 1][j][2],
        dp[i - 1][j - 1][0] + prices[i]
      );
    }
  }

  return dp[n - 1][k][0];
}

// @lc code=end

/*
解题思路详解：

1. 题目理解
   - 问题本质：允许做多/做空两类交易，在次数受限的情况下最大化利润。
   - 关键特点：交易必须按顺序进行，且开仓后要在未来某天平仓，
     不能与上一笔同日收尾和下一笔开头重叠。
   - 目标：最大化所有交易收益之和。

2. 算法分析：
   - 时间复杂度：O(nk)，枚举每一天与交易次数的组合。
   - 空间复杂度：O(nk)，三维 DP 数组存储状态（可进一步滚动降维）。
   - 算法类型：动态规划（状态机，分别记录空仓、多头、空头）。

3. 解题思路：
   - 核心思想：dp[i][j][s] 表示第 i 天完成 j 次交易后，状态 s 下的最大
     利润。s=0 空仓，s=1 持有多单，s=2 持有空单。
   - 转移：
     * 维持空仓，或由多单/空单在第 i 天平仓。
     * 多单来自保持前一天多单，或者由空仓买入（消耗一次交易机会）。
     * 空单类似，来自延续或从空仓开空。
   - 初始条件：第 0 天可选择建多或建空，收益分别为 -price[0] 与 price[0]。

4. 实现要点：
   - 三维数组 dp[i][j][s]，i∈[0,n)，j∈[0,k]。
   - 更新顺序为天数递增、交易次数递增，确保依赖已计算。
   - 结果取 dp[n-1][k][0]，即最后一天空仓情况下的最大收益。

5. 算法优势
   - 状态机清晰，能同时处理多头与空头两类操作。
   - 复杂度 O(nk) 在 n<=1e3, k<=500 内可接受。

6. 核心步骤
   - 初始化 dp[0][j][1/2]。
   - 双层循环遍历天数与交易次数，写出三种状态的转移。
   - 返回 dp[n-1][k][0]。

7. 示例分析
   - 示例 1：prices=[1,7,9,8,2],k=2。
     * 第 0 天建多、第 2 天平仓获 8；第 3 天开空、第 4 天回补获 6；
       总计 14。
   - 示例 2：prices=[12,16,19,19,8,1,19,13,9],k=3。
     * 按题述策略依次做多、卖空、再做多，累积 36。

8. 常见错误
   - 忽略卖空场景，仅处理多头，导致收益不完整。
   - 状态定义与交易次数消耗搞混，买入/开空必须使用 j-1 的空仓状态。
   - 初始化缺失导致 dp 数组默认 0，从而无法正确建仓。

10. 扩展思考
   - 若增加手续费，可在平仓时扣减常数。
   - 若限制同一时间最多持有一单，可复用此三状态模型。
   - 可使用滚动数组将空间降为 O(k) 以应对更大 n。
*/
