/*
 * @lc app=leetcode.cn id=2110 lang=typescript
 *
 * [2110] 股票平滑下降阶段的数目
 *
 * https://leetcode.cn/problems/number-of-smooth-descent-periods-of-a-stock/description/
 *
 * algorithms
 * Medium (59.94%)
 * Likes:    830
 * Dislikes: 39
 * Total Accepted:    66.9K
 * Total Submissions: 105K
 * Testcase Example:  '[3,2,1,4]'
 *
 * 给定一个整数数组 prices 表示每日的股价，其中 prices[i] 是第 i 天的价格。
 *
 * 若一段连续的天数满足：除第一天外，其余每一天的价格都比前一天
 * 恰好少 1，则称之为一段平滑下降阶段。
 *
 * 请返回所有平滑下降阶段的总数量。
 *
 *
 * 示例 1：
 *
 *
 * 输入：prices = [3,2,1,4]
 * 输出：7
 * 解释：共有 7 段平滑下降阶段：
 * [3]、[2]、[1]、[4]、[3,2]、[2,1] 与 [3,2,1]。
 * 单独一天也视为平滑下降阶段。
 *
 *
 * 示例 2：
 *
 *
 * 输入：prices = [8,6,7,7]
 * 输出：4
 * 解释：共有 4 段平滑下降阶段：[8]、[6]、[7]、[7]。
 * [8,6] 不是，因为 8 - 6 ≠ 1。
 *
 *
 * 示例 3：
 *
 *
 * 输入：prices = [1]
 * 输出：1
 * 解释：只有 [1]。
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= prices.length <= 10^5
 * 1 <= prices[i] <= 10^5
 *
 *
 */

// @lc code=start
/**
 * 统计股票所有平滑下降阶段（相邻差值恰为 1 的连续子数组数量）。
 *
 * @param prices - 每天的股价列表，长度满足 1 <= n <= 1e5。
 * @returns 所有平滑下降阶段的数量。
 */
function getDescentPeriods(prices: number[]): number {
  const n = prices.length;
  let total = 0; // 全部平滑下降阶段数量
  let streak = 0; // 以当前天结尾的平滑下降阶段长度

  for (let i = 0; i < n; i++) {
    if (i > 0 && prices[i - 1] - 1 === prices[i]) {
      streak += 1; // 能衔接前一天，则长度 +1
    } else {
      streak = 1; // 否则从当前天重新开始
    }
    total += streak; // 当前结尾的阶段数等于长度本身
  }
  return total;
}
// @lc code=end

/*
解题思路详解：

1. 题目理解
   - 问题本质：统计所有满足相邻差值恰为 1 的连续子数组数量。
   - 关键特点：数组长度可达 1e5，需要线性或接近线性的时间复杂度。
   - 优化目标：无需枚举所有区间，而是找到复用结构的统计方法。

2. 算法分析：
   - 时间复杂度：O(n)，只需一次遍历累加答案。
   - 空间复杂度：O(1)，仅用常数变量记录当前阶段长度。
   - 算法类型：线性扫描 + 动态规划（以当前位置作为状态）。

3. 解题思路：
   - 核心思想：如果第 i 天能和 i-1 天连接形成平滑下降阶段，则以 i 结尾的
     阶段数量比上一天多 1，否则重置为 1。
   - 推导过程：以 i 结尾的平滑下降子数组数量恰好等于当前连续长度
     streak，直接累加即可得到总数。
   - 主要步骤概述：
     1) 初始化 total=0、streak=0。
     2) 逐日扫描；若 prices[i-1]-1 === prices[i]，则 streak++，否则 streak=1。
     3) 每轮将 streak 加入 total，最终即为答案。

4. 实现要点：
   - 关键数据结构：只需常数变量，避免额外数组。
   - 核心算法步骤：比较相邻元素差值，维护 streak 和 total。
   - 边界情况处理：第一天必须单独计入（streak 置 1）。

5. 算法优势（可选）
   - 单次遍历即可完成，性能最优。
   - 不需要复杂数据结构，代码简洁易维护。

6. 核心算法步骤（可选）
   - 初始化 total=0、streak=0。
   - 遍历数组，若满足平滑下降条件则 streak++，否则重置为 1。
   - 在每次迭代中将 streak 累加到 total。

7. 示例分析
   - 示例一 [3,2,1,4]：
     - i=0：streak=1,total=1。
     - i=1：2=3-1，streak=2,total=3。
     - i=2：1=2-1，streak=3,total=6。
     - i=3：4 不满足条件，streak=1,total=7。
   - 示例二 [8,6,7,7]：
     - 6 与 8 差值为 2，无法连接，因而只有 4 段单独的长度 1 子数组。
   - 示例三 [1]：只有一日，自然只有一段。

8. 常见错误
   - 将差值判断写成赋值（如 price[i] = price[i-1]-1），导致数据被覆盖。
   - 忘记把单日的阶段计入答案，造成总数偏小。
   - 遍历从 i=1 开始，未处理第一天导致答案漏 1。

10. 扩展思考
   - 优化思路：若需要统计差值为 k 的下降阶段，只需改为比较 prices[i-1]-k。
   - 类似问题：非递增/递减子数组数量、好子数组计数等，都可以用“以 i
     结尾”思路。
   - 实际应用：用于分析股票连续跌幅区间、监控系统连续指标变化等
     场景。
*/
