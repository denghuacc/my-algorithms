# AI Coding Agent Instructions

## 项目概述

这是一个算法学习项目，包含数据结构实现、算法练习和 LeetCode 题目解答。项目的核心目标是通过高质量的代码注释和详细的解题思路来帮助学习和理解算法。本指南适用于所有参与协作的 AI 编码助手（如 GitHub Copilot、Codex、Claude Code 等），以确保不同模型/IDE 都能遵循一致的规范。项目中的主要实现语言为 TypeScript，偶尔会出现 Go、Rust、Python 等其他语言的辅助代码；除非另有说明，优先为 `.ts` 文件提供注释和解题思路，其他语言文件仅在必要时补充说明。

## 适用范围

本指导文档适用于以下文件和目录：

- `algorithms/**/*.ts` - 算法实现文件
- `data-structures/**/*.ts` - 数据结构实现文件
- `leetcode/**/*.ts` - LeetCode 题目解答
- `leetcode-pick/**/*.ts` - 精选 LeetCode 题目
- `cracking-the-coding-interview/**/*.ts` - 程序员面试金典题目

## 代码注释规范

### 文件头部注释

对于算法实现文件，应包含：

````typescript
/**
 * 算法名称 - 简短描述
 *
 * @description 详细描述算法的用途和特点
 * @timeComplexity O(?) - 时间复杂度
 * @spaceComplexity O(?) - 空间复杂度
 * @category 算法分类（如：排序、搜索、动态规划等）
 *
 */
````

### 函数注释规范

每个函数都应该有清晰的 JSDoc 注释：

````typescript
/**
 * 函数功能描述
 *
 * @param paramName - 参数描述，包括类型和约束
 * @returns 返回值描述
 * @throws 可能抛出的异常描述
 *
 */
````

### 行内注释规范

- **关键步骤注释**：解释算法的核心步骤
- **复杂逻辑注释**：说明不直观的代码逻辑
- **优化点注释**：解释为什么这样实现（性能、空间等考虑）
- **边界条件注释**：说明特殊情况的处理

```typescript
const MOD = 1e9 + 7; // 取模常量
let cnt = 0; // 当前连续 1 的长度
let res = 0; // 结果总数

// 遍历字符串的每个字符
for (const ch of s) {
  if (ch === "1") {
    // 遇到 1，连续长度加 1
    cnt++;
  } else {
    // 遇到 0，说明一段连续的 1 结束了
    // 计算这段连续 1 能组成的子串数量：cnt * (cnt + 1) / 2
    // 这是组合数学中的求和公式：1 + 2 + 3 + ... + n = n(n+1)/2
    res = (res + (((cnt * (cnt + 1)) / 2) % MOD)) % MOD;
    cnt = 0; // 重置计数器
  }
}

// 处理最后一段连续的 1（如果字符串以 1 结尾）
res = (res + (((cnt * (cnt + 1)) / 2) % MOD)) % MOD;

return res;
```

### 注释与解题思路的换行要求

- 所有注释（文件头、函数 JSDoc、行内注释等）以及“解题思路”部分的文字说明，必须遵守
  print width 100 的限制。
- 当单行内容超过 100 个字符时，必须进行人工换行并保持语义完整，禁止出现超过限制的
  单行长注释。
- 所有 AI Agent 在编写或更新任何说明文字时，都必须遵循该限制，视为强制性规则。

## LeetCode 题目解答规范

### 文件结构要求

**严格按照三段式结构组织代码，绝对不能打乱顺序：**

1. **题目描述部分**（顶部）- 来自 LeetCode 插件，**禁止修改**
2. **算法实现部分**（中间）- 在 `@lc code=start` 和 `@lc code=end` 之间
3. **解题思路部分**（底部）- 详细的思路分析和总结

### 解题思路注释模板

当解答算法题时，请按照以下结构提供详细的解答：

#### 1. 题目理解

- **问题本质**：用1-2句话概括问题的核心
- **关键特点**：列出题目的重要特征和约束条件
- **目标**：明确要优化的指标（时间、空间、最值等）

#### 2. 解题思路

##### 核心思想

- 说明采用的主要算法思路或数据结构
- 解释为什么选择这种方法

##### 算法步骤

按顺序列出具体的解题步骤：

1. **第一步**：数据预处理或初始化
2. **第二步**：核心算法逻辑
3. **第三步**：结果处理或优化

#### 3. 代码实现

##### 完整代码

```typescript
// 提供完整的、可运行的代码实现
// 包含详细的注释说明关键步骤
```

##### 关键函数说明

- 解释核心函数的作用和参数
- 说明重要的数据结构选择

#### 4. 复杂度分析

- **时间复杂度**：O(?) 并解释为什么
- **空间复杂度**：O(?) 并解释为什么
- **关键观察**：导致该复杂度的核心原因

#### 5. 示例分析

至少要列出2~3个具体示例进行说明

##### 图解过程

- 用具体示例展示算法执行过程
- 画出关键的数据结构变化
- 逐步展示算法的每个阶段

##### 边界情况

- 列出需要特别处理的边界情况
- 说明算法如何处理这些情况

#### 6. 算法要点总结

##### 核心技巧

- 总结解题中使用的关键技巧
- 说明可以应用到类似问题的通用方法

##### 优化要点

- 列出提高性能的优化策略
- 解释为什么这些优化有效

##### 类似问题

- 提及可以用相同思路解决的其他问题
- 说明算法的适用范围

#### 7. 常见错误

- 列出容易犯的错误
- 提供避免这些错误的建议
- 至少列出三条实用的避坑指南

---

### 模板使用说明

1. **层次清晰**：从宏观到微观，从思路到实现
2. **图文并茂**：用示例和图解帮助理解
3. **注重细节**：包含复杂度分析和边界情况
4. **举一反三**：总结通用方法和类似问题
5. **实用性强**：提供完整可运行的代码

记住：好的算法解答不仅要正确，更要让读者理解思路、学会方法、触类旁通。

## 算法代码文件结构规范

### 文件结构说明

每个算法代码文件必须严格按照以下三个部分组织，**绝对不能打乱顺序**：

#### 1. 题目描述部分（顶部）

```typescript
/*
 * @lc app=leetcode.cn id=题目编号 lang=typescript
 *
 * [题目编号] 题目标题
 *
 * https://leetcode.cn/problems/问题链接/description/
 *
 * algorithms
 * 难度 (通过率%)
 * Likes:    点赞数
 * Dislikes: 点踩数
 * Total Accepted:    通过次数
 * Total Submissions: 提交次数
 * Testcase Example:  '测试用例'
 *
 * 题目详细描述...
 *
 * 示例：
 * 输入：...
 * 输出：...
 * 解释：...
 *
 * 提示：
 * - 约束条件1
 * - 约束条件2
 */

export {};
```

**重要规则：**

- 这部分内容来自 LeetCode 插件，**禁止修改或删除**
- 保持原有的注释格式和内容
- `lang=typescript` 等语言标识不可更改

#### 2. 算法实现部分（中间）

```typescript
// @lc code=start
function 函数名(参数列表): 返回类型 {
  // 在这里实现算法逻辑
  // 可以添加详细的实现注释
  // 解释关键步骤和数据结构选择
}
// @lc code=end
```

**编码规范：**

- 函数签名来自 LeetCode 插件，**不要修改函数名和参数**
- 在函数内部添加实现代码
- 可以添加辅助函数（在主函数前面）
- 注释要简洁明了，解释关键逻辑
- 使用有意义的变量名

备注：必须保留 LeetCode 提供的函数签名，禁止修改。有的时候 TypeScript 会有多个解法，此时可能会使用了 var 声明多个函数（这是一个 trick 方法），禁止修改函数式子。

#### 3. 解题思路部分（底部）

```typescript
/*
解题思路详解：

1. 问题本质：
   - 核心问题描述
   - 关键特点分析

2. 算法分析：
   - 时间复杂度：O(?)
   - 空间复杂度：O(?)
   - 算法类型：(如：动态规划、贪心、图论等)

3. 解题思路：
   - 核心思想
   - 推导过程 
   - 主要步骤概述

4. 实现要点：
   - 关键数据结构选择
   - 核心算法步骤
   - 边界情况处理

5. 算法优势（可选）
   - 列出解法的几个优点

6. 核心算法步骤（可选）
   - 简单列出算法的每一步骤

7. 示例分析
   - 通过具体例子说明解法的有效性
   - 列出多个示例进行说明

8. 常见错误
   - 实用的避坑指南
   - 列出多条错误和边界情况说明

10. 扩展思考
   - 优化思路：性能优化，代码简化，内存优化
   - 类似问题：总结类似问题列表
   - 深入的变种和优化思考
   - 实际应用和场景分析
   - 数学公式和推导（可选）
*/
```

### AI Agent 操作指南

#### ✅ 允许的操作

1. **在算法实现部分**：

   - 编写函数实现代码
   - 添加辅助函数
   - 添加实现注释
   - 优化算法逻辑

2. **在解题思路部分**：
   - 添加详细的思路分析
   - 解释算法原理
   - 分析复杂度
   - 提供优化建议

#### ❌ 禁止的操作

1. **不要修改题目描述部分**：

   - 不要删除或修改 LeetCode 插件生成的注释
   - 不要更改 `@lc` 标识
   - 不要修改题目链接和描述

2. **不要破坏文件结构**：

   - 不要在题目描述和代码之间插入解题思路
   - 不要将代码实现放在文件最后
   - 不要删除 `export {};` 语句

3. **不要修改函数签名**：
   - 函数名、参数名、返回类型保持不变，且禁止修改已有的类或者函数的结构
   - 不要更改 `// @lc code=start` 和 `// @lc code=end` 标记

### 代码风格要求

#### 注释规范

```typescript
// 单行注释：解释具体实现逻辑
/*
 * 多行注释：解释复杂算法思路
 * 或者重要的数据结构设计
 */
```

#### 变量命名

- 使用有意义的变量名：`left`, `right`, `maxValue`
- 避免单字母变量：除了循环变量 `i`, `j`, `k`
- 常量使用大写：`MOD`，`MAX_SIZE`, `DEFAULT_VALUE`

#### 函数组织

```typescript
// @lc code=start
function 主函数(params): type {
  // 主要逻辑


  // 辅助函数（如果需要）
  function helper(params): type {
    // 实现
  }
}
// @lc code=end
```

### 示例文件结构

参考 `leetcode/1513.仅含-1-的子串数` 的完整结构，确保新文件遵循相同的格式规范。

---

**记住：结构稳定性 > 代码完美性**
保持文件的三段式结构比任何代码优化都重要！

## TypeScript 代码规范

使用当前流行的 TypeScript 代码规范即可，这里不做赘述了，确保代码清晰、易读且高效。

## AI Agent 工作指南

作为在本项目中协作的任何 AI 编码助手（如 GitHub Copilot、Codex、Claude Code 等），在处理任务时请：

1. **严格遵循文件结构**：特别是 LeetCode 文件的三段式结构
2. **提供教学性注释**：不仅要有代码实现，更要有思路解释
3. **注重算法分析**：每个解法都要有时间和空间复杂度分析
4. **包含示例追踪**：通过具体例子展示算法执行过程
5. **考虑多种解法**：在可能的情况下提供不同的解题思路
6. **优化意识**：说明代码的优化点和改进空间
7. **实践导向**：注释要有助于读者理解和学习算法思想

### 代码质量要求

### 性能优化指导

#### 时间复杂度优化

```typescript
// ✅ 优化前：O(n²) 暴力解法
// 说明为什么这个复杂度不够好
for (let i = 0; i < n; i++) {
  for (let j = i + 1; j < n; j++) {
    // 暴力搜索
  }
}

// ✅ 优化后：O(n) 哈希表解法
// 说明如何通过数据结构优化时间复杂度
const map = new Map();
for (let i = 0; i < n; i++) {
  // 利用哈希表的O(1)查找特性
}
```

#### 空间复杂度优化

```typescript
// ✅ 空间优化：将二维DP压缩为一维
// 说明为什么可以这样优化，以及如何保证正确性
const dp = new Array(n).fill(0);
for (let i = 0; i < m; i++) {
  // 从后往前更新，避免覆盖还需要使用的值
  for (let j = n - 1; j >= 0; j--) {
    dp[j] = Math.max(dp[j], dp[j - 1] + nums[i]);
  }
}
```

### 编写风格偏好

#### 1. 注释密度

- 每个关键步骤都要有注释
- 复杂的一行代码要有解释，有难度的逻辑可以多行注释
- 不明显的优化技巧要说明原因

#### 2. 代码可读性

- 使用有意义的变量名
- 适当的空行分隔逻辑块
- 一致的缩进和格式

#### 3. 教学性质

- 优先考虑代码的可理解性
- 在注释中解释"为什么"而不仅是"做什么"
- 提供多种解法的对比（如果有多种解法）

记住：这个项目的价值在于学习过程，而不仅仅是解决问题。好的注释和思路分析比完美的代码更重要。
