/*
 * @lc app=leetcode.cn id=933 lang=typescript
 *
 * [933] 最近的请求次数
 *
 * https://leetcode-cn.com/problems/number-of-recent-calls/description/
 *
 * algorithms
 * Easy (73.06%)
 * Likes:    141
 * Dislikes: 0
 * Total Accepted:    55.8K
 * Total Submissions: 74.4K
 * Testcase Example:  '["RecentCounter","ping","ping","ping","ping"]\n[[],[1],[100],[3001],[3002]]'
 *
 * 写一个 RecentCounter 类来计算特定时间范围内最近的请求。
 *
 * 请你实现 RecentCounter 类：
 *
 *
 * RecentCounter() 初始化计数器，请求数为 0 。
 * int ping(int t) 在时间 t 添加一个新请求，其中 t 表示以毫秒为单位的某个时间，并返回过去 3000
 * 毫秒内发生的所有请求数（包括新请求）。确切地说，返回在 [t-3000, t] 内发生的请求数。
 *
 *
 * 保证 每次对 ping 的调用都使用比之前更大的 t 值。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：
 * ["RecentCounter", "ping", "ping", "ping", "ping"]
 * [[], [1], [100], [3001], [3002]]
 * 输出：
 * [null, 1, 2, 3, 3]
 *
 * 解释：
 * RecentCounter recentCounter = new RecentCounter();
 * recentCounter.ping(1);     // requests = [1]，范围是 [-2999,1]，返回 1
 * recentCounter.ping(100);   // requests = [1, 100]，范围是 [-2900,100]，返回 2
 * recentCounter.ping(3001);  // requests = [1, 100, 3001]，范围是 [1,3001]，返回 3
 * recentCounter.ping(3002);  // requests = [1, 100, 3001, 3002]，范围是
 * [2,3002]，返回 3
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= t <= 10^9
 * 保证每次对 ping 调用所使用的 t 值都 严格递增
 * 至多调用 ping 方法 10^4 次
 *
 *
 */

export {};

// @lc code=start
/**
 * 最近的请求次数计数器
 *
 * 核心思想：
 * 1. 使用队列存储请求时间戳
 * 2. 每次新请求到达时，移除超过3000毫秒的旧请求
 * 3. 返回当前队列长度，即最近3000毫秒内的请求数
 *
 * 为什么使用队列：
 * - 请求时间戳是严格递增的
 * - 超时的请求总是在队列头部
 * - 队列的先进先出特性完美匹配这个场景
 */
class RecentCounter {
  requests: number[]; // 存储请求时间戳的队列

  /**
   * 构造函数：初始化空的请求队列
   * 时间复杂度：O(1)
   * 空间复杂度：O(1)
   */
  constructor() {
    this.requests = [];
  }

  /**
   * 处理新的ping请求，返回最近3000毫秒内的请求总数
   * 时间复杂度：O(k)，k为需要移除的过期请求数量，平均情况下接近O(1)
   * 空间复杂度：O(n)，n为队列中保存的请求数量，最多为3000毫秒内的请求数
   *
   * @param t 当前请求的时间戳（毫秒）
   * @returns 在[t-3000, t]时间范围内的请求总数
   */
  ping(t: number): number {
    // 将新请求时间戳加入队列末尾
    this.requests.push(t);

    // 移除所有超过3000毫秒的旧请求
    // 由于时间戳严格递增，超时的请求总是在队列头部
    while (this.requests[0] < t - 3000) {
      this.requests.shift(); // 移除队列头部的过期请求
    }

    // 返回当前队列长度，即最近3000毫秒内的请求数
    return this.requests.length;
  }
}

/**
 * Your RecentCounter object will be instantiated and called as such:
 * var obj = new RecentCounter()
 * var param_1 = obj.ping(t)
 */
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 实现一个计数器，统计最近3000毫秒内的请求数量
   - 每次新请求到达时，需要快速计算当前时间窗口内的请求总数
   - 时间窗口是滑动的：[t-3000, t]

2. 算法分析：
   - 时间复杂度：
     * 构造函数：O(1)
     * ping方法：摊销O(1)，最坏情况O(k)，k为需要移除的过期请求数
   - 空间复杂度：O(n)，n为最近3000毫秒内的请求数量
   - 算法类型：队列应用、滑动窗口、数据流处理

3. 实现要点：
   - **数据结构选择**：队列（使用数组模拟）
     * 利用请求时间戳严格递增的特性
     * 过期请求总是在队列头部，新请求总是在队列尾部
   
   - **核心操作**：
     * 入队：每次ping时将新时间戳加入队列尾部
     * 出队：移除队列头部所有过期的时间戳
     * 计数：返回当前队列长度
   
   - **时间窗口维护**：
     * 窗口大小固定为3000毫秒
     * 窗口随着新请求到达而滑动
     * 只保留窗口内的有效请求

4. 为什么选择队列：
   - **时间有序性**：请求时间戳严格递增
   - **FIFO特性**：最早的请求最先过期
   - **高效性**：避免了对所有历史请求的遍历
   - **自然匹配**：队列的特性完美契合滑动窗口的需求

5. 优化思路：
   - 当前实现已经是最优的，平均时间复杂度接近O(1)
   - 可以使用双端队列(deque)优化头部删除操作，但JavaScript原生不支持
   - 空间复杂度无法进一步优化，必须保存窗口内的所有请求
   - 可以考虑批量删除过期请求以减少操作次数

6. 类似问题：
   - 239. 滑动窗口最大值（固定大小滑动窗口）
   - 346. 数据流中的移动平均值（固定大小窗口的平均值）
   - 362. 敲击计数器（时间窗口内的事件计数）
   - 1429. 第一个唯一数字（数据流处理）

7. 拓展应用：
   - **Web服务器**：限流器实现，统计请求频率
   - **监控系统**：计算QPS、错误率等实时指标
   - **游戏开发**：技能冷却时间、连击计数
   - **日志分析**：时间窗口内的事件聚合

8. 其他解法对比：
   - **暴力解法**：每次遍历所有历史请求
     * 时间复杂度：O(n)，空间复杂度：O(n)
     * 效率低下，不实用
   
   - **哈希表计数**：按时间戳分组计数
     * 时间复杂度：O(k)，k为时间窗口大小
     * 空间复杂度可能更高，实现复杂
   
   - **环形缓冲区**：固定大小的缓冲区
     * 适用于请求频率稳定的场景
     * 实现复杂，不如队列直观

9. 常见错误：
   - 忘记移除过期的请求，导致计数错误
   - 没有正确理解时间窗口的含义（开区间vs闭区间）
   - 使用错误的数据结构（如普通数组的线性删除）
   - 边界条件处理：空队列、单个请求等
   - 时间戳比较错误（< vs <=）
*/
