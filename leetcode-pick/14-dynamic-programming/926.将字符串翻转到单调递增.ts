/*
 * @lc app=leetcode.cn id=926 lang=typescript
 *
 * [926] 将字符串翻转到单调递增
 *
 * https://leetcode.cn/problems/flip-string-to-monotone-increasing/description/
 *
 * algorithms
 * Medium (60.55%)
 * Likes:    205
 * Dislikes: 0
 * Total Accepted:    17.8K
 * Total Submissions: 29.5K
 * Testcase Example:  '"00110"'
 *
 * 如果一个二进制字符串，是以一些 0（可能没有 0）后面跟着一些 1（也可能没有 1）的形式组成的，那么该字符串是 单调递增 的。
 *
 * 给你一个二进制字符串 s，你可以将任何 0 翻转为 1 或者将 1 翻转为 0 。
 *
 * 返回使 s 单调递增的最小翻转次数。
 *
 *
 *
 * 示例 1：
 *
 *
 * 输入：s = "00110"
 * 输出：1
 * 解释：翻转最后一位得到 00111.
 *
 *
 * 示例 2：
 *
 *
 * 输入：s = "010110"
 * 输出：2
 * 解释：翻转得到 011111，或者是 000111。
 *
 *
 * 示例 3：
 *
 *
 * 输入：s = "00011000"
 * 输出：2
 * 解释：翻转得到 00000000。
 *
 *
 *
 *
 * 提示：
 *
 *
 * 1 <= s.length <= 10^5
 * s[i] 为 '0' 或 '1'
 *
 *
 */

// @lc code=start
/**
 * 动态规划解法
 * 核心思想：对于每个位置，维护以0结尾和以1结尾的最小翻转次数
 */
function minFlipsMonoIncr(s: string): number {
  const n = s.length;
  // dp0: 当前位置以0结尾的最小翻转次数
  // dp1: 当前位置以1结尾的最小翻转次数
  let dp0 = 0;
  let dp1 = 0;

  for (let i = 0; i < n; i++) {
    const c = s[i];
    // 新的状态值
    let dp0New = dp0; // 以0结尾，只能从之前的0状态转移
    let dp1New = Math.min(dp1, dp0); // 以1结尾，可以从之前的0或1状态转移

    if (c === "1") {
      // 当前字符是1，如果要以0结尾需要翻转
      dp0New++;
    } else {
      // 当前字符是0，如果要以1结尾需要翻转
      dp1New++;
    }

    // 更新状态
    dp0 = dp0New;
    dp1 = dp1New;
  }

  // 返回最终的最小翻转次数
  return Math.min(dp0, dp1);
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 将二进制字符串转换为单调递增形式（先0后1）
   - 每次可以翻转一个字符（0变1或1变0）
   - 求最小翻转次数

2. 算法分析：
   - 时间复杂度：O(n)，其中n是字符串长度
   - 空间复杂度：O(1)，只使用常数空间
   - 算法类型：动态规划

3. 实现要点：
   - 状态定义：dp0[i]表示前i个字符以0结尾的最小翻转次数
   - 状态定义：dp1[i]表示前i个字符以1结尾的最小翻转次数
   - 状态转移：
     * dp0[i] = dp0[i-1] + (s[i] == '1' ? 1 : 0)  // 以0结尾只能从0状态转移
     * dp1[i] = min(dp0[i-1], dp1[i-1]) + (s[i] == '0' ? 1 : 0)  // 以1结尾可以从0或1状态转移

4. 优化思路：
   - 空间优化：只保存前一个状态，不需要保存整个dp数组
   - 状态压缩：使用两个变量代替dp数组
   - 贪心思想：以1结尾时总是选择较小的前驱状态

5. 边界情况：
   - 空字符串返回0
   - 单个字符的情况
   - 全0或全1的字符串

6. 类似问题：
   - 编辑距离
   - 最长递增子序列
   - 其他字符串转换问题

7. 关键洞察：
   - 单调递增的二进制字符串必然是形如"000...111..."的形式
   - 对于每个位置，只需要考虑以0结尾或以1结尾两种情况
   - 一旦选择了以1结尾，后续所有位置都必须以1结尾
*/
