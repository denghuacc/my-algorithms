/*
 * @lc app=leetcode.cn id=213 lang=typescript
 *
 * [213] 打家劫舍 II
 *
 * https://leetcode-cn.com/problems/house-robber-ii/description/
 *
 * algorithms
 * Medium (30.96%)
 * Likes:    308
 * Dislikes: 0
 * Total Accepted:    41.3K
 * Total Submissions: 107.3K
 * Testcase Example:  '[2,3,2]'
 *
 *
 * 你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
 *
 * 给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。
 *
 * 示例 1:
 *
 * 输入: [2,3,2]
 * 输出: 3
 * 解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。
 *
 *
 * 示例 2:
 *
 * 输入: [1,2,3,1]
 * 输出: 4
 * 解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
 * 偷窃到的最高金额 = 1 + 3 = 4 。
 *
 */

export {};

// @lc code=start
/**
 * 动态规划解法
 * 核心思想：将环形问题转化为两个线性问题
 */
function rob(nums: number[]): number {
  const n = nums.length;
  // 如果只有一个房屋，直接返回
  if (n === 1) return nums[0];

  // 由于房屋围成环形，第一个和最后一个不能同时偷
  // 所以分为两种情况：
  // 1. 偷第一个房屋，不偷最后一个房屋：[0, n-2]
  // 2. 不偷第一个房屋，偷最后一个房屋：[1, n-1]
  return Math.max(robRange(nums, 0, n - 2), robRange(nums, 1, n - 1));

  /**
   * 在指定范围内偷房屋的最大收益
   * @param nums 房屋金额数组
   * @param start 起始位置
   * @param end 结束位置
   * @returns 最大收益
   */
  function robRange(nums: number[], start: number, end: number): number {
    const n = nums.length;
    // 使用滚动数组优化空间复杂度
    let dpI1 = 0; // dp[i+1]
    let dpI2 = 0; // dp[i+2]
    let dpI = 0; // dp[i]

    // 从后往前计算
    for (let i = end; i >= start; i--) {
      // 状态转移：选择偷或不偷当前房屋
      dpI = Math.max(dpI1, nums[i] + dpI2);
      // 更新状态
      dpI2 = dpI1;
      dpI1 = dpI;
    }

    return dpI;
  }
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 打家劫舍的环形版本
   - 房屋围成环形，第一个和最后一个相邻
   - 不能偷相邻的房屋，求最大收益

2. 算法分析：
   - 时间复杂度：O(n)，其中n是数组长度
   - 空间复杂度：O(1)，使用滚动数组
   - 算法类型：动态规划

3. 实现要点：
   - 问题转化：将环形问题转化为两个线性问题
   - 状态定义：dp[i]表示从位置i开始能偷到的最大金额
   - 状态转移：dp[i] = max(dp[i+1], nums[i] + dp[i+2])
   - 边界处理：单个房屋的特殊情况

4. 优化思路：
   - 空间优化：使用滚动数组代替dp数组
   - 问题分解：将环形问题分解为两个线性问题
   - 提前返回：单个房屋的情况

5. 边界情况：
   - 空数组：返回0
   - 单个房屋：返回该房屋的金额
   - 两个房屋：返回较大值

6. 类似问题：
   - 打家劫舍（线性房屋）
   - 打家劫舍III（树形房屋）
   - 其他环形问题

7. 关键洞察：
   - 环形问题的关键在于第一个和最后一个房屋不能同时偷
   - 可以分解为两个线性问题：[0,n-2]和[1,n-1]
   - 取两个问题的最大值

8. 示例分析：
   nums = [2,3,2]
   - 情况1：[0,1] = [2,3]，最大收益 = 3
   - 情况2：[1,2] = [3,2]，最大收益 = 3
   - 结果：max(3, 3) = 3

9. 与打家劫舍I的区别：
   - 打家劫舍I：线性房屋，直接使用动态规划
   - 打家劫舍II：环形房屋，需要分解为两个线性问题
   - 核心思想相同，但需要处理环形约束

10. 状态转移理解：
    - 对于位置i，有两种选择：
      1. 不偷当前房屋：dp[i] = dp[i+1]
      2. 偷当前房屋：dp[i] = nums[i] + dp[i+2]
    - 选择收益较大的方案
    - 由于环形约束，需要分别处理两个范围
*/
