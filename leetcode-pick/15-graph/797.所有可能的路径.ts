/*
 * @lc app=leetcode.cn id=797 lang=typescript
 *
 * [797] 所有可能的路径
 *
 * https://leetcode-cn.com/problems/all-paths-from-source-to-target/description/
 *
 * algorithms
 * Medium (74.03%)
 * Likes:    160
 * Dislikes: 0
 * Total Accepted:    22.1K
 * Total Submissions: 28.7K
 * Testcase Example:  '[[1,2],[3],[3],[]]'
 *
 * 给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序）
 *
 * 二维数组的第 i 个数组中的单元都表示有向图中 i 号节点所能到达的下一些节点，空就是没有下一个结点了。
 *
 * 译者注：有向图是有方向的，即规定了 a→b 你就不能从 b→a 。
 *
 *
 *
 * 示例 1：
 *
 *
 *
 *
 * 输入：graph = [[1,2],[3],[3],[]]
 * 输出：[[0,1,3],[0,2,3]]
 * 解释：有两条路径 0 -> 1 -> 3 和 0 -> 2 -> 3
 *
 *
 * 示例 2：
 *
 *
 *
 *
 * 输入：graph = [[4,3,1],[3,2,4],[3],[4],[]]
 * 输出：[[0,4],[0,3,4],[0,1,3,4],[0,1,2,3,4],[0,1,4]]
 *
 *
 * 示例 3：
 *
 *
 * 输入：graph = [[1],[]]
 * 输出：[[0,1]]
 *
 *
 * 示例 4：
 *
 *
 * 输入：graph = [[1,2,3],[2],[3],[]]
 * 输出：[[0,1,2,3],[0,2,3],[0,3]]
 *
 *
 * 示例 5：
 *
 *
 * 输入：graph = [[1,3],[2],[3],[]]
 * 输出：[[0,1,2,3],[0,3]]
 *
 *
 *
 *
 * 提示：
 *
 *
 * n == graph.length
 * 2 <= n <= 15
 * 0 <= graph[i][j] < n
 * graph[i][j] != i（即，不存在自环）
 * graph[i] 中的所有元素 互不相同
 * 保证输入为 有向无环图（DAG）
 *
 *
 */

// @lc code=start
/**
 * 深度优先搜索 (DFS) 解决方案
 *
 * 核心思想：从源节点开始，使用DFS遍历所有可能的路径，当到达目标节点时记录路径
 */
function allPathsSourceTarget(graph: number[][]): number[][] {
  const n = graph.length;
  const stack = [0]; // 当前路径栈，初始包含源节点0
  const ret: number[][] = []; // 存储所有有效路径

  dfs(0); // 从源节点开始DFS
  return ret;

  /**
   * 深度优先搜索函数
   * @param x 当前访问的节点
   */
  function dfs(x: number) {
    // 如果到达目标节点，记录当前路径
    if (x === n - 1) {
      ret.push(stack.slice()); // 使用slice()创建路径的副本
      return;
    }

    // 遍历当前节点的所有邻居
    for (const y of graph[x]) {
      stack.push(y); // 将邻居加入当前路径
      dfs(y); // 递归访问邻居
      stack.pop(); // 回溯，移除邻居
    }
  }
}
// @lc code=end

/*
解题思路详解：

1. 问题本质：
   - 在有向无环图(DAG)中找出所有从源节点到目标节点的路径
   - 这是一个路径枚举问题，需要遍历所有可能的路径组合

2. 算法分析：
   - 时间复杂度：O(2^n * n)，其中n是节点数
     * 最坏情况下，每个节点都有多个选择，路径数量呈指数增长
     * 每条路径最多包含n个节点
   - 空间复杂度：O(n)，递归调用栈深度和路径栈
   - 算法类型：深度优先搜索 (DFS)

3. 实现要点：
   - 使用栈(stack)记录当前路径
   - 使用回溯法：访问完一个分支后，需要移除该节点继续探索其他分支
   - 当到达目标节点(n-1)时，将当前路径的副本加入结果集
   - 由于是DAG，不需要visited数组避免重复访问

4. 优化思路：
   - 使用slice()创建路径副本，避免引用问题
   - 利用DAG特性，无需检测环
   - 可以考虑使用记忆化搜索优化重复计算（但此题数据规模较小，直接DFS即可）

5. 关键技巧：
   - 回溯法：push() -> dfs() -> pop() 的标准模式
   - 路径记录：使用数组模拟栈，方便复制和操作
   - 终止条件：到达目标节点时记录路径

6. 类似问题：
   - 全排列问题
   - 组合总和问题
   - 图的路径问题
*/
